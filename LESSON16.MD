Предыдущее занятие |         &nbsp;          | Следующее занятие
:----------------:|:-----------------------:|:----------------:
[Урок 15](LESSON15.MD) | [Содержание](README.MD) | [Урок 17](LESSON17.md)

# Урок 16. String

# Требования к сдаче работы

Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.

***Критерии оценивания***

* Оценка 5 - надо сделать все пять заданий.
* Оценка 4 - надо сделать любые четыре задания.
* Оценка 3 - надо сделать любые три задания.

<details>
<summary>
Оглавление
</summary>

# Оглавление

1. [Класс String](#класс-string)
   * [Строковый литерал](#строковый-литерал)
   * [Пул строк и методы `Object`](#пул-строк-и-методы-object)
   * [Полезные методы `String`](#полезные-методы-string)
2. [Подстроки и внутристроковая нумерация](#подстроки-и-внутристроковая-нумерация)
   * [Нумерация символов внутри строки](#нумерация-символов-внутри-строки)
   * [Получение символа по индексу](#получение-символа-по-индексу)
   * [Составляем простой алгоритм на основе стандартных методов](#составляем-простой-алгоритм-на-основе-стандартных-методов)
3. [Методы String для поиска и получения подстрок](#методы-string-для-поиска-и-получения-подстрок)
   * [Методы для поиска подстрок](#методы-для-поиска-подстрок)
   * [Методы для получения подстрок](#методы-для-получения-подстрок)
4. [Замена строк и свойство неизменяемости](#замена-строк-и-свойство-неизменяемости)
   * [Методы замены строк](#методы-замены-строк)
   * [Свойство неизменяемости](#свойство-неизменяемости)
   * [Плюсы и минусы неизменяемости](#плюсы-и-минусы-неизменяемости)
5. [Задание 1](#задание-1)
6. [Задание 2](#задание-2)
7. [Задание 3](#задание-3)
8. [Задание 4](#задание-4)
9. [Задание 5](#задание-5)
   

</details>

<details>
<summary>Класс String</summary>

# Класс String

Строки в программировании встречаются повсеместно. 
Любое сообщение в браузере, текст для ввода и вывода, время, даты — всё это строки. 

Его объект представляет собой набор символов — **строку** (англ. _string_). Например, текст урока, который вы сейчас читаете, —
это множество объектов `String`. 

Класс `String` — самый популярный в любой программе на `Java`, даже если в коде нет ни одного его экземпляра.
Без строк не обойтись при записи метаинформации, такой как имена классов и импортов. 
Также `String` даёт возможность проводить множество манипуляций со строками: 
проверять их размер и содержание, приводить к нужному регистру.

## Строковый литерал

Поскольку строки являются объектами, их можно создавать через ключевое слово `new`:
```java
String myString = new String("Привет!");
```
 
Однако гораздо проще и удобнее создавать так, как вы делали во всех предыдущих уроках: 
```java
String myString = "Привет!";  
```
При такой записи объект-строка создаётся через строковый **литерал** (англ. _string literal_).
**Литералы** — это заранее определённые константные значения в программе.
Их не могут создать программисты, и они всегда обозначают одно и то же. 
Например, символ `1` — это значение, всегда равное единице, а запись `"кот"` всегда обозначает пушистого домашнего питомца. 
В нашем примере литералом будет запись `"Привет!"`. 

Литералы используются практически во всех языках программирования для создания значений примитивных типов: 

```java
int age = 23; // 23 — числовой литерал
String name = "Байт"; // "Байт" — строковый литерал
boolean isJavaAwesome = true; // true — булев литерал  
```

По возможности всегда создавайте строки через литерал. 
Во-первых, такая запись короче и привычнее для большинства разработчиков. 
Во-вторых, она позволяет JVM использовать специальные оптимизации для строк. 

## Пул строк и методы `Object`

Строки — неизменяемые объекты. Это значит, что вы не сможете подменить символы внутри после инициализации. 
Поэтому для экономии места в оперативной памяти строки с одинаковым значением на уровне JVM могут ссылаться на один и тот же объект. 
При создании строк с помощью литерала они попадают в особое хранилище —  **пул строк** (англ. `string pool`). 
Если строка находится в пуле и вы попытаетесь создать строку с таким же значением,
то она не будет создаваться второй раз. Вместо этого вернётся ссылка на уже существующую. 
Подробнее о пуле строк можно почитать [здесь](https://ru.stackoverflow.com/questions/714949/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%B2-java-%D0%BF%D0%BE-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B5)
или в [официальной документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html). 

Важно запомнить, что строки, которые создаются через new, не попадают в пул. 
Это нужно учитывать при сравнении строк между собой. Вместо оператора == нужно всегда использовать `equals()`. 
Этот метод вместе с `toString()` и `hashCode()` уже корректно переопределены для `String` — как одного из основных классов стандартной библиотеки. 
Вот что произойдёт при сравнении строк через `==`, а не через `equals()`:

```java
public class Practicum {
    public static void main(String[] args) {
        String one = "привет"; // строка попала в пул
        String two = "привет"; // вместо создания новой строки берётся ссылка на уже существующую
        String three = new String("привет"); // создаётся новый объект

        System.out.println(one==two); // вернёт true
        System.out.println(one==three); // вернёт false
    }
}
```

```
Результат

true

false
```

Хотя все три строки одинаковые, у них отличается способ создания, 
и их сравнение через `==` вернёт как `true`, так и `false`.

Если бы строки сравнивались через `equals()`, 
то результат был бы корректным (поскольку происходит сравнение значений, а не ссылок).

```java
public class Practicum {
    public static void main(String[] args) {
        String one = "привет";
        String two = "привет";
        String three = new String("привет");

        System.out.println(one.equals(two)); // вернёт true
        System.out.println(one.equals(three)); // вернёт true
    }
}
```

```
Результат

true

true
```

Другой метод класса `Object` — `toString()`, который обычно используется, чтобы создать строковое представление объекта, при вызове для строк просто возвращает их самих.

## Полезные методы `String`

Класс `String` содержит несколько десятков методов. Знать все необязательно, но некоторые стоит запомнить. 
Например, узнать, сколько символов в строке, можно с помощью метода `length()`. Метод `isEmpty()` возвращает ответ, 
является ли строка пустой или нет. Если использовать их вместе, 
то можно заглянуть в содержание строки. Допустим, нужно проверить, есть ли в строке нужное количество символов:

```java
public class PasswordChecker {
    public boolean checkPassword(String password) {
        if (password.isEmpty()) { // проверяем, не является ли строка пустой
            System.out.println("Пароль отсутствует.");
            return false;
        } else if (password.length() < 8) { // размер строки не должен быть меньше 8 символов
            System.out.println("Пароль слишком короткий.");
            return false;
        }
        System.out.println("Подходящий пароль.");
        return true;
    }

    public static void main(String[] args) {
        PasswordChecker checker = new PasswordChecker();

        System.out.println(checker.checkPassword(""));           // false
        System.out.println(checker.checkPassword("S34fd1265Jd")); // true
        System.out.println(checker.checkPassword("          "));  // true
        System.out.println(checker.checkPassword("shortpw"));    // false
    }
}
```
```
Результат

Пароль отсутствует.

false

Подходящий пароль.

true

Подходящий пароль.

true

Пароль слишком короткий.

false

```

В этом коде методы `isEmpty()` и `length()` отвечают за то, чтобы пароль содержал не меньше восьми символов и не был пустым. 
Поменяйте значение строк и посмотрите, как изменится результат. 

Обратите внимание на «пустую» строку `"          "` (англ. _string blank_).
Она состоит только из пробелов. Да, пробелы — это тоже символы! Такие строки
из пробелов встречаются очень часто, и для их обработки тоже есть методы. `isBlank()` 
вернёт `true`, если строка действительно пустая (`""`) или содержит только пробельные символы. 
Метод `trim()` (англ. «обрезать») возвращает строку, из которой удалены пробельные символы в начале и в конце.

```java
public class Practicum {
    public static void main(String[] args) {
        String blank = "   ";
        String notBlank = "Тут пробелы или строка?!";
        System.out.println(blank.isBlank()); // true
        System.out.println(notBlank.isBlank()); // false

        String withBlanks = "  Привет, у меня тут лишние пробелы!";
        String trimmed = withBlanks.trim();
        System.out.println(trimmed);
    }
}
```
```
Результат

true

false

Привет, у меня тут лишние пробелы!
```


Строки могут состоять как из строчных, так и из прописных букв. 
Поэтому класс String предоставляет методы `toUpperCase()` и `toLowerCase()` для перевода строки в верхний и нижний регистры:

```java
public class Practicum {
    public static void main(String[] args) {
        String text = "Привет, я Java!";
        System.out.println(text.toUpperCase()); // выведет "ПРИВЕТ, Я JAVA!"
        System.out.println(text.toLowerCase()); // выведет "привет, я java!"
    }
}
```
```
Результат

ПРИВЕТ, Я JAVA!

привет, я java!
```

</details>

<details>
<summary>Подстроки и внутристроковая нумерация</summary>

# Подстроки и внутристроковая нумерация

При работе со строками часто нужно найти и потом изменить некоторые слова или отдельные символы. 
Это может понадобиться, например, для исправления орфографических ошибок в текстовом редакторе или 
чтобы найти нужную информацию в браузере. Для обработки этих и подобных задач используются подстроки. 
О них и поговорим в этом уроке. 

**Подстрока** (англ. _substring_) — это непрерывный набор символов внутри строки.
Например, «**обед**» — подстрока для «п**обед**а», а словосочетание «**упала на лапу**» содержится в строке «А роза **упала на лапу** Азора». 
А вот «**саёт**» не будет подстрокой для «**са**мол**ёт**» — так как тут нарушена последовательность символов. 

Строка также всегда будет подстрокой и для самой себя. 
Однако важно запомнить, что подстроки чувствительны к регистру. 
К примеру, «**чай**» будет подстрокой для «**чай**», 
но не будет для «**Чай**», а «**Кар**» не входит в «**картошка**», но входит в «**Карлсон**».

![img.png](img.png)

## Нумерация символов внутри строки

Ориентироваться внутри строк и искать подстроки позволяет внутренняя нумерация символов. 
Она ничем не отличается от нумерации в массиве и тоже начинается с **нуля**. Свой номер есть у каждого «символа»,
будь это цифра, символ алфавита, пробел или даже спецсимвол. Например, 
в строке `"Java"` символ `"v"` находится на второй позиции, а символ `"J"` на нулевой. 

![img_1.png](img_1.png)

Для манипуляций с подстроками в классе `String` предусмотрены свои методы. Например, с помощью `indexOf(String str)` и `lastIndexOf(String str)` 
можно найти индекс начала подстроки. Разница методов в том, что `indexOf` ищет слева направо, а `lastIndexOf` — справа налево. Если подстрока не найдена, вернётся `-1`.

```java
public class Practicum {
    public static void main(String[] args) {
        String start = "Hello, world!";
        System.out.println(start.indexOf("world"));
    }
}
```
Будет напечатано `7`. Это индекс элемента `"w"`, с которого начинается подстрока `"world"`. 

![img_2.png](img_2.png)

Методы `indexOf()` и `lastIndexOf()` также могут принимать в качестве второго аргумента индекс, с которого нужно начать поиск. 
В этом случае их сигнатура будет такой — `indexOf(String str, int fromIndex)` и `lastIndexOf(String str,int fromIndex)`. 
Искать, начиная от конкретного символа, полезно, когда вы точно знаете, где 
находится искомая подстрока. Однако если начать поиск не с того элемента, то можно вообще её не найти:

```java
public class Practicum {
    public static void main(String[] args) {
        String start = "Hello, world!";
        System.out.println(start.indexOf("world", 10));
    }
}
```
Метод вернёт -1, так как с позиции 10 при движении слева направо подстроку "world" обнаружить не получилось. 

![img_3.png](img_3.png)

## Получение символа по индексу

Получить элемент можно с помощью метода `charAt(int index)`.
Его, к слову, удобно использовать в циклах для прохода по всем элементам строки. 
В качестве аргумента в метод передаётся индекс:

```java
public class Practicum {
    public static void main(String[] args) {
        String soManyMethods = "Опять много новых методов!";
        System.out.println(soManyMethods.charAt(5)); // выведет пробел
        System.out.println(soManyMethods.charAt(14)); // выведет 'в'
        System.out.println(soManyMethods.charAt(54)); // выдаст исключение
    }
}
```

```
Результат

Exception in thread "main" java.lang.StringIndexOutOfBoundsException: index 54,length 26

	at java.base/java.lang.String.checkIndex(String.java:3278)

	at java.base/java.lang.StringUTF16.checkIndex(StringUTF16.java:1470)

	at java.base/java.lang.StringUTF16.charAt(StringUTF16.java:1267)

	at java.base/java.lang.String.charAt(String.java:695)

	at Practicum.main(Practicum.java:6)
в
```
Символ по индексу обязательно должен существовать, иначе программа выбросит исключение `StringIndexOutOfBoundsException` (англ. «**индекс находится за границами строки**»). 

## Составляем простой алгоритм на основе стандартных методов

Методы стандартной библиотеки — полезные инструменты. Но нужно не только знать их, но и уметь объединять в новые. Допустим, вам нужно написать метод, 
который будет проверять, что какая-то подстрока встречается в строке только один раз. Назовём его, например, `boolean onlySingleSubstring(String initialString, String substring)`. 

```java
onlySingleSubstring("раз два три",      "раз", ); // тут метод должен вернуть true
onlySingleSubstring("раз два, раз два", "раз", ); // а тут false
```

Можно придумать несколько решений, но самое простое — проверить, 
что искомая подстрока входит слева направо (`indexOf(...)`) и справа налево (`lastIndexOf()`) с одинаковым индексом.

```java
public class OnlySubstring {
    public boolean onlySingleSubstring(String initialString, String substring) {
        return initialString.indexOf(substring) == initialString.lastIndexOf(substring);
    }

    public static void main(String[] args) {
        var os = new OnlySubstring();
        System.out.println(os.onlySingleSubstring("раз два, раз два", "раз"));
        System.out.println(os.onlySingleSubstring("раз два", "раз"));
    }
}
```

```
Результат

false

true
```

Если индексы при поиске подстроки не совпадают, значит, методы обнаруживали несколько повторов. 
Чтобы придумать даже такой простой алгоритм, нужно хорошо знать стандартные методы. 

</details>


<details>

<summary>Методы String для поиска и получения подстрок</summary>

# Методы String для поиска и получения подстрок


## Методы для поиска подстрок

Всего в `String` три метода для поиска подстроки:
* `boolean contains(String other)` возвращает `true`, если подстрока будет обнаружена в любом месте строки, иначе `false`;
* `boolean startsWith(String other)` вернёт `true`, если подстрока находится в начале строки, иначе `false`;
* `boolean endsWith(String other)` вернёт `true`, если подстрока в конце строки, иначе `false`.

```java
public class Practicum {
    public static void main(String[] args) {
        System.out.println("раз два три".contains("раз"));    // true
        System.out.println("раз два три".contains("два"));    // true
        System.out.println("раз два три".contains("три"));    // true

        System.out.println("раз два три".startsWith("раз"));  // true
        System.out.println("раз два три".startsWith("два"));  // false
        System.out.println("раз два три".startsWith("три"));  // false

        System.out.println("раз два три".endsWith("раз"));    // false
        System.out.println("раз два три".endsWith("два"));    // false
        System.out.println("раз два три".endsWith("три"));    // true
	}
}
```
```
Результат

true
true
true
true
false
false
false
false
true
```


## Методы для получения подстрок

Часто возникает необходимость не только найти подстроку, но и получить её. 
Это может понадобиться, например, чтобы создать инициалы из имени и отчества — из строк в этом случае нужно взять только первые символы.
Для решения таких задач в классе `String` предусмотрены методы `String substring(int beginIndex, int endIndex)` и 
`String substring(int beginIndex)`. Они принимают индексы и возвращают искомую подстроку или символ. 

Разберём их. 
* `String substring(int beginIndex)`

Если передать в метод `String substring(int beginIndex)` один индекс `beginIndex`, то он вернёт все символы, начиная от этого индекса и до самого конца строки.

```java
public class Practicum {
    public static void main(String[] args) {
        System.out.println("abcde".substring(3)); 
    }
}
```

Элемент `"d"` идёт в строке под индексом `3`, и после него есть только элемент `"e"`, поэтому метод вернул подстроку `"de"`.

![img_4.png](img_4.png)

* `String substring(int beginIndex, int endIndex)`

Второй вариант — передать в `substring()` два индекса: не только начальный `beginIndex`, но и конечный `endIndex`. 
В этом случае метод вернёт подстроку, начиная от символа с `beginIndex` и заканчивая символом с индексом `endIndex-1`. Символ с индексом `endIndex` исключается из результата.


```java
public class Practicum {
    public static void main(String[] args) {
        System.out.println("abcde".substring(1, 5));
    }
} 
```

Будет напечатана подстрока `"bcde"`. Обратите внимание, что несмотря на то, что индекс `5` находится за пределами строки, 
ошибки исключения не будет, так как символ под индексом `4` входит в строку.

![img_5.png](img_5.png)


</details>


<details>

<summary>Замена строк и свойство неизменяемости</summary>

# Замена строк и свойство неизменяемости

Замена строк настолько же необходимая операция, как и их поиск. 
Смена фамилии, переименование улицы — лишь пара возможных примеров, где она нужна. 
В этом уроке разберём методы, с помощью которых можно заменить подстроку или символ, 
а также поговорим о том, как операция замены работает в условиях неизменяемости строк. 

## Методы замены строк

Для замены строк в классе `String` реализованы два метода. 
Первый `String replace(String target, String replacement)` подменяет **все вхождения** подстроки `target` на строку `replacement`. 
Второй `String replaceFirst(String target, String replacement)` заменяет лишь **первое вхождение** искомой подстроки.


```java
public class Practicum {
    public static void main(String[] args) {
        String example = "раз два, раз два";
        System.out.println(example.replace("раз", "три")); // выведет "три два, три два"
        System.out.println(example.replaceFirst("раз", "три")); // выведет "три два, раз два"
    }
}
```

```
Результат

три два, три два

три два, раз два
```

Обратите внимание: оба метода `replace()` и `replaceFirst()` вызываются у объекта класса `String` и одновременно возвращают объект класса `String`. 
Это свойство позволяет объединить несколько вызовов в цепочку (вызывать подряд можно не только эти, но и другие методы `String`). 
Например, если в строке вам нужно заменить все буквы `«а»` на `«А»`, а подстроку `«зелёный»` на `«красный»`, это можно сделать так:

```java
public class Practicum {
    public static void main(String[] args) {
        String vegetables = "Томат — зелёный, а морковка — оранжевая";

        System.out.println(vegetables.replace("а", "А").replaceFirst("зелёный", "красный"));
        // Выведет: "ТомАт — красный, А морковкА — орАнжевАя"
    }
}
```

```
ТомАт — красный, А морковкА — орАнжевАя
```

С помощью методов `replace()` и `replaceFirst()` можно реализовать множество вещей, 
которыми вы пользуетесь каждый день и уже привыкли не замечать. 
Например:
* Автоматическое исправления орфографии при печати — текст с ошибкой или опечаткой заменяется на правильный.
* Автодополнение текста при печати.
* Приведение данных к единому формату. Это актуально, например, при вводе номеров телефонов — 
кто-то из пользователей может записывать номер как `"+7 (999) 999-99-99"`, а кому-то привычнее писать `"89999999999"`. С помощью замены символов разные варианты записи можно унифицировать.

## Свойство неизменяемости

В первом уроке этой темы мы рассказали, что у строк есть одно важное свойство — свойство **неизменяемости** (англ. _immutability_). 
То есть поменять значение отдельных символов внутри строки после инициализации не получится.

```java
public class Practicum {
    public static void main(String[] args) {
        String str = "Меня не получится изменить!";
        str[3] = 'ю'; // код с такой инструкцией не скомпилируется
    }
}
```

```
Результат

submission/Practicum.java:4: error: array required, but String found

        str[3] = 'ю'; // код с такой инструкцией не скомпилируется

           ^

1 error

```
Но ведь мы только что заменяли строки через `replace()` и `replaceFirst()`! Дело в том, что при использовании методов замены 
для неизменяемых объектов всегда создаётся новый объект, а не меняется старый. 
Поэтому вот такой вызов `replace()` ничего не поменяет в программе:

```java
public class Practicum {
    public static void main(String[] args) {
        String greeting = "hello, world";
        greeting.replace("world", "java"); // создаётся новый объект, но никуда не присваивается
        System.out.println(greeting); // по-прежнему выведет hello, world
    }
}
```

Если перенести этот код в `IDEA`, то среда разработки укажет на возможную ошибку — `<Result of 'String.replace()' is ignored>` (англ. «результат вызова String.replace() проигнорирован»).
Чтобы напечаталась изменённая строка, её нужно сохранить в переменную. В нашем примере в `greeting`.

```java
public class Practicum {
    public static void main(String[] args) {
        String greeting = "hello, world";
        greeting = greeting.replace("world", "java"); // новый объект сохранён в greeting
        System.out.println(greeting); // теперь выведет hello, java
    }
}
```

```
Результат

hello, java
```

Чтобы понять, что происходит при выполнении такого кода, посмотрите на рисунок ниже. 

Стрелки указывают на строки и их связь с переменной `greeting`, а цифрами обозначена последовательность действий. 
Сначала (1) где-то в памяти программы создаётся строка `"hello, world"`. Ссылка на неё сохраняется в переменную `greeting`. 
Затем (2) происходит вызов `greeting.replace("world", "java")`, в ходе которого подстрока `"world"` заменяется на `"java"`, и в памяти создаётся новый объект `"hello, java"`. 
Далее (3) переменной `greeting` присваивается ссылка на `"hello, java"`. Строка `"hello, world"`
ещё какое-то время может храниться в памяти, но на неё больше не будет внешних ссылок. 
Затем (4) выводим в консоль содержимое переменной `greeting`, в которой хранится ссылка на новый объект строки, — на экран будет выведено `“hello, java”`.

Обратите внимание: каждое новое строковое значение формируется отдельно от других. Например, строки `“java”` и `“hello, java”` 
возникают в разное время, каждая на своём шаге функции `main()`.

![img_6.png](img_6.png)

## Плюсы и минусы неизменяемости

У неизменяемости есть и достоинства, и недостатки. Начнём с плюсов. 

* Значение неизменяемого объекта внутри метода остаётся постоянным. 
Это значит, что вам не нужно думать над тем, в каких частях программы находится ссылка на объект.
Ни один метод в программе не может изменить неизменяемый объект. Это упрощает понимание программы.

* Неизменяемый объект не может находиться в промежуточном состоянии.
 Его значение (ссылка) может либо измениться, либо нет. Это особенно актуально для сложных и длительных операций. 
Например, если нужно перевести весь текст «Войны и мира» в нижний регистр, 
то неизменяемость гарантирует, что в процессе ни одна часть программы не сможет получить полуготовый текст, где обработана только часть символов.

Однако использование неизменяемых объектов не всегда эффективно. Посмотрим внимательнее на программу по поиску повторений в тексте. 

```java
public class FindRepeats {
    int numberOfRepeats(String text, String substring) {
        int count = 0;
        while (text.contains(substring)) {
            count++;
            text = text.substring(text.indexOf(substring) + substring.length());
        }
        return count;
    }
}
```
Сейчас переменной `text` присваивается каждая найденная подстрока. 
Раскроем этот цикл в последовательность вызовов и изучим его подробнее.

```java
public class Practicum {
    public static void main(String[] args) {

        String text = "раз раз раз раз раз ";
        String entry = "раз ";
        text = text.substring(text.indexOf(entry) + entry.length());
        text = text.substring(text.indexOf(entry) + entry.length());
        text = text.substring(text.indexOf(entry) + entry.length());
        text = text.substring(text.indexOf(entry) + entry.length());
        text = text.substring(text.indexOf(entry) + entry.length());

        System.out.println(text);
    }
}
```

При выполнении такого кода происходит примерно следующее:
1. Каждый вызов `text.substring(text.indexOf(entry) + entry.length());` создаёт новую строку — на каждом шаге из неё удаляется один найденный повтор.
2. Новая строка присваивается `text`.
3. Старое значение строки остаётся в памяти, при этом на него больше нет ссылок из программы. Такие объекты считаются «мусором»,
а механизм их удаления — **сборкой мусора** (англ. _garbage collection_). Сборка мусора периодически запускается средой исполнения **Java**, 
то есть разработчику не приходится специально думать об этом. 
Тем не менее лучше производить меньше мусора, так как его удаление занимает время, а значит, влияет на скорость и отзывчивость программы.

На схеме явно видно, что программа создала несколько похожих, но тем не менее разных строк, и на каждую нужно выделить место в памяти.

![img_7.png](img_7.png)

</details>

<details>

<summary>Задание 1</summary>

# Задание 1

Пользователи веб-сайта часто вставляют лишние пробелы в поля ввода. 
Напишите метод `fixString()` для обрезки ненужных пробелов. 
Он должен возвращать текст "Вы ничего не ввели!", 
если входная строка пустая или состоит из пробельных символов.

```java

public class CleanInput {
    public String fixString(String str) {
        
    }
}

```

## Подсказка

* Для того чтобы проверить, пустая строка или нет, нужен метод isBlank().
* Отчистить строку от лишних пробелов в начале и конце можно с помощью trim().
* Для оформления метода вам понадобится условная конструкция if () {} else {}.

</details>


<details>

<summary>Задание 2</summary>

# Задание 2

Реализуйте методы `capsLock()` и `print()`. 
Первый устанавливает флаг `isCapsLock` в `true` или `false`.
Второй выводит строку в верхнем или оставляет регистр как есть в зависимости от этого флаг

```java
public class TextEditor {

    private boolean isCapsLock = false;

    public void capsLock() {
        // Здесь нужно изменить значение флага isCapsLock на противоположное
    }

    public void print(String str) {
		// а здесь нужно распечатать строку или в верхнем регистре, или без изменений, учитывая флаг
    }
}


```

## Подсказка

* Для изменения значения флага на противоположное можно взять его логическое отрицание `true == !false`.
* Чтобы выбрать, в каком регистре выводить строку, можно использовать условную конструкцию `if (...) {} else {}`.

</details>

<details>

<summary>Задание 3</summary>

# Задание 3

Напишите метод `int numberOfRepeats(String text, String substring)`, который будет возвращать число повторения подстроки `substring` в переданном тексте text. 
Пример

```java
numberOfRepeats("раз два три, раз два три", "раз"); // вернёт 2
numberOfRepeats("Hello, world!", "goodbye"); // вернёт 0 
```

`Practicum.java`

```java
public class Practicum {
    public static void main(String[] args) {
        FindRepeats check = new FindRepeats();
        int count = check.numberOfRepeats("раз, раз, раз", "раз");
        System.out.println(count);
    }
}

```

`FindRepeats.java`

```java
public class FindRepeats {
    int numberOfRepeats(String text, String substring) {

    }
}


```


## Подсказка

* Для хранения числа повторений создайте переменную. Искать повторы поможет метод `contains()`. 
Также понадобится цикл, который будет продолжаться до тех пор, 
пока не найдены все повторения. 
Это будет выглядеть так — `while (text.contains(substring))`.
* Внутри тела цикла нужно считать повторы `count++` и менять значение `text`, удаляя из него текст, где уже были найдены повторения.
* Преобразовать текст нужно через методы `substring()` и `indexOf()`. Конструкция `text.indexOf(substring)` + `substring.length()` вернёт индекс символа, 
следующего за найденной подстрокой. Начиная с этого символа, нужно вернуть остаток текста через `substring()`.

</details>


<details>

<summary>Задание 4</summary>

# Задание 4


Маленькие дети часто забывают, что нужно начинать новое предложение с большой буквы. Помогите им! Реализуйте метод `capitalize()`. 
Он должен переводить первый символ в переданной строке в верхний регистр при помощи метода `toUpperCase()` и возвращать полученную строку.

`Practicum.java`

```java
public class Practicum {
    public static void main(String[] args) {
        Capitalizator check = new Capitalizator();
        System.out.println(check.capitalize("я не волшебник, я только учусь!"));
    }
}

```

`Capitalizator.java`

```java
public class Capitalizator {
    public String capitalize(String str) {
        
    }
}


```

## Подсказка

* Первый символ в строке нужно взять через `substring(0,1)` и перевести в верхний регистр через `toUpperCase()`.
* Затем заглавный символ нужно прибавить к оставшейся строке. Получить её позволит `substring(1)`.

</details>


<details>

<summary>Задание 5</summary>

# Задание 5

Опечатки и орфографические ошибки — проклятье любых текстов.
Бьёмся об заклад, в нашем курсе вам тоже попадались эти субъекты! 
Поэтому предлагаем вам реализовать программу автозамены. Она должна будет исправлять заранее известные недоработки в тексте.

Реализуйте метод `String fixText(String text)`. Он должен:
* Исправлять кавычки `"„"` и `"“"` на `"«"` и `"»"`.
* Убирать опечатку в слове `"цевилизаций"` (на `"цивилизаций"`).
* Убирать лишние символы в начале и в конце строки.
* Начинать строку с большой буквы. Обратите внимание, мы уже добавили в код ранее написанный вами метод `String capitalize(String str)`.

`Practicum.java`

```java
public class TextFixer {

    public String capitalize(String str) {
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }

    public String fixText(String text) {
        // Реализуйте этот метод
         
    }

    public static void main(String[] args) {

        String text = "    история каждой из крупных галактических цевилизаций может быть разделена на три различные, " +
                "ярко выраженные фазы: Борьба за выживание, Любопытство и Утонченность, также именуемые фазами " +
                "„Как?“, „Зачем?“ и „Где?“. Пример: если для первой фазы характерен вопрос: „Как бы нам поесть?“," +
                " а для второй „Зачем мы едим?“, то третья отличается вопросом: „Где бы нам лучше поужинать?“.   ";

        var textFixer = new TextFixer();
        var fixedText = textFixer.fixText(text);
        System.out.println(fixedText);
    }
}


```

## Подсказка

* Вызов метода `trim()`, чтобы убрать начальные и конечные пробелы, и методов `replace()` для замены можно объединить в цепочку вызовов.
* Чтобы заменить кавычки на правильные, нужно два вызова `.replace("„", "«").replace("“", "»")`. 
Ещё один вызов `.replace("цевилизаций", "цивилизаций")` требуется для замены опечатки на правильный результат.
* Можно сразу применить `capitalize()` к результату вызова остальных методов, а можно сначала сохранить промежуточный результат,
а потому передать его в `capitalize()`. В любом случае не забудьте, что текст должен начинаться с заглавной буквы.

</details>




Предыдущее занятие |         &nbsp;          | Следующее занятие
:----------------:|:-----------------------:|:----------------:
[Урок 15](LESSON15.MD) | [Содержание](README.MD) | [Урок 17](LESSON17.MD)