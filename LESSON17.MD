Предыдущее занятие |         &nbsp;          | Следующее занятие
:----------------:|:-----------------------:|:----------------:
[Урок 16](LESSON16.MD) | [Содержание](README.MD) | [Урок 18](LESSON18.MD)

# Урок 17. StringBuilder

# Требования к сдаче работы

Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.

***Критерии оценивания***

* Оценка 5 - надо сделать все задания.
* Оценка 4 - надо сделать любые пять заданий.
* Оценка 3 - надо сделать любые четыре задания.

<details>
<summary>
Оглавление
</summary>

# Оглавление

1. [Особенности объектов `StringBuilder`](#особенности-объектов-stringbuilder)
   * [Методы StringBuilder](#методы-stringbuilder)
      * [Вставка в середину строки](#вставка-в-середину-строки)
      * [Замена подстроки или элемента](#замена-подстроки-или-элемента)
      * [Удаление по индексу](#удаление-по-индексу)
      * [Отзеркаливание текста](#отзеркаливание-текста)
      * [Обрезка строки](#обрезка-строки)
2. [Сборка-разборка строк](#сборка-разборка-строк)
   * [Разделение строки](#разделение-строки)
   * [regex](#regex)
   * [Из массива в строку](#из-массива-в-строку)
   * [Аргумент произвольной длины varargs](#аргумент-произвольной-длины-varargs)
3. [Форматирование строк](#форматирование-строк)
   * [Как происходит форматирование](#как-происходит-форматирование)
   * [Символы преобразования](#символы-преобразования)
   * [Дополнительные параметры символов преобразования](#дополнительные-параметры-символов-преобразования)
   * [Переносы и пустоты](#переносы-и-пустоты) 
4. [Задание 1](#задание-1)
5. [Задание 2](#задание-2)
6. [Задание 3](#задание-3)
7. [Задание 4](#задание-4)
8. [Задание 5](#задание-5)
9. [Задание 6](#задание-6)
10. [Задание 7](#задание-7)
   
</details>

Из-за неизменяемости строк цикличные операции вроде поиска подстроки и её удаления при работе с 
текстами большого размера приведут к созданию большого количества лишних объектов. 
Чтобы этого избежать, в Java существует ещё один класс для работы со строками — `StringBuilder` 
(англ. «строитель строк»).
Он позволяет менять содержание строки без создания новой.

<details>
<summary>Особенности объектов `StringBuilder`</summary>

# Особенности объектов `StringBuilder`

В отличие от `String`, класс `StringBuilder` представляет строку в виде изменяемого набора символов. 
`StringBuilder` — обычный класс, поэтому его объекты создаются через ключевое слово `new`.
Для создания объектов у `StringBuilder` есть разные конструкторы. Но в основном используются два 
из них: конструктор без аргументов или конструктор с одним аргументом-строкой.
С помощью второго можно сразу задать начальное состояние строки.

```java
public class Practicum {
    public static void main(String[] args) {
        StringBuilder example = new StringBuilder("Hello, world!");
        System.out.println(example); // создали строку с начальным значением "Hello, world!"
    }
}
```
```
Результат

Hello, world!
```

Начальное значение может быть любым — измените строку `"Hello, world!"` 
в конструкторе на какую-то другую и перезапустите код.

Если начальное значение строки не задано, то будет создан пустой объект `StringBuilder`.
Для вставки в него элементов предусмотрено множество методов, например `append(String str)`.
Он добавляет подстроку в конец.

```java
public class Practicum {
    public static void main(String[] args) {
        StringBuilder builder = new StringBuilder(); // строка без начального значения
        builder.append("Hello, "); // добавляем подстроку в конец StringBuilder
        builder.append("world!"); // и ещё одну
        System.out.println(builder);
    }
}
```

```
Результат

Hello, world!
```

Внутренняя реализация `StringBuilder` отдалённо похожа на реализацию списка `ArrayList<T>`. 
При создании экземпляра `StringBuilder` выделяется внутренний буфер определённой вместимости,
где и будут храниться элементы. Этот буфер может увеличиваться в размере по необходимости. Кроме того,
вместимость можно задать сразу при создании `StringBuilder` при помощи конструктора, принимающего `int`.

```java
// создаём объект StringBuilder с начальной вместимостью в 100 элементов
StringBuilder sb = new StringBuilder(100); 
```

Объекты `StringBuilder` редко используются как независимые сущности. 
Их основная задача — помочь в создании строки. 
После работы с ними их всегда можно привести к неизменяемой строке `String` с помощью метода `toString()`.

```java
 public class Practicum {
     public static void main(String[] args) {
         StringBuilder builder = new StringBuilder(); // создали объект - изменяемую строку
         builder.append("Hello, ");
         builder.append("world!");

         String asString = builder.toString(); // сделали изменяемую строку неизменяемой
         System.out.println(asString); // выведет "Hello, world!"
     }
}
```

```
Результат

Hello, world!
```

Метод `toString` преобразует
содержимое внутреннего буфера `StringBuilder` в строку и возвращает её в качестве результата.

## Методы StringBuilder

Помимо append() класс StringBuilder предоставляет и ряд других методов. 
Мы разберём здесь только наиболее используемые. Как и в случае с другими классами 
стандартной библиотеки, полный список можно посмотреть в [документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringBuilder.html).

Часть методов `StringBuilder` идентична по функциональности и названию методам `String`.
Это методы `indexOf(String str)` и `lastIndexOf(String str)`, 
которые возвращают индекс элемента, методы `substring(int beginIndex)` и 
`substring(int beginIndex, int endIndex)`,
которые нужны для получения подстроки или символа (оба метода возвращают объект класса `String`).

### Вставка в середину строки.
Метод `insert(int index, String str)` позволяет добавить подстроку или символ в середину `StringBuilder`. 

Для этого нужно передать в метод индекс символа, с которого должна быть вставка:

```java
public class Practicum {
    public static void main(String[] args) {
        StringBuilder example = new StringBuilder("Helo!");
        example.insert(4, "l"); // добавили "l" на 3-ю позицию перед "o"
        System.out.println(example.toString()); // выведет строку "Hello!"
    }
}
```
```
Результат

Helol!
```
Вставка всегда сдвигает символы вправо.

### Замена подстроки или элемента.

Замена внутри строк `StringBuilder` происходит при помощи метода
`replace(int indexFromInclusive, int indexToExclusive, String replacement)`. 
Важно запомнить, что первый индекс при замене берётся включительно, а второй — нет.

```java
public class Practicum {
   public static void main(String[] args) {
      StringBuilder builder = new StringBuilder("Hillo, world!");
      builder.replace(1,2, "e");
      builder.replace(7,13, "java!");

      System.out.println(builder.toString());// выведет строку "Hello, java!"
   }
}
```
```
Результат

Hello, java!
```

### Удаление по индексу.

Для удаления одного или нескольких элементов понадобятся методы `deleteCharAt(int index)` 
и `delete(int startIndexInclusive, int endIndexExclusive)`. 
При удалении по двум индексам первый индекс берётся включительно,
а второй нет (аналогично методу замены `replace(int, int, String)`).

```java
public class Practicum {
   public static void main(String[] args) {
      StringBuilder builder = new StringBuilder("Hhellllllo!");
      builder.deleteCharAt(1); // удалит элемент 'h'
      builder.delete(2, 6);    // удалит все лишние символы 'l'
      System.out.println(builder.toString()); // выведет строку "Hello!"
   }
}
```
```
Результат

Hello!
```

### Отзеркаливание текста.

Перевернуть строку позволяет метод `reverse()`.

```java
public class Practicum {
   public static void main(String[] args) {
      StringBuilder builder = new StringBuilder("!dlrow ,olleH");
      builder.reverse();
      System.out.println(builder.toString()); // выведет "Hello, world!"
   }
}
```
```
Результат

Hello, world!
```


### Обрезка строки.

Метод `setLength(int newLength)` позволяет оставить только заданное количество символов.
Для этого нужно передать в него нужную длину строки.

```java
public class Practicum {
   public static void main(String[] args) {
      StringBuilder builder = new StringBuilder("hellodghkwennalmc/ skm");
      builder.setLength(5); // останется только пять символов
      System.out.println(builder.toString()); // выведет строку "hello"
   }
}
```
```
Результат

hello
```

> Теперь вы знаете, что строки создаются не только через `String`, 
> но и через `StringBuilder`. Основная особенность этого класса — изменяемость. 
> Вы можете эффективно добавлять и удалять элементы в `StringBuilder` по мере необходимости,
> и только в конце превратить его в неизменяемый объект типа `String`.
> Это позволяет уменьшить количество промежуточных объектов-строк, что особенно полезно,
> когда вы не можете узнать заранее, как должна выглядеть финальная строка.

</details>

<details>

<summary>Сборка-разборка строк</summary>

# Сборка-разборка строк

Строки — это не всегда связный текст. 
Они могут представлять собой какой-то набор данных. 
Например, строка `"красный, жёлтый, зелёный"` обозначает цвета,
из которых состоит светофор.
В ходе работы над кодом может понадобиться преобразовать такую составную строку 
в массив элементов или, наоборот, создать на основе массива типа `String` единую строку. 
О том, как «разбирать» и «собирать» строки, и пойдёт речь в этом уроке.

## Разделение строки

Изучите код ниже. Программа принимает строку `excellent` из имён и фамилий студентов,
которые справились с экзаменом на «отлично», и с помощью цикла и методов String печатает их список.

```java
public class Practicum {
    public static void main(String[] args) {
        String excellent = "Марина Голубева,Анна Иванова,Василий Рябов,Екатерина Белых,Иван Засонин,";

        int lastNameStart = 0;
        for (int i = 0; i < excellent.length(); i++) {
            if (excellent.charAt(i) == ',') {
                System.out.println(excellent.substring(lastNameStart, i) + " — отлично");
                lastNameStart = i + 1;
            }
        }
    }
}
```

```
Результат

Марина Голубева — отлично

Анна Иванова — отлично

Василий Рябов — отлично

Екатерина Белых — отлично

Иван Засонин — отлично
```

Имена и фамилии перечислены через запятую `','` — разделитель.
По сути, программа работает со строкой, в которой скомпонованы несколько элементов 
— отдельных студентов. Обходить их было бы гораздо удобнее не в поиске разделителя-запятой,
как сейчас, а если бы все они были заранее отделены друг от друга.
В этом может помочь метод `split(String regex)` (от англ. _split_ — «расщеплять, раскалывать»).

Метод `split(String regex)` превращает строку в массив строк `String[]`. 
Элементы в строке разделяются по разделителю `regex`, который передаётся в метод.

```java
public class Practicum {
    public static void main(String[] args) {
        String excellent = "Марина Голубева,Анна Иванова,Василий Рябов,Екатерина Белых,Иван Засонин";

        String[] split = excellent.split(",");

        for (String student: split) {
            System.out.println(student + " — отлично");
        }
    }
}
```
```
Результат

Марина Голубева — отлично

Анна Иванова — отлично

Василий Рябов — отлично

Екатерина Белых — отлично

Иван Засонин — отлично
```

Результат такого кода полностью совпадает с предыдущим, но программа стала проще и понятнее.

Всё, что находится до первой запятой, получило индекс `[0]`, всё, что между первой 
и второй запятыми, — индекс `[1]` и так далее. Символы после последней запятой 
стали последним элементом массива.

![img_8.png](../L16/img_8.png)

## regex

Метод `split(String regex)` принимает в качестве аргумента не просто символ,
а **регулярное выражение** (`regex` — сокращение от англ. **regular expression**).
Регулярные выражения — это особые строки из обычных и специальных символов,
которые используются для поиска.

Ряд символов нельзя использовать напрямую как разделители.
Это символы точки `<.>`, знака вопроса `<?>`, скобок `<(>`,  `<)>`, `<[>`, `<{>`, 
доллара `<$>`, звёздочки `<*>`, плюса `<+>` и некоторые другие: `<|>`, `<^>`, `<\>`. 
Если элементы в строке разделены одним из таких символов, то при передаче в метод
необходимо добавить два обратных слеша `<\\>`.


```java
public class Practicum {
    public static void main(String[] args) {
        String students = "Примечание 1.1*Примечание 1.2*Примечание 1.3";

        String[] split = students.split("\\*");

        System.out.println(split[0].equals("Примечание 1.1"));
        System.out.println(split[1].equals("Примечание 1.2"));
        System.out.println(split[2].equals("Примечание 1.3"));
    }
}

```

Если убрать слеши — программа выдаст ошибку-исключение.

## Из массива в строку

Также может возникнуть необходимость провести операцию, 
обратную `split(String regex)` — «сборку» строки. 
Это бывает полезным, если требуется упаковать в строку массив.
Для этого в классе `String` есть статический метод `join(String delimeter, String... strs)`
(от англ. **join** — «соединять, объединять»).

Например, соберём в строку массив домашних питомцев `arrayOfPets`.
Для этого просто передадим разделитель-запятую и массив в метод в качестве аргументов.

```java
public class Practicum {
    public static void main(String[] args) {
        String[] arrayOfPets = new String[]{
                "Кот Батончик",
                "Хомяк Рафаэлка",
                "Попугай Картошка"
        };

        String pets = String.join(", ", arrayOfPets);

        System.out.println("Мои питомцы: " + pets);
    }
}
```
```
Результат

Мои питомцы: Кот Батончик, Хомяк Рафаэлка, Попугай Картошка
```

## Аргумент произвольной длины varargs


Обратите внимание на запись второго аргумента в методе `join()` — `String... strs`. 
Такая запись, тип данных плюс многоточие, называется **variable arguments**
(англ. «_произвольное/вариативное количество аргументов_»), или **varargs**. 
Аргумент типа **varargs** часто встречается в методах стандартной библиотеки и означает,
что метод может принять любое количество аргументов или массив, как в примере выше.
**varargs** в методе может быть только один и всегда будет на последнем месте после всех остальных аргументов.  

Поэтому специально создавать массив для метода `join()` необязательно, 
можно просто передать нужное количество аргументов.

```java

public class Practicum {
    public static void main(String[] args) {
        String pet1 = "Кот Батончик";
        String pet2 = "Хомяк Рафаэлка";
        String pet3 = "Попугай Картошка";

        String allPets = String.join(", ", pet1, pet2, pet3);

        System.out.println("Мои питомцы: " + allPets);
    }
}
```

```

Результат

Мои питомцы: Кот Батончик, Хомяк Рафаэлка, Попугай Картошка
```
</details>


<details>

<summary>Форматирование строк</summary>

# Форматирование строк

**Форматирование строк** — это операция, в результате которой строки можно привести к определённому виду.
В стандартной библиотеке предусмотрен достаточно обширный набор инструментов для этого.

## Как происходит форматирование

Для форматирования строк используется статический метод `String.format(String format, Object... args)`. 
В него передаётся два аргумента. Первый — образец для форматирования `String format,` это строка, 
в которой, как правило, используются **символы преобразования** (англ. _conversion character_),
хотя их может и не быть. Далее идёт **varargs** `Object... args` — подразумевается,
что он должен содержать столько аргументов, сколько в `String format` символов преобразования.

Одна из основных причин, почему удобнее пользоваться форматированием, — это более понятная запись.
Допустим, есть строка `trafficLight`.

```java
String[] colors = new String[]{"красный", "жёлтый", "зелёный"};
String trafficLight = "Цвета светофора: " + colors[0] + ", " + colors[1] + " и " + colors[2] + ".";

```

Теперь запишем эту строку через форматирование. В качестве символа преобразования используем %s.

```java
String[] colors = new String[]{"красный", "жёлтый", "зелёный"};
String trafficLight = String.format("Цвета светофора: %s, %s и %s.", colors[0], colors[1], colors[2]);
```

Результат в обоих случаях будет одинаковым. Однако при использовании форматирования сразу видно, 
как будут располагаться аргументы и какие между ними символы. 
В первом случае нужно ещё не забыть правильно расставить пробелы с запятыми.

Когда нужно одновременно отформатировать строку и сразу вывести результат,
удобнее воспользоваться методом `System.out.printf(String format, Object... args)`.

```java

public class Practicum {
    public static void main(String[] args) {
        String[] colors = new String[]{"красный", "жёлтый", "зелёный"};
        System.out.printf("Цвета светофора: %s, %s и %s.", colors[0], colors[1], colors[2]);
    }
}
```
```
Результат

Цвета светофора: красный, жёлтый и зелёный.
```

## Символы преобразования

Для разных типов данных нужны разные символы преобразования. 
Они состоят из знака процентов `%` и обязательного указания типа данных.
`%s` — для строк (_s_ — сокращение от **string**);
`%d` — для целых чисел (_d_ от **decimal**);
`%f` — для чисел с плавающей точкой (_f_ от **float**);
`%b` — для булевых значений (_b_ от **boolean**);
`%c` — для символов (_c_ от char и **c*haracter***).

Если понадобятся другие, менее распространённые, их можно найти в [документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Formatter.html#syntax).

Помимо подстановки значений с помощью форматирования,
можно проводить и другие манипуляции. Например, автоматически повышать регистр.
Чтобы вывести строку в верхнем регистре, вместо символа `%s` понадобится `%S`.

```java
public class Practicum {
    public static void main(String[] args) {
        String pizza = "Пицца, 1 шт., 310.50";
        System.out.printf("%S", pizza);
    }
}
```

```
Результат

ПИЦЦА, 1 ШТ., 310.50
```

Аналогичным образом можно выводить булевы значения прописными или строчными буквами.

```java
public class Practicum {
   public static void main(String[] args) {
      boolean theTruth = true;
      System.out.printf("%b", theTruth);
      System.out.println();
      System.out.printf("%B", theTruth);
   }
}
```

```
Результат

true

TRUE
```

Кроме того, с помощью форматирования можно приводить типы. 
Например, непустую строку можно привести к булеву типу.

```java
public class Practicum {
   public static void main(String[] args) {
      String str = "Hello, Java!";
      System.out.printf("%b", str); // получим true
   }
}
```

```
Результат

true
```
Автоприведение типов срабатывает не всегда. Например, не получится привести строку к целому числу.

## Дополнительные параметры символов преобразования

К символам преобразования можно добавить параметры. С их помощью можно регулировать:
* расположение строки по левому или правому краю;
* максимальное и минимальное количество символов для выводимой строки;
* количество символов после плавающей точки в дробных числах.

Разберём всё по порядку.

Задать нужное расположение можно с помощью унификации длины строки.
Для этого нужно добавить положительное число между знаком `%` и обозначением `s`. 
Это число обозначает минимальное число символов. В результате строка станет нужной длины —
недостающие символы заполнятся пробелами.

```java
public class Practicum {
    public static void main(String[] args) {
        String pizza = "Пицца, 1 шт., 310.50";
        String tea = "Чай, 1 шт., 113.30";
        int[] numbers = {1,2,3,4,5,6,7,8,9,10};
        System.out.print(numbers[0]);
        System.out.printf("%25s", pizza);
        System.out.println();
        System.out.print(numbers[1]);
        System.out.printf("%25s", tea);
    }
}
```

```
Результат

1     Пицца, 1 шт., 310.50

2       Чай, 1 шт., 113.30
```

Результат будет очень похож на выравнивание по правому краю в текстовых редакторах.
Важно, чтобы число-параметр было достаточно большим, — тогда форматирование будет заметно.
Попробуйте заменить 25 на маленькое число — например, на 5 — и посмотрите, что получится.

Чтобы выровнять текст по левой стороне, целое число после `%` нужно сделать **отрицательным**.

```java
public class Practicum {
    public static void main(String[] args) {
        String pizza = "Пицца, 1 шт., 310.50";
        String discount = "-10%";
        System.out.printf("%-35s", pizza);
        System.out.println(discount);
    }
}
```

```
Результат

Пицца, 1 шт., 310.50               -10%
```

Чтобы ограничить количество символов в строке, нужно задать её диапазон. 
Это происходит с помощью **параметра точности**. Точность задаётся между `%` и `s` 
в виде числа с плавающей точкой. Целая часть — минимальное количество символов, дробная — максимальное.

```java
public class Practicum {
    public static void main(String[] args) {
        String pizza = "Пицца, 1 шт., 310.50";
        System.out.printf("%1.12s", pizza); // Выведет не менее одного символа и не более 12
    }
}
```

```
Результат

Пицца, 1 шт.
```

Строка pizza оказалась обрезана, так как её часть не попадает в заданный диапазон.
Замените значение переменной pizza на "" и перезапустите код. 
Кажется, что ничего не выведено, но на самом деле получился один пробел, 
так как минимальная длина вывода в этом примере — один символ.

Аналогичным образом можно задать количество символов после точки в дробях. 
Первое число в записи преобразования всё так же будет обозначать минимальное 
количество выводимых символов, а вот второе уже количество символов после запятой. 
Округление при этом произойдёт по правилам математики.

```java
public class Practicum {
   public static void main(String[] args) {
      double price = 12345.6789;
      System.out.printf("%2.2f", price); // Выведет 12345.68
   }
}
```

```
Результат

12345.68
```

## Переносы и пустоты
Осталось только научиться добавлять переносы в форматируемую строку.
Для этого существует два способа. Или добавить форматный символ `%n`, 
или специальный символ `\n`. 
В обоих случаях будет выполнен перенос строки.
Отличие в том, что `%n` используется только в форматируемых строках,
в то время как `\n` работает и в обычных строках. По этой причине чаще используется именно `\n`.

```java

public class Practicum {
    public static void main(String[] args) {
        String pizza = "Пицца, 1 шт., 310.50";
        String tea = "Чай, 1 шт., 113.30";
        String cookies = "Печенье, 1 уп., 75.75";

        System.out.println(pizza + "\n" + tea + "\n" + cookies);
    }
}
```
```
Результат

Пицца, 1 шт., 310.50

Чай, 1 шт., 113.30

Печенье, 1 уп., 75.75
```

</details>


<details>

<summary>Задание 1</summary>

# Задание 1

Напишите конструктор приветствия с помощью `StringBuilder`. 
Сначала создайте экземпляр `StringBuilder`, а затем добавьте в него три подстроки.

```java
public class Practicum {
   public static void main(String[] args) {

      String start = "Привет! Меня зовут ";

      StringBuilder hello = new StringBuilder(); // создайте StringBuilder с началом start
        ... // добавьте подстроку "<ваше имя>"
        ... // добавьте подстроку ". Я из города "
        ... // добавьте подстроку "<ваш город>."

      

      String asString = start + hello.toString();
      System.out.println(asString);
   }
}
```

## Подсказка

Метод `.append("нужная подстрока")` добавляет всё, что в круглых скобках,
в конец строки-объекта `StringBuilder`.

## Ожидаемый результат

```
Результат

Привет! Меня зовут <ваше имя>. Я из города <ваш город>.
```


</details>

<details>

<summary>Задание 2</summary>

# Задание 2

Часто при реализации больших программ часть данных в них попадает в неподходящем, «сыром» виде. 
Такие данные нужно преобразовать, чтобы избежать ошибок в их дальнейшей обработке.
Напишите метод `String fixPoem(String[] poem)` для работы со стихотворениями.
Метод должен удалять пустые строки (или строки из пробельных символов)
и лишние пробелы с начала и конца. 
Стихотворение доступно по вызову метода `readPoem()` в виде списка строк.

К примеру, если на входе у нас такой набор строк:
```
" Я помню чудное мгновенье:",
"   Передо мной явилась ты,   ",
"",
"   ",
" Как мимолётное виденье,",
" ",
"Как гений чистой красоты.",
""
```

То после обработки он должен выглядеть так:

```
"Я помню чудное мгновенье:",
"Передо мной явилась ты,",
"Как мимолётное виденье,",
"Как гений чистой красоты." 

```

`PoemFixer.java`

```java
public class PoemFixer {

   public String[] readPoem() {
      return new String[]{
              "   Это кто там ложку «ложит»?",
              "",
              "   ",
              "Знай, такого быть не может!",
              "  Ложку мы на стол кладём,  ",
              "",
              "А тебя – к обеду ждём."
      };
   }

   public String fixPoem(String[] poem) {
      // код метода 
   }

   public static void main(String[] args) {
      PoemFixer poemFixer = new PoemFixer();
      String[] poem = poemFixer.readPoem();
      String poemAsString = poemFixer.fixPoem(poem);
      System.out.println(poemAsString);
   }
}
```

## Подсказка

* Сначала нужно создать пустой объект `new StringBuilder()`. 
В него будем записывать «очищенный» текст стихотворения.

* Второй шаг — построить цикл по всем строкам аргумента, переданного в метод `fixPoem()`.
Сделать это можно, например, циклом `forEach: for (String line: poem) {}`.

* На каждом шаге цикла нужно добавлять строку в объект `StringBuilder`, но только если она 
не пустая и не состоит только из пробелов — методы `isEmpty()` и `isBlank()` помогут это проверить.

* При добавлении требуется также удалить лишние пробельные символы — здесь поможет `append()` и `trim()`.
Их можно объединить `sb.append(line.trim())`.


</details>


<details>

<summary>Задание 3</summary>

# Задание 3

В уроке мы не раз сделали акцент на том, что `StringBuilder` позволяет не создавать лишние строки.
Проверьте это! Оптимизируйте программу по подсчету количества вхождений строки в текст из 
предыдущего урока, чтобы она не создавала лишний «мусор». 
Подсказка: вместо `contains()` в `StringBuilder` необходимо пользоваться методом `indexOf`, 
а вместо получения подстроки можно просто удалять лишние элементы.

`FindRepeats.java`

```java
public class FindRepeats {
   int numberOfRepeats(String text, String substring) {
      int count = 0;
      // код метода
      return count;
   }
}
```

## Подсказка

* Создайте объект `StringBuilder` через конструктор, принимающий аргумент `text`.
* После этого замените методы по обработке строки. 
Вместо `text.contains(substring)` нужно искать индекс `substring` в `StringBuilder`. 
Если он не `-1`, значит, мы нашли совпадение.
* Если совпадение найдено, нужно отрезать все символы от начала
`StringBuilder` до конца найденной строки. 
Для этого используйте функцию `sb.delete(0, ..,)`. 
Второй аргумент должен быть индексом следующего за повторением элемента.

</details>


<details>

<summary>Задание 4</summary>

# Задание 4


Палиндром — это число, сочетание букв или текст, которые читаются одинаково как слева направо, 
так и справа налево. Например, слово «комок» или фраза «А роза упала на лапу Азора».
Хотите узнать, зачем вам это знать? Вопрос про палиндром — один из самых частых на собеседованиях. 
А ещё на палиндром любят давать задачки. Мы тоже подготовили сразу две. Вот первая.

Напишите метод `boolean isPalindromeWord(String str)`. Он должен возвращать
true, если аргумент — палиндром, иначе false. Исходите из того, что 
строка-аргумент это одно слово, которое не содержит пробелов. К примеру, «казак».

`Palindrome.java`

```java
public class Palindrome {

   public boolean isPalindromeWord(String str) {
      // ваш код
   }
}
```

## Подсказка

* Создайте `StringBuilder` с исходной строкой, переверните его через `reverse()`, 
а затем сравните полученный результат с помощью `equals()` с изначальной строкой.

</details>


<details>

<summary>Задание 5</summary>

# Задание 5


Настройте программу по учёту школьных оценок.
На вход подаётся строка, один элемент которой имеет вид <имя, фамилия, предмет, оценка>. 
Между собой элементы разделяются с помощью символа `";"`.

К примеру:
`"вероника,чехова,ФИЗИКА,5;анна,строкова,МАТЕМАТИКА,4;иван,петров,ГЕОМЕТРИЯ,5"`

Нужно вывести на экран отдельные строки вида `"Имя Фамилия предмет — Оценка"`. 
При этом нужно учесть, что

* Имя и фамилия должны начинаться с большой буквы — здесь вам поможет метод `String capitalize(String str)`, 
который вы написали ранее.

* Название предмета должно состоять из строчных букв.
* Оценка должна быть преобразована в текст. 
Соответствующий метод `String gradeToString(String grade)` уже реализован в прекоде.
* Оценка должна быть отделена от предмета длинным тире `'—'`. 
Скопируйте символ в код и не забудьте добавить по пробелу с каждой стороны.


Выходные данные должны получиться такими:
`Вероника Чехова физика — Безупречно`
`Анна Строкова математика — Потрясающе`
`Иван Петров геометрия — Безупречно`

`Grades.java`

```java
public class Grades {

   private String capitalize(String str) {
      return str.substring(0,1).toUpperCase() + str.substring(1);
   }

   private String gradeToString(String grade) {
      switch (grade) {
         case "5": {
            return "Безупречно";
         }
         case "4": {
            return "Потрясающе";
         }
         case "3": {
            return "Восхитительно";
         }
         case "2": {
            return "Прекрасно";
         }
         default:
            return "Очаровательно";
      }
   }

   // grades - строка вида "имя,фамилия,предмет,оценка;имя,фамилия,предмет,оценка;"
   public void gradeBeautifier(String grades) {
       ... // реализуйте метод здесь
      String[] data = grades.split(";");

      for (String item : data) {
         String[] info = item.split(",");
         String name = capitalize(info[0]);
         String surname = capitalize(info[1]);
         String subject = info[2].toLowerCase();
         String grade = gradeToString(info[3]);
         System.out.println(String.join(" ", name, surname, subject, "-", grade));

      }
   }


}
```

## Подсказка

* Сначала разделите всю строку по первому разделителю `';'`. 
Затем пройдитесь циклом по всем найденным значениям и
каждую запись разделите ещё раз уже по символу `','`. 
* Запись об одном школьнике содержит данные по известным индексам. 
К примеру, по нулевому индексу идёт имя, а по третьему оценка. Соберите все части в строку,
применяя к ним `capitalize()`, `toLowerCase()` и `gradeToString()`.
* Собирать вместе строку можно либо через конкатенацию, либо через `StringBuilder`.
Не забудьте добавить пробелы между частями вывода, а также до и после длинного тире `—`.

</details>

<details>

<summary>Задание 6</summary>

# Задание 6


Программа по учёту оценок сломалась, но в нашей части системы сохранились 
бэкапы! Проведите преобразование, обратное тому,
которое было в предыдущем задании. На вход теперь подаётся массив строк:

`Вероника Чехова физика — Безупречно`
`Анна Строкова математика — Потрясающе`
`Иван Петров геометрия — Безупречно`

Требуется превратить их в одну запись вида
`"имя,фамилия,предмет,оценка;имя,фамилия,предмет,оценка"`. 
Метод для перевода оценки в строку-число уже реализован.

Выходные данные должны получиться такими:


`GradesReversed.java`

```java
import java.util.ArrayList;
import java.util.List;
public class GradesReversed {

   private String gradeStringToInt(String grade) {
      switch (grade) {
         case "Безупречно": {
            return "5";
         }
         case "Потрясающе": {
            return "4";
         }
         case "Восхитительно": {
            return "3";
         }
         case "Прекрасно": {
            return "2";
         }
         default:
            return "1";
      }
   }

   public String serializeGrades(String[] grades) {
       ... // реализуйте метод здесь
     
   }

}
```

## Подсказка

* Чтобы перебрать исходный массив, его сначала придётся разбить 
на отдельные элементы по пробельному символу `split(" ")`. 
Затем их нужно объединить в строки, все элементы которых должны быть
через запятую — `join(",", ..., ..., ..., ...)`. 
* При разбитии массива по пробелу следует учитывать, что перед записью оценки
идут пробел, тире, пробел `' — '`. То есть важные для вас элементы находятся 
в позициях 0, 1, 2 и 4. Элемент 3 вам не нужен. 
* Полученные строки нужно объединить между собой, использую точку с запятой — `join(";", list)`. 
* Для преобразования элементов массива используйте метод `toLowerCase()` и `gradeStringToInt()`.

</details>

<details>

<summary>Задание 7</summary>

# Задание 7

Допишите программу для вывода на экран информации из чека.

На вход подаётся массив строк вида `{"Пицца, 1 шт., 310.50", "Чай, 2 шт., 113.30", "Печенье, 1 уп., 75.75"}`.
Наименование товара состоит не более чем из восьми символов, 
количество не более чем из пяти, а цена не более чем из шести символов.

В результате исполнения метода на экран должен напечататься чек. 
Все его элементы должны быть выровнены по левому краю. Между ними должно 
быть минимум два пробела. Ограничений на максимальный вывод нет, 
равно как и ограничений на количество пробелов между наименованием / количеством / ценой.

Пример обработанных данных (оба варианты корректны):
```
Пицца    1 шт.  310.50
Чай      2 шт.  113.30
Печенье  1 уп.  75.75 
```

```
Пицца       1 шт.     310.50
Чай         2 шт.     113.30
Печенье     1 уп.     75.75 
```


`CheckPrinter.java`

```java
public class CheckPrinter {
   public static void printCheck(String[] items) {
      ...// ваш код
   }

   public static void main(String[] args) {
      Scanner scanner = new Scanner(System.in);
      System.out.println("Введите количество записей:");
      int n = Integer.parseInt(scanner.nextLine());
      String[] values = new String[n];
      for (int i=0; i<n; ++i)
         values[i] = scanner.nextLine();
      printCheck(values);
   }
}
```

## Подсказка

* Исходную строку для начала нужно разбить на элементы при помощи `.split(", ")`. 
* Ограничения на количество символов в наименовании товара, количестве и цене даны не просто так — 
их можно использовать для выравнивания строки через форматирование.
Например, для ограничения в восемь символов можно использовать формат `%-10s`. 
Это включит и строку наименования товара, и пару пробелов для красивого вывода.

</details>



Предыдущее занятие |         &nbsp;          | Следующее занятие
:----------------:|:-----------------------:|:----------------:
[Урок 16](LESSON16.MD) | [Содержание](README.MD) | [Урок 18](LESSON18.MD)