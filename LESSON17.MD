Предыдущее занятие |         &nbsp;          | Следующее занятие
:----------------:|:-----------------------:|:----------------:
[Урок 16](LESSON16.MD) | [Содержание](README.MD) | [Урок 18](LESSON18.MD)

# Урок 17. StringBuilder

# Требования к сдаче работы

Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.

***Критерии оценивания***

* Оценка 5 - надо сделать все пять заданий.
* Оценка 4 - надо сделать любые четыре задания.
* Оценка 3 - надо сделать любые три задания.

<details>
<summary>
Оглавление
</summary>

# Оглавление

1. [Класс String](#класс-string)
   * [Строковый литерал](#строковый-литерал)
   * [Пул строк и методы `Object`](#пул-строк-и-методы-object)
   * [Полезные методы `String`](#полезные-методы-string)
2. [Подстроки и внутристроковая нумерация](#подстроки-и-внутристроковая-нумерация)
   * [Нумерация символов внутри строки](#нумерация-символов-внутри-строки)
   * [Получение символа по индексу](#получение-символа-по-индексу)
   * [Составляем простой алгоритм на основе стандартных методов](#составляем-простой-алгоритм-на-основе-стандартных-методов)
3. [Методы String для поиска и получения подстрок](#методы-string-для-поиска-и-получения-подстрок)
   * [Методы для поиска подстрок](#методы-для-поиска-подстрок)
   * [Методы для получения подстрок](#методы-для-получения-подстрок)
4. [Замена строк и свойство неизменяемости](#замена-строк-и-свойство-неизменяемости)
   * [Методы замены строк](#методы-замены-строк)
   * [Свойство неизменяемости](#свойство-неизменяемости)
   * [Плюсы и минусы неизменяемости](#плюсы-и-минусы-неизменяемости)
5. [Задание 1](#задание-1)
6. [Задание 2](#задание-2)
7. [Задание 3](#задание-3)
8. [Задание 4](#задание-4)
9. [Задание 5](#задание-5)
   
</details>

Из-за неизменяемости строк цикличные операции вроде поиска подстроки и её удаления при работе с 
текстами большого размера приведут к созданию большого количества лишних объектов. 
Чтобы этого избежать, в Java существует ещё один класс для работы со строками — `StringBuilder` 
(англ. «строитель строк»).
Он позволяет менять содержание строки без создания новой.

<details>
<summary>Особенности объектов `StringBuilder`</summary>

# Особенности объектов `StringBuilder`

В отличие от `String`, класс `StringBuilder` представляет строку в виде изменяемого набора символов. 
`StringBuilder` — обычный класс, поэтому его объекты создаются через ключевое слово `new`.
Для создания объектов у `StringBuilder` есть разные конструкторы. Но в основном используются два 
из них: конструктор без аргументов или конструктор с одним аргументом-строкой.
С помощью второго можно сразу задать начальное состояние строки.

```java
public class Practicum {
    public static void main(String[] args) {
        StringBuilder example = new StringBuilder("Hello, world!");
        System.out.println(example); // создали строку с начальным значением "Hello, world!"
    }
}
```
```
Результат

Hello, world!
```

Начальное значение может быть любым — измените строку `"Hello, world!"` 
в конструкторе на какую-то другую и перезапустите код.

Если начальное значение строки не задано, то будет создан пустой объект `StringBuilder`.
Для вставки в него элементов предусмотрено множество методов, например `append(String str)`.
Он добавляет подстроку в конец.

```java
public class Practicum {
    public static void main(String[] args) {
        StringBuilder builder = new StringBuilder(); // строка без начального значения
        builder.append("Hello, "); // добавляем подстроку в конец StringBuilder
        builder.append("world!"); // и ещё одну
        System.out.println(builder);
    }
}
```

```
Результат

Hello, world!
```

Внутренняя реализация `StringBuilder` отдалённо похожа на реализацию списка `ArrayList<T>`. 
При создании экземпляра `StringBuilder` выделяется внутренний буфер определённой вместимости,
где и будут храниться элементы. Этот буфер может увеличиваться в размере по необходимости. Кроме того,
вместимость можно задать сразу при создании `StringBuilder` при помощи конструктора, принимающего `int`.

```java
// создаём объект StringBuilder с начальной вместимостью в 100 элементов
StringBuilder sb = new StringBuilder(100); 
```

Объекты `StringBuilder` редко используются как независимые сущности. 
Их основная задача — помочь в создании строки. 
После работы с ними их всегда можно привести к неизменяемой строке `String` с помощью метода `toString()`.

```java
 public class Practicum {
     public static void main(String[] args) {
         StringBuilder builder = new StringBuilder(); // создали объект - изменяемую строку
         builder.append("Hello, ");
         builder.append("world!");

         String asString = builder.toString(); // сделали изменяемую строку неизменяемой
         System.out.println(asString); // выведет "Hello, world!"
     }
}
```

```
Результат

Hello, world!
```

Метод `toString` преобразует
содержимое внутреннего буфера `StringBuilder` в строку и возвращает её в качестве результата.

## Методы StringBuilder

Помимо append() класс StringBuilder предоставляет и ряд других методов. 
Мы разберём здесь только наиболее используемые. Как и в случае с другими классами 
стандартной библиотеки, полный список можно посмотреть в [документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringBuilder.html).

Часть методов `StringBuilder` идентична по функциональности и названию методам `String`.
Это методы `indexOf(String str)` и `lastIndexOf(String str)`, 
которые возвращают индекс элемента, методы `substring(int beginIndex)` и 
`substring(int beginIndex, int endIndex)`,
которые нужны для получения подстроки или символа (оба метода возвращают объект класса `String`).

### Вставка в середину строки.
Метод `insert(int index, String str)` позволяет добавить подстроку или символ в середину `StringBuilder`. 

Для этого нужно передать в метод индекс символа, с которого должна быть вставка:

```java
public class Practicum {
    public static void main(String[] args) {
        StringBuilder example = new StringBuilder("Helo!");
        example.insert(4, "l"); // добавили "l" на 3-ю позицию перед "o"
        System.out.println(example.toString()); // выведет строку "Hello!"
    }
}
```
```
Результат

Helol!
```
Вставка всегда сдвигает символы вправо.

### Замена подстроки или элемента.

Замена внутри строк `StringBuilder` происходит при помощи метода
`replace(int indexFromInclusive, int indexToExclusive, String replacement)`. 
Важно запомнить, что первый индекс при замене берётся включительно, а второй — нет.

```java
public class Practicum {
   public static void main(String[] args) {
      StringBuilder builder = new StringBuilder("Hillo, world!");
      builder.replace(1,2, "e");
      builder.replace(7,13, "java!");

      System.out.println(builder.toString());// выведет строку "Hello, java!"
   }
}
```
```
Результат

Hello, java!
```

### Удаление по индексу.

Для удаления одного или нескольких элементов понадобятся методы `deleteCharAt(int index)` 
и `delete(int startIndexInclusive, int endIndexExclusive)`. 
При удалении по двум индексам первый индекс берётся включительно,
а второй нет (аналогично методу замены `replace(int, int, String)`).

```java
public class Practicum {
   public static void main(String[] args) {
      StringBuilder builder = new StringBuilder("Hhellllllo!");
      builder.deleteCharAt(1); // удалит элемент 'h'
      builder.delete(2, 6);    // удалит все лишние символы 'l'
      System.out.println(builder.toString()); // выведет строку "Hello!"
   }
}
```
```
Результат

Hello!
```

### Отзеркаливание текста.

Перевернуть строку позволяет метод `reverse()`.

```java
public class Practicum {
   public static void main(String[] args) {
      StringBuilder builder = new StringBuilder("!dlrow ,olleH");
      builder.reverse();
      System.out.println(builder.toString()); // выведет "Hello, world!"
   }
}
```
```
Результат

Hello, world!
```


### Обрезка строки.

Метод `setLength(int newLength)` позволяет оставить только заданное количество символов.
Для этого нужно передать в него нужную длину строки.

```java
public class Practicum {
   public static void main(String[] args) {
      StringBuilder builder = new StringBuilder("hellodghkwennalmc/ skm");
      builder.setLength(5); // останется только пять символов
      System.out.println(builder.toString()); // выведет строку "hello"
   }
}
```
```
Результат

hello
```

> Теперь вы знаете, что строки создаются не только через `String`, 
> но и через `StringBuilder`. Основная особенность этого класса — изменяемость. 
> Вы можете эффективно добавлять и удалять элементы в `StringBuilder` по мере необходимости,
> и только в конце превратить его в неизменяемый объект типа `String`.
> Это позволяет уменьшить количество промежуточных объектов-строк, что особенно полезно,
> когда вы не можете узнать заранее, как должна выглядеть финальная строка.

</details>



<details>

<summary>Задание 1</summary>

# Задание 1

Напишите конструктор приветствия с помощью `StringBuilder`. 
Сначала создайте экземпляр `StringBuilder`, а затем добавьте в него три подстроки.

```java
public class Practicum {
   public static void main(String[] args) {

      String start = "Привет! Меня зовут ";

      StringBuilder hello = new StringBuilder(); // создайте StringBuilder с началом start
        ... // добавьте подстроку "<ваше имя>"
        ... // добавьте подстроку ". Я из города "
        ... // добавьте подстроку "<ваш город>."

      

      String asString = start + hello.toString();
      System.out.println(asString);
   }
}
```

## Подсказка

Метод `.append("нужная подстрока")` добавляет всё, что в круглых скобках,
в конец строки-объекта `StringBuilder`.

## Ожидаемый результат

```
Результат

Привет! Меня зовут <ваше имя>. Я из города <ваш город>.
```


</details>

<details>

<summary>Задание 2</summary>

# Задание 2

Часто при реализации больших программ часть данных в них попадает в неподходящем, «сыром» виде. 
Такие данные нужно преобразовать, чтобы избежать ошибок в их дальнейшей обработке.
Напишите метод `String fixPoem(String[] poem)` для работы со стихотворениями.
Метод должен удалять пустые строки (или строки из пробельных символов)
и лишние пробелы с начала и конца. 
Стихотворение доступно по вызову метода `readPoem()` в виде списка строк.

К примеру, если на входе у нас такой набор строк:
```
" Я помню чудное мгновенье:",
"   Передо мной явилась ты,   ",
"",
"   ",
" Как мимолётное виденье,",
" ",
"Как гений чистой красоты.",
""
```

То после обработки он должен выглядеть так:

```
"Я помню чудное мгновенье:",
"Передо мной явилась ты,",
"Как мимолётное виденье,",
"Как гений чистой красоты." 

```

`PoemFixer.java`

```java
public class PoemFixer {

   public String[] readPoem() {
      return new String[]{
              "   Это кто там ложку «ложит»?",
              "",
              "   ",
              "Знай, такого быть не может!",
              "  Ложку мы на стол кладём,  ",
              "",
              "А тебя – к обеду ждём."
      };
   }

   public String fixPoem(String[] poem) {
      // код метода 
   }

   public static void main(String[] args) {
      PoemFixer poemFixer = new PoemFixer();
      String[] poem = poemFixer.readPoem();
      String poemAsString = poemFixer.fixPoem(poem);
      System.out.println(poemAsString);
   }
}
```

## Подсказка

* Сначала нужно создать пустой объект `new StringBuilder()`. 
В него будем записывать «очищенный» текст стихотворения.

* Второй шаг — построить цикл по всем строкам аргумента, переданного в метод `fixPoem()`.
Сделать это можно, например, циклом `forEach: for (String line: poem) {}`.

* На каждом шаге цикла нужно добавлять строку в объект `StringBuilder`, но только если она 
не пустая и не состоит только из пробелов — методы `isEmpty()` и `isBlank()` помогут это проверить.

* При добавлении требуется также удалить лишние пробельные символы — здесь поможет `append()` и `trim()`.
Их можно объединить `sb.append(line.trim())`.


</details>


<details>

<summary>Задание 3</summary>

# Задание 3

В уроке мы не раз сделали акцент на том, что `StringBuilder` позволяет не создавать лишние строки.
Проверьте это! Оптимизируйте программу по подсчету количества вхождений строки в текст из 
предыдущего урока, чтобы она не создавала лишний «мусор». 
Подсказка: вместо `contains()` в `StringBuilder` необходимо пользоваться методом `indexOf`, 
а вместо получения подстроки можно просто удалять лишние элементы.

`FindRepeats.java`

```java
public class FindRepeats {
   int numberOfRepeats(String text, String substring) {
      int count = 0;
      // код метода
      return count;
   }
}
```

## Подсказка

* Создайте объект `StringBuilder` через конструктор, принимающий аргумент `text`.
* После этого замените методы по обработке строки. 
Вместо `text.contains(substring)` нужно искать индекс `substring` в `StringBuilder`. 
Если он не `-1`, значит, мы нашли совпадение.
* Если совпадение найдено, нужно отрезать все символы от начала
`StringBuilder` до конца найденной строки. 
Для этого используйте функцию `sb.delete(0, ..,)`. 
Второй аргумент должен быть индексом следующего за повторением элемента.

</details>


<details>

<summary>Задание 4</summary>

# Задание 4


Палиндром — это число, сочетание букв или текст, которые читаются одинаково как слева направо, 
так и справа налево. Например, слово «комок» или фраза «А роза упала на лапу Азора».
Хотите узнать, зачем вам это знать? Вопрос про палиндром — один из самых частых на собеседованиях. 
А ещё на палиндром любят давать задачки. Мы тоже подготовили сразу две. Вот первая.

Напишите метод `boolean isPalindromeWord(String str)`. Он должен возвращать
true, если аргумент — палиндром, иначе false. Исходите из того, что 
строка-аргумент это одно слово, которое не содержит пробелов. К примеру, «казак».

`FindRepeats.java`

```java
public class Palindrome {

   public boolean isPalindromeWord(String str) {
      // ваш код
   }
}
```

## Подсказка

* Создайте `StringBuilder` с исходной строкой, переверните его через `reverse()`, 
а затем сравните полученный результат с помощью `equals()` с изначальной строкой.

</details>


<details>

Предыдущее занятие |         &nbsp;          | Следующее занятие
:----------------:|:-----------------------:|:----------------:
[Урок 16](LESSON16.MD) | [Содержание](README.MD) | [Урок 18](LESSON18.MD)