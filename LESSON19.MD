   Предыдущее занятие   |         &nbsp;          |   Следующее занятие    
:----------------------:|:-----------------------:|:----------------------:
 [Урок 18](LESSON18.MD) | [Содержание](README.MD) | [Урок 20](LESSON20.MD) 

# Урок 19. Работа с файлами

# Требования к сдаче работы

Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.

***Критерии оценивания***

* Оценка 5 - надо сделать все задания.
* Оценка 4 - надо сделать любые четыре заданий.
* Оценка 3 - надо сделать любые три задания.

## Оглавление

1. [Введение в тему](#введение-в-тему)
2. [Основы работы с файлами](#основы-работы-с-файлами)

9. [Задание 1](#задание-1)
10. [Задание 2](#задание-2)
11. [Задание 3](#задание-3)
12. [Задание 4](#задание-4)
13. [Задание 5](#задание-5)

## Введение в тему

В этой теме мы расскажем, как код на Java взаимодействует с файловой системой компьютера. 
А именно: как программа создаёт, читает и сохраняет файлы — эти операции выполняют многие реальные приложения.

Мы рассмотрим следующие моменты:

* как создавать и удалять файлы и директории;
* зачем нужны потоки ввода и вывода;
* как извлекать данные из файла и сохранять их обратно с помощью разных инструментов и методов;
* как работать с файлами безопасно и обработать возможные исключения;
* что такое кодировка и как правильно указать её тип в программе, чтобы корректно отобразить текст.

После завершения уроков вы узнаете больше о том, как Java общается с внешним миром, и сможете создавать более сложные и функциональные приложения.

<details>

<summary>Основы работы с файлами</summary>

## Основы работы с файлами

Особенности навигации и работы с файлами отличаются у разных операционных систем.
Так как Java — кроссплатформенный язык, в ней есть классы, которые координируют взаимодействие разработчика с любой файловой системой.

Для представления файлов в Java существует два класса:

* `java.io.File`, доступный с 1-й версии Java (1996);
* более новый API `java.nio.file.Path`, доступный с 7-й версии Java (2011).

Оба класса умеют выполнять все необходимые операции с файлами: чтение, запись, проверку состояния, удаление и многое другое. 
`File` появился гораздо раньше, но его всё ещё можно встретить в реальных проектах, которые были созданы до 2011 года.
В `Path` учли ошибки предыдущей реализации — что это за ошибки, расскажем подробнее далее в уроке. С момента возникновения класс `Path` стал использоваться для новых проектов.

### Путь


**Путь** (англ. path) — это набор символов, показывающий расположение файла или директории в файловой системе.
Вы уже встречались с понятием «путь», когда работали с командной строкой — команда `pwd` выводит путь к текущей директории.

```bash
$ pwd
/home/student
```

В операционных системах UNIX разделительным знаком для записи пути является `/`. В Windows — `\`. Эти знаки разделяют названия директорий, составляющих путь к файлу. Например:

```commandline
Linux, macOS: /home/username/docs/file.txt
Windows: C:\username\docs\file.txt
```

Есть два вида путей: 
* **Абсолютный (полный) путь** — указывает на одно и то же место в файловой системе вне зависимости от текущей директории. Полный путь всегда начинается с корневого каталога.
* **Относительный (сокращённый) путь** — указывает место относительно какой-либо отправной точки (другого файла, программы и так далее).

Например, абсолютный путь до файла `file.txt` всегда будет одинаковым — `C:\username\docs\file.txt`, а относительный зависит от того, в какой директории
находятся пользователь или программа, которые хотят обратиться к этому файлу. 
Допустим, пользователь находится в папке `C:\username\`, тогда относительный путь до нужного файла — `docs\file.txt`.

### Класс File

Объект класса `File` нужен для управления информацией о файлах и директориях.
Чтобы создать его, можно указать в строке **абсолютный** или **относительный** путь к файлу или каталогу, с которыми предполагается работа в коде.
Пример создания объекта `File` для директории `C:\\documents` в Windows:

```java
File dir = new File("C:\\documents");
```

Также есть следующие способы создать объект типа `File`: 
* `File(File parent, String child)` — указать путь к директории в виде объекта класса `File` и имя файла;
* `File(String parent, String child)` — указать путь к директории и имя файла.

```java
import java.io.File;

public class Practicum {

    public static void main(String[] args) {

        // создание объекта File для директории C:\\documents (для пользователей Windows)
        File dir = new File("C:\\documents");

        // создание объектов для файлов, которые находятся в директории
        File file1 = new File(dir, "lesson.txt"); // указываются путь к директории в виде объекта класса File и имя файла
        File file2 = new File("C:\\documents", "example.txt"); // указываются путь к директории и имя файла
    }
}
```

В классе `File` есть много методов и свойств для работы с файлами и директориями. 
При необходимости вы можете обратиться к [официальной документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/File.html) и найти интересующее описание.
Мы приведём только самые популярные методы:

* `String getName()` — позволяет узнать краткое имя файла или директории;
* `boolean isFile()` — возвращает значение true, если по указанному пути находится файл;
* `boolean isDirectory()` — возвращает значение true, если по указанному пути находится директория;
* `String[] list()` — возвращает массив имён файлов и поддиректорий;
* `File[] listFiles()` — возвращает массив объектов файлов и поддиректорий.

Пройдёмся по содержимому директории с помощью перечисленных методов.

```java
import java.io.File;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) {

        // создаём объект директории
        File dir = new File(HOME);

        // проверяем, является ли объект директорией
        if (dir.isDirectory()) {

            // получаем все вложенные объекты в директории
            for (File item : dir.listFiles()) {
                if (item.isDirectory()) {
                    System.out.println("Каталог: " + item.getName());
                } else {
                    System.out.println("Файл: " + item.getName());
                }
            }
        }
    }
}
```

Ещё несколько наиболее распространённых методов:
* `boolean mkdir()` — создаёт новую директорию. При успешном создании возвращает значение `true`.
* `boolean renameTo(File dest)` — переименовывает файл или директорию. В параметре указывается новое имя файла. Если переименовать не удалось, метод возвращает `false`.
* `boolean delete()` — удаляет или файл, или пустую директорию по пути, который передан в конструктор. При успешном удалении возвращает `true`.

Также в классе `File` существует константа `separator`. С помощью неё вводятся разделительные знаки `/` или `\`.

Пример кода, в котором есть описанные выше методы и константа:

```java
import java.io.File;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) {

        // определение объекта для директории
        File dir = new File(HOME + File.separator + "NewDir");
        
        boolean created = dir.mkdir();
        if (created) {
            System.out.println("Директория создана.");
        }

        // присвоение нового имени директории
        File newDir = new File(HOME + File.separator + "NewDirRenamed");
        dir.renameTo(newDir);

        // удаление директории
        boolean deleted = newDir.delete();
        if (deleted) {
            System.out.println("Директория удалена.");
        }
    }
}

```

### Работа с файлами в 7-й версии Java и выше

У класса `File` имеется ряд недостатков. Например, в нём отсутствует метод, который позволяет скопировать файл
и переместить его в другое место. Кроме того, в этом классе много методов, возвращающих булево значение `false` в случае ошибки. С исключениями править код гораздо проще.

В 7-й версии Java создатели языка решили изменить работу с файлами и директориями. Вместо единого класса `java.io.File` появились три структуры:
* `Paths` — служебный класс, который предоставляет два метода для получения объекта типа `Path`.
* `Path` — доработанная версия `File`. Это интерфейс, у которого есть множество реализаций для конкретных файловых систем. Он делает всё, что может его предшественник, но эффективнее.
* `Files` — класс, состоящий из множества статических методов для работы с файлами.

### Класс Paths

`Paths` — небольшой класс с двумя статическими методами get, которые различаются только входными параметрами. Вот форматы этих методов:
* `Path get(String first, String... more)` — преобразует строку пути (параметр first) или последовательность строк (параметр more), образующих при соединении строку пути, в Path.
* `Path get(URI uri)` — преобразует заданный объект типа URI. Это символьная строка, позволяющая идентифицировать какой-либо ресурс:
документ, изображение, файл и так далее. 
Например, строка `file:\\\C:\books\dune.epub` идентифицирует файл электронной книги, расположенной по пути `C:\\books`, как объект `Path`.

Класс `Paths` создали для того, чтобы получить из переданной строки или `URI` объект типа `Path`. 
Другой функциональности у него нет. Пример работы этого класса:

```java
import java.nio.file.Path;
import java.nio.file.Paths;

public class Practicum {

    public static void main(String[] args) {

        // использован интерфейс Path, который позволяет описать путь к файлам и каталогам
        Path myFavouriteFilePath =
            Paths.get("C:\\users\\username\\desktop\\favouriteFile.txt");
    }
}
```


### Интерфейс Path

Объект типа `Path` содержит имена директорий и файлов, которые составляют полный путь к файлу или каталогу.
Он также содержит методы для добавления элементов пути, их извлечения и манипуляций с ними. 
Остальные методы для разных действий вынесены в статические методы класса `Files`.

Некоторые из методов `Path`:
* `Path getFileName()` — возвращает имя файла из пути;
* `Path getParent()` — возвращает «родительскую» директорию по отношению к текущему пути (ту, которая находится выше по дереву директорий);
* `Path getRoot()` — возвращает «корневую» директорию (ту, которая находится на вершине дерева директорий);
* `java.io.File toFile() `— метод для перехода между старым и новым средством работы с файлами;
* `Path resolve(String other)` — возвращает путь к вложенному элементу с именем `other` в папке (при этом исходный путь должен быть папкой — файлы не могут содержать вложенных элементов).
* 
С остальными методами интерфейса Path вы можете ознакомиться в [официальной документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/file/Path.html).

С помощью описанных выше методов можно получить минимальную информацию о расположении объекта типа Path. Например:
```java
import java.nio.file.Path;
import java.nio.file.Paths;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) {

        // создаём объект Path с помощью статического метода get() класса Paths
        Path testFilePath = Paths.get(HOME, "test", "file.txt");

        // выводим информацию о файле
        System.out.println("Информация о файле: ");
        System.out.println(" - имя: " + testFilePath.getFileName());
        System.out.println(" - корневая директория: " + testFilePath.getRoot());
        System.out.println(" - родительская директория: " + testFilePath.getParent());

        // выводим элементы пути
        System.out.println("Элементы пути: ");
        for (Path element : testFilePath) {
            System.out.println(" - элемент пути: " + element);
        }
    }
}
```

### Класс Files

`Files` — это `final`-класс с `private`-конструктором. Он содержит только 
статические методы для выполнения различных действий. Его основные методы:
* `Path createFile(Path path, FileAttribute<?>... attrs)` — создаёт новый пустой файл. Выбрасывает исключение, если файл уже существует. Параметры метода: `path` — путь к файлу, который нужно создать, `attrs` — необязательный список атрибутов файла (в нём можно указать правила доступа к файлу, добавить информацию о создателе и так далее).
* `Path createDirectory(Path dir, FileAttribute<?>... attrs)` — создаёт новую директорию. Параметры метода: `dir` — директория, которую нужно создать, `attrs` — необязательный список атрибутов директории.
* `Path move(Path source, Path target, CopyOption. . . options)` — перемещает файл. Параметры метода: `source` — путь к файлу, который нужно переместить, `target` — путь к файлу назначения, `options` — необязательные параметры, определяющие, как нужно делать перемещение.
* `void delete(Path path)` — удаляет файл или директорию. Если удаляется директория, необходимо убедиться, что она пуста, иначе будет получено исключение `DirectoryNotEmptyException`. Если удаляется файл, необходимо убедиться, что он существует, иначе будет получено исключение `NoSuchFileException`. Параметры метода: `path` — путь к файлу или директории, которые нужно удалить.
* `boolean deleteIfExists(Path path)` — удаляет файл или директорию, если они существуют. Параметры метода: `path` — путь к файлу, который нужно удалить. Возвращаемое значение: `true` — если файл был удалён этим методом, `false` — если файл не может быть удалён, потому что не существует.

Остальные методы класса `Files` вы можете найти в [официальной документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/file/Files.html).

В примере ниже показана работа обозначенных методов:

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) throws IOException {

        // создаём файл testFile
        Path testFile =
            Files.createFile(Paths.get(HOME, "testFile.txt"));

        if (Files.exists(Paths.get(HOME, "testFile.txt"))) {
            System.out.println("Файл успешно создан.");
        }

        // создаём директорию testDirectory
        Path testDirectory =
            Files.createDirectory(Paths.get(HOME, "testDirectory"));
        if (Files.exists(Paths.get(HOME, "testDirectory"))) {
            System.out.println("Директория успешно создана.");
        }

        // перемещаем файл testFile в директорию testDirectory
        testFile = Files.move(testFile,
            Paths.get(HOME, "testDirectory", "testFile.txt"),
            REPLACE_EXISTING);

        if (Files.exists(
            Paths.get(HOME, "testDirectory", "testFile.txt"))) {

            System.out.println("Файл перемещён в testDirectory.");
        }

        // удаляем файл
        Files.delete(testFile);
        if (!Files.exists(
            Paths.get(HOME, "testDirectory", "testFile.txt"))) {

            System.out.println("Тестовый файл удалён.");
        }

        // удаляем пустую директорию
        Files.delete(testDirectory);
        if (!Files.exists(Paths.get(HOME, "testDirectory"))) {
            System.out.println("Директория удалена.");
        }
    }
}
```

### Метод copy()
Теперь расскажем о методе, которого не хватало в `File`. Это метод копирования `Path copy(Path source, Path target, CopyOption... options)`.
Его параметры: `source` — путь к исходному файлу, `target` — путь к тому файлу, что будет создан в результате копирования (включая имя нового файла),
`options` — необязательные параметры копирования. Существует три таких параметра:
* `REPLACE_EXISTING` — указывает, что если в директории назначения уже есть такой файл, то нужно его заменить;
* `COPY_ATTRIBUTES` — указывает, что нужно скопировать атрибуты оригинального файла в его копию;
* `ATOMIC_MOVE` — указывает, что необходимо переместить файл атомарно. Это значит, что перемещение или выполнится целиком, или не выполнится вообще.
💡 Обратите внимание

>💡 Обратите внимание: при копировании директории содержащиеся в ней файлы и каталоги копироваться не будут.

В примере ниже сначала создаётся объект типа `Path` для исходного файла (`sourceFile`) и объект для директории назначения (`targetDir`). Далее с помощью метода resolve
(англ. «разрешить»), который умеет объединять два пути в один, создаётся объект `targetFile` для пути файла назначения. После этого выполняется метод `copy()`.

```java
import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) {

        // исходный файл
        Path sourceFile = Paths.get(HOME, "test.txt");
        // директория назначения
        Path targetDir = Paths.get(HOME, "test");

        copyFile(sourceFile, targetDir);
    }

    public static void copyFile(Path sourceFile, Path targetDir) {
        Path targetFile = targetDir.resolve(sourceFile.getFileName());

        try {
            Files.copy(sourceFile, targetFile);
        } catch (FileAlreadyExistsException e) {
            System.out.format("Файл %s уже существует.", targetFile);
        } catch (IOException e) {
            System.err.format("Произошла ошибка во время копирования файла.");
        }
    }

}
```

</details>


   Предыдущее занятие   |         &nbsp;          |   Следующее занятие    
:----------------------:|:-----------------------:|:----------------------:
 [Урок 18](LESSON18.MD) | [Содержание](README.MD) | [Урок 20](LESSON20.MD) 