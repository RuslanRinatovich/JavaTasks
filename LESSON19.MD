   Предыдущее занятие   |         &nbsp;          |   Следующее занятие    
:----------------------:|:-----------------------:|:----------------------:
 [Урок 18](LESSON18.MD) | [Содержание](README.MD) | [Урок 20](LESSON20.MD) 

# Урок 19. Работа с файлами

# Требования к сдаче работы

Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.

***Критерии оценивания***

* Оценка 5 - надо сделать все задания.
* Оценка 4 - надо сделать любые четыре заданий.
* Оценка 3 - надо сделать любые три задания.

## Оглавление

1. [Введение в тему](#введение-в-тему)
2. [Основы работы с файлами](#основы-работы-с-файлами)

9. [Задание 1](#задание-1)
10. [Задание 2](#задание-2)
11. [Задание 3](#задание-3)
12. [Задание 4](#задание-4)
13. [Задание 5](#задание-5)

## Введение в тему

В этой теме мы расскажем, как код на Java взаимодействует с файловой системой компьютера. 
А именно: как программа создаёт, читает и сохраняет файлы — эти операции выполняют многие реальные приложения.

Мы рассмотрим следующие моменты:

* как создавать и удалять файлы и директории;
* зачем нужны потоки ввода и вывода;
* как извлекать данные из файла и сохранять их обратно с помощью разных инструментов и методов;
* как работать с файлами безопасно и обработать возможные исключения;
* что такое кодировка и как правильно указать её тип в программе, чтобы корректно отобразить текст.

После завершения уроков вы узнаете больше о том, как Java общается с внешним миром, и сможете создавать более сложные и функциональные приложения.

<details>

<summary>Основы работы с файлами</summary>

## Основы работы с файлами

Особенности навигации и работы с файлами отличаются у разных операционных систем.
Так как Java — кроссплатформенный язык, в ней есть классы, которые координируют взаимодействие разработчика с любой файловой системой.

Для представления файлов в Java существует два класса:

* `java.io.File`, доступный с 1-й версии Java (1996);
* более новый API `java.nio.file.Path`, доступный с 7-й версии Java (2011).

Оба класса умеют выполнять все необходимые операции с файлами: чтение, запись, проверку состояния, удаление и многое другое. 
`File` появился гораздо раньше, но его всё ещё можно встретить в реальных проектах, которые были созданы до 2011 года.
В `Path` учли ошибки предыдущей реализации — что это за ошибки, расскажем подробнее далее в уроке. С момента возникновения класс `Path` стал использоваться для новых проектов.

### Путь


**Путь** (англ. path) — это набор символов, показывающий расположение файла или директории в файловой системе.
Вы уже встречались с понятием «путь», когда работали с командной строкой — команда `pwd` выводит путь к текущей директории.

```bash
$ pwd
/home/student
```

В операционных системах UNIX разделительным знаком для записи пути является `/`. В Windows — `\`. Эти знаки разделяют названия директорий, составляющих путь к файлу. Например:

```commandline
Linux, macOS: /home/username/docs/file.txt
Windows: C:\username\docs\file.txt
```

Есть два вида путей: 
* **Абсолютный (полный) путь** — указывает на одно и то же место в файловой системе вне зависимости от текущей директории. Полный путь всегда начинается с корневого каталога.
* **Относительный (сокращённый) путь** — указывает место относительно какой-либо отправной точки (другого файла, программы и так далее).

Например, абсолютный путь до файла `file.txt` всегда будет одинаковым — `C:\username\docs\file.txt`, а относительный зависит от того, в какой директории
находятся пользователь или программа, которые хотят обратиться к этому файлу. 
Допустим, пользователь находится в папке `C:\username\`, тогда относительный путь до нужного файла — `docs\file.txt`.

### Класс File

Объект класса `File` нужен для управления информацией о файлах и директориях.
Чтобы создать его, можно указать в строке **абсолютный** или **относительный** путь к файлу или каталогу, с которыми предполагается работа в коде.
Пример создания объекта `File` для директории `C:\\documents` в Windows:

```java
File dir = new File("C:\\documents");
```

Также есть следующие способы создать объект типа `File`: 
* `File(File parent, String child)` — указать путь к директории в виде объекта класса `File` и имя файла;
* `File(String parent, String child)` — указать путь к директории и имя файла.

```java
import java.io.File;

public class Practicum {

    public static void main(String[] args) {

        // создание объекта File для директории C:\\documents (для пользователей Windows)
        File dir = new File("C:\\documents");

        // создание объектов для файлов, которые находятся в директории
        File file1 = new File(dir, "lesson.txt"); // указываются путь к директории в виде объекта класса File и имя файла
        File file2 = new File("C:\\documents", "example.txt"); // указываются путь к директории и имя файла
    }
}
```

В классе `File` есть много методов и свойств для работы с файлами и директориями. 
При необходимости вы можете обратиться к [официальной документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/File.html) и найти интересующее описание.
Мы приведём только самые популярные методы:

* `String getName()` — позволяет узнать краткое имя файла или директории;
* `boolean isFile()` — возвращает значение true, если по указанному пути находится файл;
* `boolean isDirectory()` — возвращает значение true, если по указанному пути находится директория;
* `String[] list()` — возвращает массив имён файлов и поддиректорий;
* `File[] listFiles()` — возвращает массив объектов файлов и поддиректорий.

Пройдёмся по содержимому директории с помощью перечисленных методов.

```java
import java.io.File;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) {

        // создаём объект директории
        File dir = new File(HOME);

        // проверяем, является ли объект директорией
        if (dir.isDirectory()) {

            // получаем все вложенные объекты в директории
            for (File item : dir.listFiles()) {
                if (item.isDirectory()) {
                    System.out.println("Каталог: " + item.getName());
                } else {
                    System.out.println("Файл: " + item.getName());
                }
            }
        }
    }
}
```

Ещё несколько наиболее распространённых методов:
* `boolean mkdir()` — создаёт новую директорию. При успешном создании возвращает значение `true`.
* `boolean renameTo(File dest)` — переименовывает файл или директорию. В параметре указывается новое имя файла. Если переименовать не удалось, метод возвращает `false`.
* `boolean delete()` — удаляет или файл, или пустую директорию по пути, который передан в конструктор. При успешном удалении возвращает `true`.

Также в классе `File` существует константа `separator`. С помощью неё вводятся разделительные знаки `/` или `\`.

Пример кода, в котором есть описанные выше методы и константа:

```java
import java.io.File;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) {

        // определение объекта для директории
        File dir = new File(HOME + File.separator + "NewDir");
        
        boolean created = dir.mkdir();
        if (created) {
            System.out.println("Директория создана.");
        }

        // присвоение нового имени директории
        File newDir = new File(HOME + File.separator + "NewDirRenamed");
        dir.renameTo(newDir);

        // удаление директории
        boolean deleted = newDir.delete();
        if (deleted) {
            System.out.println("Директория удалена.");
        }
    }
}

```

### Работа с файлами в 7-й версии Java и выше

У класса `File` имеется ряд недостатков. Например, в нём отсутствует метод, который позволяет скопировать файл
и переместить его в другое место. Кроме того, в этом классе много методов, возвращающих булево значение `false` в случае ошибки. С исключениями править код гораздо проще.

В 7-й версии Java создатели языка решили изменить работу с файлами и директориями. Вместо единого класса `java.io.File` появились три структуры:
* `Paths` — служебный класс, который предоставляет два метода для получения объекта типа `Path`.
* `Path` — доработанная версия `File`. Это интерфейс, у которого есть множество реализаций для конкретных файловых систем. Он делает всё, что может его предшественник, но эффективнее.
* `Files` — класс, состоящий из множества статических методов для работы с файлами.

### Класс Paths

`Paths` — небольшой класс с двумя статическими методами get, которые различаются только входными параметрами. Вот форматы этих методов:
* `Path get(String first, String... more)` — преобразует строку пути (параметр first) или последовательность строк (параметр more), образующих при соединении строку пути, в Path.
* `Path get(URI uri)` — преобразует заданный объект типа URI. Это символьная строка, позволяющая идентифицировать какой-либо ресурс:
документ, изображение, файл и так далее. 
Например, строка `file:\\\C:\books\dune.epub` идентифицирует файл электронной книги, расположенной по пути `C:\\books`, как объект `Path`.

Класс `Paths` создали для того, чтобы получить из переданной строки или `URI` объект типа `Path`. 
Другой функциональности у него нет. Пример работы этого класса:

```java
import java.nio.file.Path;
import java.nio.file.Paths;

public class Practicum {

    public static void main(String[] args) {

        // использован интерфейс Path, который позволяет описать путь к файлам и каталогам
        Path myFavouriteFilePath =
            Paths.get("C:\\users\\username\\desktop\\favouriteFile.txt");
    }
}
```


### Интерфейс Path

Объект типа `Path` содержит имена директорий и файлов, которые составляют полный путь к файлу или каталогу.
Он также содержит методы для добавления элементов пути, их извлечения и манипуляций с ними. 
Остальные методы для разных действий вынесены в статические методы класса `Files`.

Некоторые из методов `Path`:
* `Path getFileName()` — возвращает имя файла из пути;
* `Path getParent()` — возвращает «родительскую» директорию по отношению к текущему пути (ту, которая находится выше по дереву директорий);
* `Path getRoot()` — возвращает «корневую» директорию (ту, которая находится на вершине дерева директорий);
* `java.io.File toFile() `— метод для перехода между старым и новым средством работы с файлами;
* `Path resolve(String other)` — возвращает путь к вложенному элементу с именем `other` в папке (при этом исходный путь должен быть папкой — файлы не могут содержать вложенных элементов).
* 
С остальными методами интерфейса Path вы можете ознакомиться в [официальной документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/file/Path.html).

С помощью описанных выше методов можно получить минимальную информацию о расположении объекта типа Path. Например:
```java
import java.nio.file.Path;
import java.nio.file.Paths;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) {

        // создаём объект Path с помощью статического метода get() класса Paths
        Path testFilePath = Paths.get(HOME, "test", "file.txt");

        // выводим информацию о файле
        System.out.println("Информация о файле: ");
        System.out.println(" - имя: " + testFilePath.getFileName());
        System.out.println(" - корневая директория: " + testFilePath.getRoot());
        System.out.println(" - родительская директория: " + testFilePath.getParent());

        // выводим элементы пути
        System.out.println("Элементы пути: ");
        for (Path element : testFilePath) {
            System.out.println(" - элемент пути: " + element);
        }
    }
}
```

### Класс Files

`Files` — это `final`-класс с `private`-конструктором. Он содержит только 
статические методы для выполнения различных действий. Его основные методы:
* `Path createFile(Path path, FileAttribute<?>... attrs)` — создаёт новый пустой файл. Выбрасывает исключение, если файл уже существует. Параметры метода: `path` — путь к файлу, который нужно создать, `attrs` — необязательный список атрибутов файла (в нём можно указать правила доступа к файлу, добавить информацию о создателе и так далее).
* `Path createDirectory(Path dir, FileAttribute<?>... attrs)` — создаёт новую директорию. Параметры метода: `dir` — директория, которую нужно создать, `attrs` — необязательный список атрибутов директории.
* `Path move(Path source, Path target, CopyOption. . . options)` — перемещает файл. Параметры метода: `source` — путь к файлу, который нужно переместить, `target` — путь к файлу назначения, `options` — необязательные параметры, определяющие, как нужно делать перемещение.
* `void delete(Path path)` — удаляет файл или директорию. Если удаляется директория, необходимо убедиться, что она пуста, иначе будет получено исключение `DirectoryNotEmptyException`. Если удаляется файл, необходимо убедиться, что он существует, иначе будет получено исключение `NoSuchFileException`. Параметры метода: `path` — путь к файлу или директории, которые нужно удалить.
* `boolean deleteIfExists(Path path)` — удаляет файл или директорию, если они существуют. Параметры метода: `path` — путь к файлу, который нужно удалить. Возвращаемое значение: `true` — если файл был удалён этим методом, `false` — если файл не может быть удалён, потому что не существует.

Остальные методы класса `Files` вы можете найти в [официальной документации](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/file/Files.html).

В примере ниже показана работа обозначенных методов:

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) throws IOException {

        // создаём файл testFile
        Path testFile =
            Files.createFile(Paths.get(HOME, "testFile.txt"));

        if (Files.exists(Paths.get(HOME, "testFile.txt"))) {
            System.out.println("Файл успешно создан.");
        }

        // создаём директорию testDirectory
        Path testDirectory =
            Files.createDirectory(Paths.get(HOME, "testDirectory"));
        if (Files.exists(Paths.get(HOME, "testDirectory"))) {
            System.out.println("Директория успешно создана.");
        }

        // перемещаем файл testFile в директорию testDirectory
        testFile = Files.move(testFile,
            Paths.get(HOME, "testDirectory", "testFile.txt"),
            REPLACE_EXISTING);

        if (Files.exists(
            Paths.get(HOME, "testDirectory", "testFile.txt"))) {

            System.out.println("Файл перемещён в testDirectory.");
        }

        // удаляем файл
        Files.delete(testFile);
        if (!Files.exists(
            Paths.get(HOME, "testDirectory", "testFile.txt"))) {

            System.out.println("Тестовый файл удалён.");
        }

        // удаляем пустую директорию
        Files.delete(testDirectory);
        if (!Files.exists(Paths.get(HOME, "testDirectory"))) {
            System.out.println("Директория удалена.");
        }
    }
}
```

### Метод copy()
Теперь расскажем о методе, которого не хватало в `File`. Это метод копирования `Path copy(Path source, Path target, CopyOption... options)`.
Его параметры: `source` — путь к исходному файлу, `target` — путь к тому файлу, что будет создан в результате копирования (включая имя нового файла),
`options` — необязательные параметры копирования. Существует три таких параметра:
* `REPLACE_EXISTING` — указывает, что если в директории назначения уже есть такой файл, то нужно его заменить;
* `COPY_ATTRIBUTES` — указывает, что нужно скопировать атрибуты оригинального файла в его копию;
* `ATOMIC_MOVE` — указывает, что необходимо переместить файл атомарно. Это значит, что перемещение или выполнится целиком, или не выполнится вообще.
💡 Обратите внимание

>💡 Обратите внимание: при копировании директории содержащиеся в ней файлы и каталоги копироваться не будут.

В примере ниже сначала создаётся объект типа `Path` для исходного файла (`sourceFile`) и объект для директории назначения (`targetDir`). Далее с помощью метода resolve
(англ. «разрешить»), который умеет объединять два пути в один, создаётся объект `targetFile` для пути файла назначения. После этого выполняется метод `copy()`.

```java
import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Practicum {

    private static final String HOME = System.getProperty("user.home");

    public static void main(String[] args) {

        // исходный файл
        Path sourceFile = Paths.get(HOME, "test.txt");
        // директория назначения
        Path targetDir = Paths.get(HOME, "test");

        copyFile(sourceFile, targetDir);
    }

    public static void copyFile(Path sourceFile, Path targetDir) {
        Path targetFile = targetDir.resolve(sourceFile.getFileName());

        try {
            Files.copy(sourceFile, targetFile);
        } catch (FileAlreadyExistsException e) {
            System.out.format("Файл %s уже существует.", targetFile);
        } catch (IOException e) {
            System.err.format("Произошла ошибка во время копирования файла.");
        }
    }

}
```

</details>

<details>

<summary>Потоки ввода-вывода. Запись и чтение</summary>

## Потоки ввода-вывода. Запись и чтение

Большинство современных программ так или иначе взаимодействуют с внешним миром.
Например, загружают информацию, обмениваются ею с другими приложениями или читают файлы. 
Иными словами, программы непрерывно получают и отправляют данные — вводят их и выводят. 
Этот процесс так и называется **вводом-выводом** (англ. _input/output_). 
В Java, как и во многих других языках программирования, существует специальное понятие для работы с вводом-выводом.

### Поток

**Поток** (англ. _stream_) — это бесконечная последовательность данных. Представьте трубу, в которую вместо воды поступают упорядоченные символы или байты.
Такие трубы можно соединять друг с другом, ведь один поток способен передавать данные в другой, предварительно модифицируя их.

![img.png](img.png)

Поток подключён к источнику (англ. _source_) или получателю данных (англ. _destination_). По направлению потоки делятся следующим образом:
* **потоки ввода** (англ. _input streams_), из которых считываются данные;
* **потоки вывода** (англ. _output streams_), в которые записываются данные.

А по типу передаваемых данных так:

* **символьные потоки** (англ. _character streams_), которые содержат символы;

![img_1.png](img_1.png)

* **байтовые потоки** (англ. _byte streams_), которые содержат информацию в виде последовательности байтов.

![img_2.png](img_2.png)


### Классы для работы с потоками

В Java все необходимые классы для работы с потоками ввода-вывода находятся в пакете jаvа.io. 
Благодаря этим классам разработчику не нужно вникать в особенности низкоуровневой организации операционных систем. 

Для каждого из типов потоков Java предлагает отдельный базовый абстрактный класс:
* `InputStream` — представляет поток ввода для чтения байтов;
* `OutputStream` — представляет поток вывода для записи байтов;
* `Reader` — представляет поток ввода для чтения символов;
* `Writer` — представляет поток вывода для записи символов.

![img_3.png](img_3.png)

Также в пакете `java.io` содержится множество подклассов этих классов. Все они предназначены для различных целей.
Например, для доступа к файлам или к сети, для чтения и записи текста и так далее.

Среди прочих в этом пакете есть подкласс `PrintStream`, наследник `OutputStream`.
На самом деле вы уже знакомы с ним. Поле `out` класса `System`, которое вы множество раз использовали
для вывода информации в консоль, как раз этого типа. `PrintStream` — стандартный выходной поток,
который открыт во время выполнения программы и готов принимать выходные данные для вывода в терминал.

### Потоки и файлы

Файлы — самые распространённые источники или получатели данных в приложении. 
Для работы с файлами у каждого из четырёх абстрактных классов потоков есть своя реализация:
`FileInputStream` и `FileOutputStream`; `FileReader` и `FileWriter`.

Выбор между байтовыми и символьными потоками зависит от того, с каким типом файла предстоит работать.
Для бинарных файлов, таких как картинки, видео, pdf-файлы, нужен байтовый поток
(`FileInputStream` для чтения байтов и `FileOutputStream` для их записи). 
Для текстовых файлов лучше использовать символьный поток (`FileReader` для чтения символов и `FileWriter` для их записи), 
хотя можно применять и байтовые потоки.

> 💡 Общая схема работы с потоками и файлами в Java выглядит так:
1. Создаётся потоковый объект и ассоциируется с файлом на диске.
2. Данные читаются из потока или записываются в поток.
3. Поток закрывается.

### Запись

Чтобы сделать запись в файл с помощью `FileWriter`, 
нужно сначала создать объект `FileWriter`. Далее методом `write()`,
который есть у всех потоков вывода, можно добавить строки в новый файл. В конце необходимо закрыть поток методом `close()`.

```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

public class Practicum {

    public static void main(String[] args) throws IOException {
        Writer fileWriter = new FileWriter("filewriter.txt");

        fileWriter.write("новая запись в новый файл\n");
        fileWriter.write("добавляем текст");

        fileWriter.close();
    }
}
```

![img_4.png](img_4.png)

> 💡 С конструктором `FileWriter(String fileName)` содержимое файла будет создаваться заново при каждом запуске программы.
Чтобы добавить содержимое к уже существующему файлу, необходимо воспользоваться конструктором `FileWriter(String fileName, 
boolean append)` и передать в него значение `true` для флага `append` (англ. «присоединять»). 
Это специальный признак того, что новые данные будут записаны в конец файла.

Запустите код из примера выше с признаком `append = true` и посмотрите, как изменится создаваемый файл `filewriter.txt`.

### Чтение

Чтобы прочитать текстовый файл, необходимо сначала создать объект `FileReader`,
который подключается к файлу. `FileReader` считывает данные по одному символу за раз, 
пока не будет достигнут конец файла.

Метод `read()` возвращает значение типа `int`. А `int` содержит 
значение `char` прочитанного символа. Если метод `read()` возвращает `-1`, значит,
в `FileReader` больше нет данных для чтения и его можно закрыть с помощью метода `close()`.

```java
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

public class Practicum {

    public static void main(String[] args) throws IOException {
        Reader fileReader = new FileReader("filereader.txt");

        int data = fileReader.read();
        while (data != -1) {
            System.out.print((char) data);
            data = fileReader.read();
        }

        fileReader.close();
    }
}
```

![img_5.png](img_5.png)

`filereader.txt`

```txt
Практикум
```

### Буферизация
В примере выше `FileReader` обращался за каждым символом напрямую к файлу.
То есть его содержимое считывалось посимвольно. Этот процесс можно ускорить, 
если применить **буферизацию** (от англ. _buffer_, «буфер»). **Буферизация** — способ ввода и вывода данных, 
при котором для их временного хранения используется область памяти — **буфер**.

Буфером может быть обычный массив. Данные по очереди попадают в него, накапливаются, 
а затем обрабатываются вместе. Если добавить буферизацию в рассмотренный нами выше код,
`FileReader` будет обращаться за символами не к файлу, а к буферу. Это увеличит производительность программы.

Буферизация используется не только для чтения файлов, но и для записи.
В таком случае новые символы будут сначала сохранены в буфере, а затем, 
когда он наполнится, одной порцией записаны в файл.

Мы покажем, как работать с буферизацией, на примере класса `BufferedReader`. `BufferedReader` — подкласс `Reader`,
а значит, он может использовать все те методы для чтения из потока,
которые определены в классе `Reader`. 
Например, `read()`. Также у него есть свой собственный метод `readLine()`, 
позволяющий считывать данные из потока построчно.

![img_6.png](img_6.png)

`BufferedReader` имеет следующие конструкторы:

```java
BufferedReader(Reader in)
BufferedReader(Reader in, int sz)
```

Обратите внимание, что в конструкторе `BufferedReader(Reader in, int sz)`, 
кроме потока ввода, из которого производится чтение, нужно также указать размер буфера,
в который будут считываться символы. Если не передать размер буфера в конструктор явно, 
программа использует значение по умолчанию — 8192 символа.

Пример кода чтения файла с буферизацией:

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Practicum {

    public static void main(String[] args) throws IOException {
        FileReader reader = new FileReader("bufferedreader.txt");
        BufferedReader br = new BufferedReader(reader);

        while (br.ready()) {
            String line = br.readLine();
            System.out.println(line);
        }

        br.close();
    }
}
```

![img_7.png](img_7.png)

`bufferedreader.txt`

```txt
первая строка
вторая строка
последняя строка 
```


</details>


<details>

<summary>Задание 1</summary>

## Задание 1

Вам нужно создать файловый менеджер. Приложение должно уметь:
* просматривать содержимое директории;
* создавать файлы и директории;
* переименовывать файлы или директории;
* полностью перемещать файлы или директории;
* удалять файлы или директории.

Пользователю необходимо выбрать, какую операцию он хочет выполнить с файлом или папкой, а затем ввести путь к нужному файлу.


```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (true) {
            printMenu();
            String command = scanner.nextLine();

            System.out.println("Введите путь к файлу/директории: ");
            String enteredPath = scanner.nextLine();
            Path path = ??? // создайте переменную пути
            if (!???) { // проверьте, не ошибся ли пользователь
                System.out.println("Введённый путь не существует.");
                break;
            }
            switch (command) {
                case "exit":
                    System.out.println("Выход.");
                    System.exit(0); // пользователь хочет найти выход, выход есть всегда
                    break;
                case "ls":
                    try {
                        for (String element : ? список элементов в path?) {
                            System.out.println(???);
                        }
                    } catch (Exception e) {
                        System.out.println("Произошла ошибка при запросе содержимого директории.");
                        e.printStackTrace();
                    }
                    break;

                case "mkdir":
                    try {
                        ???
                    } catch (IOException e) {
                        System.out.println("Произошла ошибка при создании директории.");
                        e.printStackTrace();
                    }
                    break;
                case "touch":
                    try {
                        ???
                    } catch (IOException e) {
                        System.out.println("Произошла ошибка при создании файла.");
                        e.printStackTrace();
                    }
                    break;
                case "rename":
                    System.out.println("Введите новое имя файла/директории: ");
                    String newName = scanner.nextLine();

                    try {
                        ??? // с помощью опции StandardCopyOption.REPLACE_EXISTING
                    } catch (IOException e) {
                        System.out.println("Произошла ошибка при переименовании файла/директории.");
                        e.printStackTrace();
                    }
                    break;
                case "rm_file":
                    try {
                        if (!???) {
                            ???
                        } else {
                            System.out.println("С помощью этой команды можно удалить только файл!");
                        }
                    } catch (IOException e) {
                        System.out.println("Произошла ошибка при удалении файла.");
                        e.printStackTrace();
                    }
                default:
                    System.out.println("Извините, такой команды пока нет.");
            }

        }
    }

    public static void printMenu() {
        System.out.println("Что вы хотите сделать? ");
        System.out.println("ls - посмотреть содержимое директории.");
        System.out.println("mkdir - создать директорию.");
        System.out.println("touch - создать файл.");
        System.out.println("rename - переименовать директорию/файл.");
        System.out.println("rm_file - удалить файл.");
        System.out.println("exit - выход.");
    }

}
```

### Подсказки

* Для объявления переменной `path` воспользуйтесь методом `Paths.get(enteredPath)`.
* Для перечисления всех файлов в директории воспользуйтесь вызовом `path.toFile().list()`.
* Для создания директории вам понадобится метод `Files.createDirectory(path)`.
* Создать файл можно с помощью метода `Files.createFile(path)`.
* Чтобы переименовать файл или директорию, удобно воспользоваться методом `Files.move`.
* Для удаления файла используйте метод `Files.deleteIfExists(path)`.

</details>

<details>

<summary>Задание 2</summary>

## Задание 2

В компании «Профессиональные программы» решили устроить голосование,
чтобы выбрать, чем заняться на летнем корпоративе. Варианты:

A — поехать на базу отдыха;

B — пойти в поход на байдарках;

C — отправиться на экскурсию в Дагестан;

D — устроить вечеринку в офисе.

Результаты голосования представлены в файле `result.txt`. 
Обработайте результат и выведите количество проголосовавших для каждого варианта.

`result.txt`

```txt
C
A
A
D
B
A
A
B
A
C
D
D
A
A
A
B
A
A
D
B
B
C
C
B
A
C
A
C
A
B
D
A
A
C
D
A
A
B
A
A
A
A
B
A
A
A
A
A
B
B
B
B
B
C
D
```

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class Practicum {

    public static void main(String[] args) throws IOException {
        Map<String, Integer> frequencyMap = new HashMap<>();

        FileReader reader = new FileReader("result.txt");
        BufferedReader br = new BufferedReader(reader);

        // читайте файл построчно и сразу обновляйте frequencyMap.

        // выведите результат в формате "<буква>: <количество>".

    }
}
```

### Ожидаемый результат

![img_8.png](img_8.png)


### Подсказки

* Для чтения создайте цикл `while` с условием `br.ready()`.
* В цикле `while` для чтения очередной строки используйте метод `readLine()`.
* Не забудьте закрыть поток методом `close()`.


</details>


   Предыдущее занятие   |         &nbsp;          |   Следующее занятие    
:----------------------:|:-----------------------:|:----------------------:
 [Урок 18](LESSON18.MD) | [Содержание](README.MD) | [Урок 20](LESSON20.MD) 