Предыдущее занятие |         &nbsp;          | Следующее занятие
:----------------:|:-----------------------:|:----------------:
[Урок 9](LESSON9.MD) | [Содержание](README.MD) | [Урок 12](LESSON11.md)

# Урок 11. Unit-тесты

# Требования к сдаче работы

Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.

***Критерии оценивания***

* Оценка 5 - надо сделать все пять заданий.
* Оценка 4 - надо сделать любые три задания.
* Оценка 3 - надо сделать одно любое задание.

# Оглавление

1. [Введение в тему](#введение-в-тему)
2. [Задачи тестирования](#задачи-тестирования)
   * [Требования к программе и сценарии тестирования](#требования-к-программе-и-сценарии-тестирования)
   * [Как проверять требования](#как-проверять-требования)
   * [Пример тестирования](#пример-тестирования)


<details>
<summary>Введение в тему</summary>

# Введение в тему

Один из способов проверить работоспособность программы — протестировать её. В этой теме поговорим о том, зачем нужно тестирование, какое оно бывает и как тестировать свой код максимально эффективно. Вы узнаете:
* когда нужно проводить тестирование;
* что такое фреймворк и какой фреймворк используют для тестирования на Java;
* что такое класс эквивалентности и граничные значения;
* какие бывают метрики покрытия кодовой базы тестами;
* чем различаются понятия покрытия требований и покрытия кода.
А также вы научитесь сами составлять тесты для различных требований, 
запускать их и анализировать результаты тестирования. После этой темы 
помимо финального проекта спринта вас ждёт тестирование по всем темам первого модуля. 
Итак, начинаем!

</details>

<details>

<summary>Задачи тестирования</summary>

# Задачи тестирования

[Оглавление](#оглавление)

Люди довольно часто совершают ошибки, а техника отказывает. По
этому в процесс любого производства включён этап проверки. Автомобили допускаются 
к серийному выпуску только после успешного прохождения всех краш-тестов, 
сложность которых возрастает с каждым годом. Чайники, миксеры и другие бытовые электроприборы 
проходят обязательные проверки на соответствие требованиям пожарной безопасности.

Всё это необходимо для предотвращения возможных рисков. Например, 4 июня 1996 года грузовая ракета Ариан-5 
взорвалась через 37 секунд после взлёта из-за ошибки в программе по расчёту угла наклона. 
Ущерб составил около одного миллиарда долларов.

Требования к качеству продуктов в современном мире становятся всё более строгими. 
Пользователи привыкли, что программное обеспечение работает почти идеально. 
Из-за любой ошибки ваш клиент может перейти к конкурентам или оставить негативный отзыв. 
Поэтому так важно, чтобы каждый разработчик понимал важность процесса тестирования продукта 
до его выпуска на широкую аудиторию.

**Тестирование программы** (англ. software testing) — это исследование, при котором происходит:
* проверка соответствия между ожидаемым и реальным поведением программы,
* а также выявление или подтверждение каких-либо её свойств.
* 
Есть много разных видов проверок: тестирование производительности, нагрузки, гипотез, 
безопасности и так далее. 
Вы изучите базовый вид — **функциональное тестирование** (англ. _functional testing_).
Именно оно проверяет, что программа соответствует **функциональным требованиям** 
(англ. _functional requirements_), то есть делает то, что от неё ожидает пользователь. 
Например, что при включении умного чайника вода нагревается, а не превращается в лёд.

![img.png](img.png)

## Требования к программе и сценарии тестирования

Чтобы проверить, что программа работает корректно, необходимо узнать, 
с какой целью она создавалась. 
Другими словами, нужно определить **требования к программе**
(англ. _software requirements_).

Требования могут иметь разную форму и содержание. 
Иногда они представлены в виде официальных документов: 
спецификаций и технических заданий. Часто таких документов нет, 
и единственный способ узнать требования — поговорить с заказчиком.

Требования разделяются на:

* **функциональные**, которые отвечают на вопрос, что должна делать программа. 
Например, на сайте по продаже билетов в кино должна быть кнопка «купить». 
При нажатии на неё будет открываться форма оплаты.

* **нефункциональные**, которые отвечают на вопрос, 
как программа должна выполняться. Вернёмся к примеру с сайтом. 
Нефункциональное требование может звучать так: форма оплаты должна 
открываться менее чем за две секунды с момента нажатия на кнопку «купить».

### Примеры

> **Функциональные требования**
> * Сервис должен отправлять письмо на почту пользователя с информацией о купленных билетах.
> * При закрытии программы должно появляться окно с предложением сохранить проект.
> * При переходе на новый уровень игрок должен получать количество золота по формуле [Уровень * 1000].

> **Нефункциональные требования**
> * Дата покупки должна отображаться как «число.месяц.год»
> * Номер бронирования билета должен пересылаться в строковом формате.
> * Приложение должно запускаться на Android выше 10-й версии.
> * Программа должна возвращать ответ в течение 100 миллисекунд.

## Как проверять требования

Итак, сначала нужно составить или получить список требований.
Затем — написать набор сценариев тестирования. 
Именно они будут определять, делает ли программа то, что от неё ожидается в разных ситуациях. 
Такие сценарии называют **тест-кейсами** (англ. _test case_).

Правильный тест-кейс состоит из трёх частей. 
Рассмотрим их на примере тестирования калькулятора:

* **Подготовка** — определение входных параметров и предусловий. 
Что нужно, чтобы начать тест? Какие данные нам потребуются?
Для проверки калькулятора нам нужны два числа на вход (например, `7` и `4`) и работающий экземпляр класса Calculator.
* **Исполнение** — определение процедуры тестирования. Как именно мы проверяем, 
что программа работает корректно? Какие для этого нужно вызвать методы? 
Какая будет последовательность действий? В примере с калькулятором у 
экземпляра класса вызываем метод сложения. 
В качестве аргументов передаём два числа, заданных на этапе подготовки.
* **Проверка** — сравнение ожидаемого результата с полученным. 
Проверяем, что результат метода в нашем калькуляторе совпадает с ожидаемым и равняется `11`.


Получив тест-кейсы, можно создать и провести **тесты**, 
то есть автоматические или ручные операции по проверке тест-кейсов.

![img_1.png](img_1.png)

## Пример тестирования

Перенесёмся в будущее. Представим, что вы стали успешным программистом на Java (ура!), 
и ваш руководитель дал вам первое важное задание. 
Нужно написать программу для одного крупного магазина, 
которая будет рассчитывать сумму покупки с учётом скидки.

Условия такие: если сумма находится в диапазоне от `1` до `999` рублей — скидки не будет.
А если сумма покупки больше или равна `1000` рублей — клиенту предоставляется скидка в размере
`2%`. Сумма покупки задаётся только в рублях, без копеек.

Здесь требования к программе прописаны прямо в условии задачи. Сформулируем их более конкретно:
1. Если сумма покупки находится в диапазоне от `1` до `999` рублей, то скидка будет `0%`.
2. Иначе скидка составит `2%`.

![img_2.png](img_2.png)

Теперь составим тест-кейсы. 
Поскольку у нас есть пронумерованный набор требований, 
тест-кейсы для удобства тоже можно пронумеровать:

1. Если сумма покупки находится в диапазоне от 1 до 999 рублей, то скидка будет 0%.
- 1.1. Совершается покупка на 1 рубль. Ожидаемое поведение: стоимость покупки составляет 1 рубль.
- 1.2. Совершается покупка на 333 рубля. Ожидаемое поведение: стоимость покупки составляет 333 рубля.
- 1.3. Совершается покупка на 999 рублей. Ожидаемое поведение: стоимость покупки составляет 999 рублей.
2. Иначе скидка составит 2 %.
- 2.1. Совершается покупка на 1000 рублей. Ожидаемое поведение: стоимость покупки составляет 980 рублей (−2%).
- 2.2. Совершается покупка на 2000 рублей. Ожидаемое поведение: стоимость покупки составляет 1960 рублей (−2%).

![img_3.png](img_3.png)

Тест-кейсы 1.1, 1.3 и 2.1. проверяют значения на границах интервалов [1;1000) и [1000;+∞).
Такие значения называются **граничными** (англ. _boundary values_), мы расскажем о них подробнее в следующих уроках. 
А пока заметим, что проверка граничных значений — важное условие. Значительная часть ошибок в программировании совершается именно на граничных значениях.

Помимо граничных значений, необходимо проверить выполнение требований на одном из чисел внутри интервала от 1 до 999.
Нет разницы, на каком именно — 333, 543 или любом другом. Все эти значения **эквивалентны** (англ. _equivalent values_).

Все тест-кейсы необходимо выполнить. Можно запускать программу самостоятельно, передавая различные значения на вход и сверяя их с ожидаемыми — это ручное тестирование. А можно написать код, который будет делать то же самое автоматически — это автоматическое тестирование.

После исполнения тест-кейса необходимо зафиксировать его результат. 
Если реальное поведение программы совпало с ожидаемым, то считается, что тест пройден (англ. _test passed_), 
если поведение отличается — тест провален (англ. _test failed_).

В автотестах результат обычно выводится в виде списка, в котором указано, какие из тестов были пройдены, а какие — провалены.
Это нужно для того, чтобы можно было перейти к любому из проваленных кейсов и исправить либо сам тест,
либо код, который он проверяет.

При ручном тестировании всё зависит от организации: кто-то ставит галочки на листке бумаги, 
кто-то фиксирует текстом в электронном виде, а кто-то просто запоминает. 
Главное — получить ответ: прошла программа тест или нет.

Подведём итог. Для проверки корректности программы нужно проделать следующие шаги:
* Получить/составить/выяснить набор функциональных и нефункциональных требований к программе.
* Для всех требований составить набор тест-кейсов и провести их.

---
### Из каких элементов должен состоять один тест-кейс?

> * **Определение входных параметров и предусловий.**
    Перед началом процедуры тестирования к ней нужно подготовиться.

> * **Сравнение ожидаемого результата с полученным.**
На этом шаге проверяется, исполняет ли программа конкретное требование.

> * **Определение процедуры тестирования.**
Процедура тестирования показывает, из каких шагов состоит тест-кейс.

> * **Информация о результате тест-кейса.**
Без информации о результатах тест-кейса нельзя дать ответ, отвечает ли программа установленным требованиям.
---
</details>

---
<details>

<summary>JUnit — фреймворк для тестов</summary>

# JUnit — фреймворк для тестов

Для тестирования существует огромное количество методов, которые объединены во множество библиотек.

## Знакомимся с JUnit

**Фреймворк** (англ. _framework_) — особый класс библиотек.
В нём содержится набор классов и методов,
которые вы можете использовать в своей программе. 
Фреймворк отличается от обычной библиотеки тем, что код библиотеки вы запускаете из вашего кода, 
в то время как фреймворк наоборот может использовать ваш код в своей работе.

![img_4.png](img_4.png)

Один из самых популярных фреймворков для тестирования на Java — **JUnit**. 
Чтобы написать первый тест с помощью **JUnit**, нужно сделать всего два шага:
* Подключить к проекту **JUnit** как библиотеку.
* Создать метод и пометить его аннотацией `@Test`. 

**Аннотации** — это механизм Java, представляющий дополнительную информацию о создаваемых классах и методах.

Вы уже сталкивались с ним в теме про наследование.

## Пример проекта с подключением JUnit

### IntelliJ Build tool

1. Запустите IntelliJ IDEA.
2. Выберите слева вкладку **Projects**  и нажмите на кнопку **New Project**.
   ![img.png](img6.png)

3. Дайте имя проекту **debug-app**.
   Language - **Java**, Build system - **IntelliJ**.
   В качестве JDK используйте Amazon Coretto 22. Нажмите **Create**.
   ![img_1.png](img7.png)
4. Если все настройки пройдены успешно появится окно с вашим проектом.
   ![img_2.png](img8.png)
5. Запустите свой проект

Проект успешно создан.



</details>

Предыдущее занятие | &nbsp; | Следующее занятие
:----------------:|:----------:|:----------------:
[Урок 9](Lesson9.md) | [Содержание](readme.md) | [Урок 11](Lesson11.md)