Предыдущее занятие | &nbsp; | Следующее занятие
:----------------:|:----------:|:----------------:
[Урок 7](Lesson7.md) | [Содержание](readme.md) | [Урок 9](Lesson9.md)

# Урок 8. Статические поля и методы, константы и перечисления


# Требования к сдаче работы
Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.


***Критерии оценивания***
* Оценка 5 - надо сделать все пять заданий.
* Оценка 4 - надо сделать любые три задания.
* Оценка 3 - надо сделать одно любое задание.

<details>

<summary>О чем эта тема?</summary>

> Вы уже знакомы с модификаторами доступа ```public```, ```private```, 
> ```protected```, ```default```. > В Java есть ещё одна группа 
> ключевых слов, которую принято называть другими модификаторами (англ. non-access modifiers — «модификаторы не-доступа»). Они уведомляют JVM об особом поведении класса, метода или переменной. 

![S3_02_1695902792.png](L8%2FS3_02_1695902792.png)

В этой теме вы изучите два самых популярных модификатора этой группы 
— ```final``` и ```static```. 
А ещё вы узнаете: 
- какие есть особенности при работе со ```static```-полями и методами;
-  что такое enum и для чего он используется;
- как создать своё перечисление и использовать его элементы в конструкции ```switch```;
- как объявить константу.
</details>

<details>

<summary>Модификатор static</summary>

# Модификатор static

Вы уже встречали модификатор ```static``` (англ. «статический», «неподвижный»), 
когда объявляли метод ```main()```. Из этого урока вы узнаете, 
почему ```static``` обязателен для ```main()```, 
в каких случаях его нужно применять к другим методам и что будет, 
если добавить ```static``` в объявлении переменной.

## Переменная с модификатором static
Переменная, объявленная внутри класса с модификатором ```static```, называется **статической**, 
потому что она привязана исключительно к самому классу и существует независимо от 
его экземпляров. 

Если значение обычной переменной можно менять у каждого из объектов 
по отдельности, то статическая переменная является общей для всех экземпляров класса. 

Это значит, что:
- внутри класса существует только одна копия статической переменной;
- на её значение ссылаются все экземпляры класса;
- если изменить значение статической переменной, оно изменится у всех объектов класса.

Чтобы сделать переменную статической, при её объявлении нужно добавить слово ```static```. 
Модификатор доступа может быть любым: public, private или protected. 
Например, создадим статическую переменную, которая будет хранить значение, 
равное количеству крыльев у класса ```Bird``` (англ. «птица»):
```java
public class Bird {
    public static int numberOfWings = 2;
}
```
Теперь у экземпляров класса ```Bird``` будет по два крыла. 
Если мы увеличим значение статической переменной ```numberOfWings``` в два раза,
то количество крыльев удвоится одновременно у всех объектов. 
А без модификатора ```static``` нам пришлось бы менять значение переменной 
в каждом из них по отдельности. Или останавливать программу, вносить правку в код 
и запускать всё заново.

Обращаться к статическим переменным нужно через имя класса — в формате

```<имя класса>.<имя переменной>```. 

Ведь статическая переменная относится не к конкретному экземпляру, а к самому классу:

```java
public class Practicum {

    public static void main(String[] args) {
        Bird.numberOfWings = 4;
    }
}
```

Теперь добавим в класс ```Bird``` статическую переменную `count` и будем увеличивать её 
значение на единицу при создании нового объекта. 

Так как переменная `count` **статическая**, при создании нового объекта в конструкторе класса `Bird` её значение не перезаписывается заново, а увеличивается на единицу:

Запустите код. Затем уберите ключевое слово static и проверьте, изменился ли результат.

```java
public class Practicum {
    public static void main(String[] args) {

        Bird tweety = new Bird();
        Bird pepper = new Bird();
        Bird flossie = new Bird();
    }
}

class Bird {

    private static int count = 0;

    Bird() {
        count++;
        System.out.println("Количество созданных объектов: " + count);
    }
}
```
```commandline
Результат
Количество созданных объектов: 1

Количество созданных объектов: 2

Количество созданных объектов: 3
```
Итак, переменную нужно делать **статической**, если:
- её значение не зависит от объектов (например, в коде будильника «Бодрое утро»
всем объектам пригодится одинаковый параметр — название приложения, 
поэтому его можно записать в статическую переменную ```static String nameOfApp = "Бодрое утро");```
- её значение будет совместно использоваться всеми объектами одного класса (например, в статической переменной удобно хранить переключатель состояния персонажей: если в компьютерной игре применить к противникам эффект заморозки, все они должны одновременно замереть).

## Метод с модификатором static
```Static```-метод так же, как и ```static```-переменная, принадлежит классу, 
а не конкретному экземпляру, и может использоваться без создания объекта. 
Для того чтобы создать свой статический метод, достаточно при его объявлении 
добавить ключевое слово ```static```:

```java
public static void method() {
} 
```
Внутри класса к **статическому** методу можно обратиться так же, как к обычному, — по имени. 
А для внешнего вызова можно обратиться через имя класса ```<имя класса>.<имя метода>```.

Например, у класса ```Integer``` есть статический метод ```max(int a, int b)```, 
который определяет наибольшее из двух переданных чисел. Вот как его можно применить в коде:
```java
public class Practicum {

    public static void main(String[] args) {
        int max = Integer.max(5, 7);

        System.out.println(max);
    }
}
```

Чаще всего статические методы применяются в утилитарных _(англ. utility — «полезный»)_ 
задачах — они отвечают за выполнение полезных действий, которые не меняют состояние объекта. 
Например, в стандартной библиотеке Java есть класс ```Arrays``` (англ. «множества»). 

Внутри него можно найти статические методы для работы с массивами: сортировку, поиск, сравнение и другие. 
Представим, что у нас есть массив ```int[] buses``` (англ. _bus_ — «автобус») с номерами междугородных автобусов,
которые ездят из Ярославля в Кострому. 
Для вывода на экран всех значений воспользуемся статическим методом ```Arrays.toString(int[] a)```:

```java
import java.util.Arrays;

public class Practicum {

    public static void main(String[] args) {
        int[] buses = {123, 29, 500, 738, 960};
        System.out.println(Arrays.toString(buses));
    }
}
```

## Ограничения статических методов
1. >Статический метод может обращаться только к статическим переменным или методам
```java
public class Practicum {
    String aphorism = "Не рискуя, мы рискуем в сто раз больше.";

    public static void main(String[] args) {
        System.out.println(aphorism);
    }
}
```
Если запустить этот код, то будет получена ошибка. Нестатическая переменная `aphorism` так же, 
как и любая обычная переменная класса, находится внутри объекта. 
Обратиться к ней можно только через ссылку на этот экземпляр. 
А при вызове статического метода ссылка на объект не передаётся. 
Поэтому программа завершилась с ошибкой: “Non-static field ```aphorism``` cannot be referenced from a static context” 
(англ. «На нестатическое поле ```aphorism``` нельзя ссылаться из статического контекста»). 

Если сделать обычную переменную aphorism (англ. «афоризм») статической и запустить код ещё раз, то ошибки уже не будет.
```java
public class Practicum {
    static String aphorism = "Не рискуя, мы рискуем в сто раз больше.";

    public static void main(String[] args) {
        System.out.println(aphorism);
    }
}
```

2. > @Override и static несовместимы

Ещё одно правило: переопределять статические методы нельзя. 
Но вы можете объявить статический метод с одинаковой сигнатурой в родительском классе и классе-наследнике. 
Это один из вариантов сокрытия (_hiding_) — вы уже сталкивались с этим явлением в теме про наследование.

3. > Ключевые слова ```this``` и ```super``` запрещены в ```static```-методах

И последнее ограничение: внутри статического метода нельзя использовать ключевые слова ```this``` и ```super```. 
Потому что они относятся к конкретным объектам класса, 
а ```static```-методы — к самому классу.

Предположим, нам нужно создать класс для хранения фамилии и имени.
И в нём должен быть метод ```parse```, который на вход принимает строку, 
а на выходе возвращает объект класса ```PersonName```.

```java
public class PersonName {

    private String lastName;
    private String firstName;

    // возвращает PersonName из заданной строки:
    public static PersonName parse(String fullName) {
        /* Метод разделяет (англ. split) строку по символу пробела.
        В результате в переменной parts будет массив из двух элементов: фамилия, имя*/ 
        String[] parts = fullName.split(" "); 

        this.lastName = parts[0];
        this.firstName = parts[1];
        
        return this;
    }
}

```

Такой код не скомпилируется. 
Возникнет ошибка: “```PersonName.this``` cannot be referenced from a static context” 
(англ. «Нельзя ссылаться из статического контекста на ```PersonName.this```»).
Чтобы этот код выполнился, необходимо добавить явное создание объекта:

```java
public class Practicum {

    public static void main(String[] args) {
        PersonName name = PersonName.parse("Добронравова Юлия");

        System.out.println(name.getFullName());
    }
}

class PersonName {

    private String lastName;
    private String firstName;

    public PersonName(String lastName, String firstName) {
        this.lastName = lastName;
        this.firstName = firstName;
    }

    public String getFullName() {
        return lastName + " " + firstName;
    }

    public String getFirstName() {
        return firstName;
    }

    // возвращает PersonName из заданной строки:
    public static PersonName parse(String fullName) {
        String[] parts = fullName.split(" ");

        return new PersonName(parts[0], parts[1]);
    }
}
```

## Статический импорт

К переменным и методам с модификатором ```static``` можно обращаться ещё одним способом —
через **_статический импорт_** (англ. ```static import```). 
Благодаря ему со статическими переменными и методами другого класса можно работать как с внутренними.

Например, в этой программе для вычисления площади круга 
мы обращаемся к статической переменной PI на уровне класса:

```java
public class Practicum {
   public static void main(String args[]) {
      int radius = 5;
      double area = Math.PI * (radius * radius); // обращение к переменной PI
      System.out.println("Площадь круга равна: " + area);
   }
}
```
А вот эта же программа, но со статическим импортом:

```java
import static java.lang.Math.PI;

public class Practicum {
   public static void main(String args[]) {
      int radius = 5;
      double area = **PI** * (radius * radius); // обращение к переменной PI
      System.out.println("Площадь круга равна: " + area);
   }
}
```

Благодаря статическому импорту мы смогли обратиться к статической переменной ```PI``` не через класс, а как к обычной переменной. 

Будьте аккуратны: излишне частое использование статического импорта внутри одного куска кода может
сделать программу нечитаемой и неподдерживаемой. 
Используйте ```import static```, только когда вам нужен частый доступ к статическим членам из одного или двух классов. 

## Модификатор ```static``` перед методом ```main()```

JVM выполняет код, начиная с метода ```main()``` — это одно из основных соглашений, принятых разработчиками. 
Если бы не ```main()```, нам приходилось бы для каждой программы указывать метод старта. 

А слово ```static``` необходимо для того, чтобы проект мог запускаться без объектов. 
Иначе нужно было бы каждую программу сопровождать пояснениями о том, какие параметры передавать в конструкторы экземпляров. 

Каждый из модификаторов метода ```public static void main(String[] args)``` обязателен. 
Если не указать ```static```, программа будет скомпилирована без каких-либо ошибок.
Но потом, во время выполнения, JVM будет искать метод `main()` с уровнем доступа `public`, статический,
с типом возвращаемого значения `void` и массивом `String` в качестве аргумента. 

Если такой метод не будет найден, выполнение прервётся с ошибкой: 
“Main method not found in class `A`, please define the main method as: `public static void main(String[] args)`”
(англ. «Ошибка: основной метод не найден в классе `A`. Пожалуйста, определите основной метод как: 
`public static void main(String[] args)`»).



</details>

<details>

<summary>Задание 1</summary>

>Перед вами кусок кода компьютерной игры про Средневековье. 
> В ней есть много разных локаций, в том числе — смешанные леса с хвойными и лиственными деревьями. 
> Вам нужно создать симулятор такого леса, поселить в нём зайцев-беляков. 
> Обратите внимание, что цвет шести у всех зайцев  ```color``` меняется в зависимости от времени года 
> ```season```: зимой — белый, летом — серо-рыжий.
- класс `Practicum`
```java
import java.util.ArrayList;

public class Practicum {

    public static void main(String[] args) {
        ArrayList<MountainHare> hares = new ArrayList<>();
        hares.add(new MountainHare(4, 4.4, 120));
        hares.add(new MountainHare(7, 3.6, 150));
        hares.add(new MountainHare(1, 2.3, 100));

        System.out.println("В лесу лето!");
        // создайте объект "летний лес с зайцами"
       
        System.out.println("Список зайцев:");
        // напечатайте список всех зайцев

        System.out.println("В лесу зима!");
        // поменяйте время года на зиму

		System.out.println("Список зайцев:");
        // напечатайте список всех зайцев
    }

}
```

- класс `MountainHare`
```java
public class MountainHare {

    // добавьте переменные и конструктор

    @Override
    public String toString() {
        return "Заяц-беляк: " +
            "age=" + age +
            ", weight=" + weight +
            ", jumpLength=" + jumpLength +
            ", color=" + color +
            '.';
    }
}
```

- класс `Forest`
```java
import java.util.ArrayList;

public class Forest {
private ArrayList<MountainHare> hares;

    // объявите недостающие переменные и добавьте конструктор

    // добавьте метод setSeason(String newSeason)
    // в этом методе реализуйте логику смены цвета шубок зайцев-беляков

	    // добавьте метод printHares()
    
}
```
### Подсказки

- Так как цвет шерсти у всех зайцев одинаковый и меняется одновременно, 
переменная `color` должна быть статической. А остальные параметры индивидуальны для каждого зайца.
- Время года одинаково для всех лесов смешанного типа, 
поэтому переменная `season` должна быть статической. 
Чтобы запретить смену времени года без изменения цвета шубок, 
необходимо объявить эту переменную с модификатором `private`.
- Метод `setSeason(String newSeason)` должен быть статическим,
так как смена времени года не зависит от конкретного объекта леса. 
В этом методе реализуйте логику смены цвета шубок зайцев-беляков: 
если время года — `"зима"`, то цвет зайцев — `"белый"`, а иначе — `"серо-рыжий"`.
- Команда автогенерации `alt+Insert` (`⌘ + N`— для Mac OS X) поможет с конструкторами и сеттером.
- Печать списка зайцев можно реализовать с помощью цикла `for` по списку `(MountainHare hare : hares)`.
- Для того чтобы создать летний лес, воспользуйтесь сеттером и поменяйте сезон на `"лето"`.

</details>

<details>

<summary>Модификатор final</summary>

# Модификатор final

Одни элементы кода могут обновлять свои значения — например, обычные и ```static```-переменные,
а другие должны оставаться неизменными. Для всего, что в программе менять нельзя, 
есть модификатор ```final``` (англ. «окончательный»).
Рассмотрим разницу между обычной переменной и ```final``` на примере птиц. 
Живая птица находится в постоянном движении. Она летает, поёт и меняет цвет оперения. 
Эти характеристики удобнее всего хранить в обычных переменных.
Другое дело — бронзовая птица. Статуэтки не меняются, и в этом их ценность. 
Если мы хотим, чтобы такая птица «застыла» в нашем коде, 
её положение нужно записать в `final`-переменную.

### Переменная с модификатором `final`

Если при объявлении переменной добавить модификатор `final`,
то после инициализации её значение станет окончательным — изменить его будет нельзя. Например:

```java
public class Practicum {
 
    public static void main(String[] args) {
        final String figureOfEarth = "spherical"; // инициализация final-переменной 
        figureOfEarth = "flat"; // попытка изменить значение final-переменной

        System.out.println(figureOfEarth);
    }
}

```
Такая программа вызовет ошибку, поскольку идет попытка присвоить новое значение `final`-переменной.
```
submission/Practicum.java:5: error: cannot assign a value to final variable figureOfEarth

        figureOfEarth = "flat"; // попытка изменить значение final-переменной

        ^

1 error
```
> Мы попытались присвоить переменной `figureOfEarth` (от англ. «форма Земли») 
> новое значение `"flat"`, и программа завершила работу с ошибкой. 
> Потому что `figureOfEarth` — это `final`-переменная, а значит, она может быть проинициализирована только один раз.


Для переменных с примитивным типом это правило работает всегда. Если же `final`-переменная ссылается на объект,
то ситуация более сложная:
- состояние объекта менять можно;
- а вот присваивать `final`-переменной другой объект нельзя.

Запустите программу и посмотрите, как меняется состояние объекта,
на который ссылается `final`-переменная `incomeBook` (от англ. «книга доходов»):

```java
import java.util.ArrayList;
import java.util.List;

public class Practicum {

    public static void main(String[] args) {
				
				// инициализация final-переменной:
        final List<Integer> incomeBook = new ArrayList<>();
        
        System.out.println(sum(incomeBook));

        // изменение состояния объекта:
        incomeBook.add(4300);
        incomeBook.add(1500);

        System.out.println(sum(incomeBook));
    }

    public static int sum(List<Integer> list) {
        int sum = 0;

        for (int i : list) {
            sum = sum + i;
        }

        return sum;
    }
}

```

Попробуем переменной `incomeBook` после её инициализации присвоить другой объект.
Например, добавим строку: `incomeBook = new ArrayList<>();`.

```java
import java.util.ArrayList;
import java.util.List;

public class Practicum {

    public static void main(String[] args) {
				
				// инициализация final-переменной:
        final List<Integer> incomeBook = new ArrayList<>();
        
        System.out.println(sum(incomeBook));

        // изменение состояния объекта:
        incomeBook.add(4300);
        incomeBook.add(1500);
        incomeBook = new ArrayList<>(); // попытка final-переменной присвоить новый объект 
        System.out.println(sum(incomeBook));
    }

    public static int sum(List<Integer> list) {
        int sum = 0;

        for (int i : list) {
            sum = sum + i;
        }

        return sum;
    }
}
```
> при запуске этой программы мы получим ошибку, так как пытаемся `final`-переменной присвоить новый объект


```
submission/Practicum.java:16: error: cannot assign a value to final variable incomeBook

        incomeBook = new ArrayList<>();

        ^

1 error
```


Переменную с модификатором `final` необязательно инициализировать сразу.
Это можно сделать в любой момент после её объявления и до первого применения в коде.
Будьте аккуратны: любое присвоенное ей значение станет финальным.
Например, добавим инициализацию переменной `yearOfBirth` (от англ. «год рождения») после объявления:

```java
import java.util.ArrayList;
import java.util.List;

public class Practicum {

    public static void main(String[] args) {
        final int yearOfBirth; // объявление final-переменной
        yearOfBirth = 1989;
        System.out.println("Я родился в " + yearOfBirth + " году."); // первое применение final-переменной
    }
}

```

Есть ещё одно правило. Переменная с модификатором `final` уровня класса обязательно должна 
быть проинициализирована:
- при объявлении — если значение для всех объектов одинаково;
- или в теле конструктора — если значение для каждого экземпляра класса уникально.

При этом и в том, и в другом случае у каждого из объектов будет своё финальное поле,
а не общее, как в случае с модификатором `static`.

Если вы запустите этот код, возникнет ошибка.
```java
public class Practicum {

    private final int busTicket = 990;
    private final int airplaneTicket;
    private final int trainTicket;

    public Practicum() {
        this.airplaneTicket = 3590;
    }

    public int getTotalPrice() {
        return busTicket + airplaneTicket + trainTicket;
    }

    public static void main(String[] args) {
        Practicum practicum = new Practicum();
        System.out.println("Расходы на транспорт в путешествии: " + practicum.getTotalPrice() + " р.");
    }
}
```
Появится ошибка, поскольку мы пытаемся обратиться к значению переменной `trainTicket`, которая не проинициализирована.
```
submission/Practicum.java:9: error: variable trainTicket might not have been initialized

    }

    ^

1 error

```
На практике такой вариант инициализации финальных переменных уровня класса, 
как у  `busTicket` из примера выше, встречается редко. 
Обычно такие переменные инициализируют значением из входных параметров конструктора.

### Метод с модификатором `final`

Модификатор `final` защищает метод от переопределения в подклассе. 
Это значит, что реализация метода самодостаточна и завершена — 
дорабатывать или менять его в дочернем классе нельзя.
Допустим, у нас есть класс `Bicycle` (англ. «велосипед»). 
От него можно унаследовать подклассы для велосипедов с разными спецификациями:
- спортивных или шоссейных;
- двух-, трёх- или четырёхколёсных и т. д.

Но независимо от вида велосипеда, он обязательно должен делать две вещи:
- снижать скорость — если велосипедист нажимает на тормоз,
- и разгоняться — если активно крутятся педали.

Поэтому метод торможения `applyBrake` и 
метод разгона `speedUp` можно объявить с модификатором `final`, 
чтобы их нельзя было переопределить.

```java
public class Bicycle {
    
    protected int speed;
        
    public final void applyBrake() {
        speed--;
    }
        
    public final void speedUp() {
        speed++;
    }
}
```

А вот к `private`-методам применять ключевое слово `final` 
не нужно — их и без него никогда и нигде нельзя переопределять. 
К конструктору тоже нет необходимости добавлять `final`,
потому что он никогда не наследуется.

### Класс с модификатором `final`

Чтобы запретить наследование класса, объявите его `final`. 
Тогда создать от него подклассы будет невозможно.

Посмотрите на этот код:

```java
public final class Bicycle {
}

public class MountainBike extends Bicycle {
} 
```

Так как класс `Bicycle` объявлен с модификатором `final`, от него нельзя наследоваться.

На этапе компиляции программа завершится с ошибкой:
“Cannot inherit from final `Bicycle`” (англ. «У класса `Bicycle` не может быть подклассов».)

А ещё все его методы тоже становятся `final`. Это логично: раз от класса нельзя ничего наследовать, то и переопределить его методы не получится.

> 📌 Если автор кода создал класс с модификатором `final`, 
> значит, он хотел, чтобы его структура оставалась 
> постоянной из соображений логики или безопасности.

Вы уже встречались с `final`-классами. 
Как правило, это классы-обёртки: `Integer`, `Boolean`, `Double` и другие.
</details>

<details>
<summary>Константы</summary>

Переменная — не единственный способ хранения данных в программе. 
Есть ещё «постоянная», или **константа** (англ. _constant_), — она называется так, потому что изменить её значение во время работы программы невозможно.

Вы наверняка встречались с константами в школе — на уроках математики, химии или физики. 
Там константами называются величины, которые не меняются никогда: 
скорость света в вакууме или число π.


В отличие от них, константы в программировании постоянны 
только во время выполнения программы. Например, в коде онлайн-магазина может б
ыть константа для хранения минимальной суммы заказа: `MIN_ORDER_PRICE = 1000;`.
Если через год количество покупателей вырастет и затраты на логистику снизятся, 
эту сумму можно будет уменьшить. Разработчик просто заменит в коде
значение константы `MIN_ORDER_PRICE = 500;` и выпустит новую версию приложения.

В этом уроке мы расскажем о том, как создавать и правильно применять константы.

### Как сделать переменную константой

В стандартной библиотеке Java есть много констант. Вот некоторые из них:
* `MIN_VALUE` (минимальное значение) и `MAX_VALUE` (максимальное значение) класса `Integer`,
* `TRUE` и `FALSE` класса `Boolean` и многие другие.

Программист может не только обращаться к стандартным константам, «зашитым» в язык программирования, но и создать свои.

Константа в Java — это статическое финальное поле. 
Чтобы его создать, примените модификаторы static и final. 
И обязательно инициализируйте его при объявлении. Делается это так:

```java
static final тип ИМЯ_КОНСТАНТЫ = значение; // объявление и инициализация константы
```
> Если не инициализировать `static final` константу сразу — произойдёт ошибка компиляции.

При этом порядок написания модификаторов не имеет значения: `static final` или `final static`.
И в том, и в другом случае мы получим константу.

```java
public static final double PI = 3.14; // объявление и инициализация числа π 
```
Для имён констант в Java принято использовать стиль **SCREAMING_SNAKE_CASE** 
(англ. «регистр кричащей змеи») — слова внутри имени пишутся в верхнем регистре 
и разделяются символом подчёркивания. 
Благодаря этому константы можно быстро отличить от обычных переменных:

```java
static final int MAX_VALUE = 1000; //это константа
static final String PLAN_IDENTIFICATOR = "planId"; // и это константа

final double length = 4.5; // финальная переменная
boolean isCompleted = false; // логическая переменная
```
![img.png](images1-9/img.png)


Переменную с модификатором `final` тоже можно назвать **константой**. 
Она константна на уровне отдельных объектов, при этом её значение для каждого из них может быть разным.

Например, в классе `Cat` можно создать финальную переменную `final String furColor;`.
В конструкторе объектов у `firstCat` ей будет присвоено значение `"grey"`, а у `secondCat` — `"white"`. 
И в том, и в другом случае переменная `furColor` — неизменяемая, 
но значения у неё при этом разные.

А константы, которые объявляются через `static final`, общие для всех объектов.
У того же класса `Cat` может быть константа `static final SOUND = "МЯУ!"`, и она будет храниться в единственном экземпляре для всех объектов класса.

![img_1.png](images1-9/img_1.png)

### Значения констант

В константе может храниться не только единичное значение, 
но и полноценное выражение, включающее обращения к другим статическим полям или вызовы статических методов. Такие выражения помогают улучшить читаемость кода.

Представьте, что вы участвуете в разработке приложения, 
с помощью которого можно бронировать отели по всему миру и оставлять о них отзывы. 
Вам нужно поставить ограничение на максимальный размер загружаемого фото — 5 Мбайт. 
В Java основная единица измерения при работе с файлами — байт, 
поэтому допустимый размер файла необходимо преобразовать в байты.
Есть два основных варианта действий:

* завести константу с единичным значением: `static final int MAX_FILE_SIZE = 5242880;`
* или поместить в неё выражение: `static final int MAX_FILE_SIZE = 5 * 1024 * 1024;`.

В первом случае программисту придётся посчитать значение в калькуляторе и 
вписать это огромное число в константу. 
А тот, кто будет работать с кодом после него, вряд ли сможет сразу понять, 
сколько мегабайтов прячется за этими цифрами.

Если же в константу `MAX_FILE_SIZE` записать выражение, 
оно вычислится один раз и сохранится в памяти компьютера. 
Любой программист, которому потом понадобится уточнить, 
каким может быть максимальный размер файла, 
сразу поймёт, что это 5 Мбайт. Ещё один плюс: изменить значение такой константы очень легко. 
Например, чтобы увеличить её до 10 Мбайт, достаточно заменить в выражении `5` на `10`. 
И никакой калькулятор не нужен!

### Применение
Константы помогают бороться с **магическими**, 
то есть не понятно что означающими числами (от англ. _magic numbers_) в коде.
Посмотрите на этот метод:

```java
public class Registration {

    public void validateCredentials(String phone, String password) {
        if (phone.length() != 11) {
            System.out.println("Введите номер в формате 7xxxxxxxxxxx, где x - любая цифра.");
        }
        if (password.length() < 8) {
            System.out.println("Минимальная длина пароля: 8 знаков.");
        }
    }
}
```

В нём есть две проблемы:
* Во-первых, чтобы понять, что такое 11 и 8, вам нужно прочитать весь код. 
Это и есть магические числа.
* Во-вторых, если мы захотим изменить одно из них, например, 
значение минимальной длины пароля, нужно будет искать это число и менять его во всём коде. 
Потому что это значение используется не только в условии оператора `if`, 
но и в сообщении, которое выводится на экран пользователя. А теперь представьте,
что у вас не два магических числа, а несколько десятков, и все они разбросаны по
разным строчкам кода.
* 

Чтобы исправить это, нужно добавить в метод константы с подходящими именами.

Вынесем магические числа в константы с именами `MIN_PASSWORD_LENGTH` и `PHONE_LENGTH`.

```java

public class Registration {
   public static final int MIN_PASSWORD_LENGTH = 8;
  public static final int PHONE_LENGTH = 11;
    public static void validateCredentials(String phone, String password) {
        if (phone.length() != PHONE_LENGTH) {
            System.out.println("Введите номер в формате 7xxxxxxxxxxx, где x - любая цифра.");
        }
        if (password.length() < MIN_PASSWORD_LENGTH) {
            System.out.println("Минимальная длина пароля: 8 знаков.");
        }
    }

    public static void main(String[] args) {
        validateCredentials("7901000000", "Qwerty");
    }
}

```

Обратите внимание, что строки из метода `println()` в общем случае не выносятся в константы, 
потому что их назначение и так понятно. 
Но если какой-то текст в программе повторяется слишком часто, то можно и его сделать константой.

</details>

<details>
<summary>Задание 2</summary>

Во всех банковских приложениях есть возможность перевода денег. 
Как правило, прежде чем выполнить перевод, система должна проверить, 
правильно ли введены все необходимые данные.
Ваша задача — реализовать класс `TransactionValidator`, 
в котором будет находиться логика проверки суммы перевода. 
Минимальная сумма перевода — `MIN_AMOUNT` (1 р.), 
максимальная сумма перевода — `MAX_AMOUNT` (5000 р.).

### Practicum
```java
import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Пожалуйста, введите сумму перевода в рублях.");
        // считайте сумму перевода при помощи scanner.nextDouble()

        boolean isValid = ... // добавьте вызов метод isValidAmount
        if (isValid) 
            System.out.println("Спасибо! Ваш перевод на сумму " + amount + " р. успешно выполнен.");
        }
    }
}
```
### TransactionValidator
```java
public class TransactionValidator {
    // объявите константы

    // объявите метод isValidAmount()
    // внутри метода добавьте проверки на минимальную и максимальную сумму перевода
    System.out.println("Минимальная сумма перевода: " + ... + " р. Попробуйте ещё раз!");
    System.out.println("Максимальная сумма перевода: " + ... + " р. Попробуйте ещё раз!");
}

```


### Подсказки

* Метод `isValidAmount` нужно сделать статическим.
* Метод `isValidAmount` на вход будет принимать сумму перевода, а на выходе возвращать `true`, если все проверки успешно пройдены, или `false`, если обнаружены ошибки.
* Для объявления констант используйте модификаторы `public static final`.
* Сумма перевода может содержать цифры после запятой.
* Константы должны быть не только в выражении `if`, но и в сообщениях об ошибке.

</details>

<details>
<summary>Перечисляемый тип enum</summary>


Кроме примитивов и классов, в Java есть специальный тип данных, 
который называется **перечисление** (англ. _enumerated type_, «перечисляемый тип»).
Он нужен для хранения множества значений — но не любого, а ограниченного.

Вот примеры таких ограниченных множеств: четыре времени года, семь нот, четыре стороны света, 
семь дней недели, двенадцать месяцев и так далее. 
В этом уроке вы научитесь создавать перечисления и узнаете, как с ними работать.

### Как создать перечисление
Для объявления перечисления применяется ключевое слово `enum`. 
После него пишется имя в UpperCamelCase, 
а затем в фигурных скобках перечисляются элементы ограниченного множества — списком, 
через запятую.
Например, перечисление дней недели выглядит так:

```java
public enum DayOfWeek {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```
Все элементы перечисления принято писать как константы: 
в верхнем регистре, разделяя слова внутри названий символами подчёркивания.
Дело в том, что перечисляемый тип по сути — это и есть список логически связанных констант. 
Ведь количество сторон света или времён года вряд ли когда-нибудь изменится.

Поэтому иногда значения перечисления так и называют: константы перечисления. 
Каждая из них — `static final` и не может быть изменена после создания.
![img_2.png](images1-9/img_2.png)

Создадим перечисление `TrafficLight`, состоящее из трёх сигналов стандартного светофора:
красного (red), жёлтого (yellow) и зелёного (green).
```java
// объявите перечисление
enum TrafficLight {
    RED,
    YELLOW,
    GREEN
} 

```

Чтобы создать перечисление в IntelliJ IDEA:
* в структуре текущего проекта выберите New → Java Class;
* в появившемся окне введите имя нового файла (оно должно совпадать с названием перечисления) и выберите тип Enum.

![img_3.png](images1-9/img_3.png)

### Переменная с типом `enum`
Так же, как создаются переменные с типом `String` или `int`, 
можно создавать переменные с типом объявленного перечисления. 
В такой переменной можно, например, хранить жанр фильма.


```java

public class Film {
    String title;
    FilmGenre genre;
}

enum FilmGenre {
    FAMILY, // семейный
    COMEDY, // комедия
    DOCUMENTARY, // документальный
    DRAMA, // драма
    HORROR, // фильм ужасов
    FANTASY, // фантастический
    THRILLER // триллер
}

```

Значение переменной `genre`, как и других переменных c типом `enum`, 
нужно инициализировать в упрощённом виде — без оператора `new`.
```java
FilmGenre genre = FilmGenre.COMEDY;

```

Это связано с тем, что переменной с типом enum можно присвоить только то значение,
которое определено в перечислении, а значит, 
существует в единственном экземпляре на всю программу. 
В примере с фильмами переменной genre можно присвоить
только одно из значений перечисления `FilmGenre`.

Элементы перечисления можно сравнивать друг с другом с помощью оператора `==`. 
На этом строится фильтр фильмов по определённому жанру:

```java
import java.util.ArrayList;

public class Practicum {

    public static void main(String[] args) {
        ArrayList<Film> films = new ArrayList<>();
        films.add(new Film("Зелёная миля", FilmGenre.DRAMA));
        films.add(new Film("Побег из Шоушенка", FilmGenre.DRAMA));
        films.add(new Film("Властелин колец: Братство Кольца", FilmGenre.FANTASY));
        films.add(new Film("Король Лев", FilmGenre.FAMILY));

        filterByGenre(films, FilmGenre.FAMILY);
    }

    // метод для фильтрации списка фильмов по жанру:
    public static void filterByGenre(ArrayList<Film> films, FilmGenre genre) {
        for (Film film : films) {
            // Сравнение жанра фильма из списка с искомым жанром:
            if (film.getGenre() == genre) {
                System.out.println(film.getTitle());
            }
        }
    }
}

class Film {
    private String title;
    private FilmGenre genre;

    public Film(String title, FilmGenre genre) {
        this.title = title;
        this.genre = genre;
    }

    public String getTitle() {
        return title;
    }

    public FilmGenre getGenre() {
        return genre;
    }
}

enum FilmGenre {
    FAMILY, // семейный
    COMEDY, // комедия
    DOCUMENTARY, // документальный
    DRAMA, // драма
    HORROR, // фильм ужасов
    FANTASY, // фантастический
    THRILLER // триллер
}

```
```
Результат
Король Лев
```

</details>

<details>
<summary>Задание 3</summary>
Перед вами часть программы для хранения списка задач с приоритетом. Приоритет (англ. _task priority_) может быть:
* высокий (англ. high) — `TaskPriority.HIGH`,
* средний (англ. medium) — `TaskPriority.MEDIUM`,
* низкий (англ. low) — `TaskPriority.LOW`.
Вам нужно реализовать поиск задач с наивысшим приоритетом из предложенного списка.

### class Practicum
```java
// импортируйте нужные пакеты

public class Practicum {

    public static void main(String[] args) {
        ArrayList<Task> tasks = new ArrayList<>();
        tasks.add(new Task(TaskPriority.HIGH, "Оплатить интернет."));
        tasks.add(new Task(TaskPriority.LOW, "Сходить в парикмахерскую."));
        tasks.add(new Task(TaskPriority.MEDIUM, "Выбрать подарок подруге на ДР."));
        tasks.add(new Task(TaskPriority.MEDIUM, "Купить билеты в театр."));
        tasks.add(new Task(TaskPriority.HIGH, "Посетить вебинар по английскому языку."));
        tasks.add(new Task(TaskPriority.LOW, "Купить пылесос."));

        System.out.println("Задачи с наивысшим приоритетом на сегодня:");
        ... // цикл for для поиска задач
    }
}
```
### class Task
```java
public class Task {

    ... // добавьте переменную priority с приоритетом задачи
    private String description;

    ...// добавьте конструктор класса

    ... // добавьте метод get для приоритета

    public String getDescription() {
        return description;
    }
}
```

### перечисление TaskPriority
```java
... // добавьте перечисление TaskPriority
```


### Подсказки

* Для работы со списками вам понадобятся импортировать класс `ArrayList`.
* Для хранения значений приоритета создайте перечисление `TaskPriority`.
* Цикл `for` поможет перебрать все дела в списке.
* Для поиска задач с максимальным приоритетом `TaskPriority.HIGH`воспользуйтесь оператором `==`.

</details>

<details>
<summary>Работа с перечислениями</summary>

Итак, перечисления помогают группировать логически связанные 
значения и повышают читаемость кода. 
А ещё с ними удобно работать — благодаря нескольким 
стандартным методам и оператору `switch`. 

### Добавляем методы
#### Методы класса `object`
Все методы класса `Object` — `toString()`, `getClass()`, `hashCode()` и другие — можно
применять и к `enum`.
Отдельно отметим метод `equals()`. Рассмотрим его на примере программы, 
которая хранит график работы музея «Эрмитаж»:
* вторник, четверг, воскресенье с 11:00 до 19:00;
* среда, пятница, суббота — с 11:00 до 20:00;
* понедельник — выходной.

```java
public class Practicum {

    public static void main(String[] args) {
        printHoursForDay(DayOfWeek.FRIDAY);
    }

    public static void printHoursForDay(DayOfWeek day) {

        if (DayOfWeek.TUESDAY.equals(day) || DayOfWeek.THURSDAY.equals(day) 
            || DayOfWeek.SUNDAY.equals(day)) {
            
            System.out.println("В этот день музей работает с 11:00 до 19:00. Ждём вас!");
        } else if (DayOfWeek.WEDNESDAY.equals(day) || DayOfWeek.FRIDAY.equals(day) 
            || DayOfWeek.SATURDAY.equals(day)) {
            
            System.out.println("В этот день музей работает с 11:00 до 20:00. Ждём вас!");
        } else {
            System.out.println("Понедельник — выходной. Будем рады видеть вас в другой день!");
        }
    }
}

enum DayOfWeek {

    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```
> Если заменить метод `equals()` на оператор ==, то результат не изменится.
> Метод `equals()` в данном случае совпадает с оператором `==`. 
> Дело в том, что каждая из констант перечисления хранится 
> в единственном экземпляре. 
> Поэтому если создать несколько переменных со значением, 
> например, `Color.GREEN,` 
> все они будут ссылаться на один и тот же элемент перечисления —
> `GREEN` (а оператор == как раз это и проверяет).

>💡 Нельзя однозначно сказать, что лучше использовать: 
> equals() или ==. И у того, и у другого варианта есть свои плюсы и минусы, 
> и среди разработчиков нет единого мнения. 
> Сторонники equals() говорят о том, что любой элемент enum — это объект, 
> соответственно, сравнивать его значения нужно как объекты. 
> Сторонники == в свою очередь парируют, 
> что оператор сравнения повышает читаемость.


Есть небольшой нюанс в том, как ведут себя эти методы при работе с `null`: 
если сравнивать объект с элементом перечисления через метод,
то `equals` всегда должен быть вызван у элемента перечисления, 
а не у объекта, с которым мы этот элемент пытаемся сравнить. 
Иначе возникнет ошибка `NullPointerException`.
Запустите код и убедитесь, что произойдёт ошибка. 
```java
public class Practicum {

    public static void main(String[] args) {
        TrafficLight t = null;
        tryToCrossStreet(t);
    }

    public static void tryToCrossStreet(TrafficLight light) {
        if (light.equals(TrafficLight.GREEN)) {
            System.out.println("Переходите дорогу!");
        } else {
            System.out.println("Ждите");
        }
    }
}

enum TrafficLight {
    RED,
    YELLOW,
    GREEN
}
```
```
Результат
Exception in thread "main" java.lang.NullPointerException

	at Practicum.tryToCrossStreet(Practicum.java:9)

	at Practicum.main(Practicum.java:5)
```

Мы попытались вызвать метод equals у null и это привело к исключению. 

Если вызвать метод equals у элемента перечисления TrafficLight.GREEN,
а объект light передайте в качестве аргумента.
Проблема должна исчезнуть. 
```java
public class Practicum {

    public static void main(String[] args) {
        TrafficLight t = null;
        tryToCrossStreet(t);
    }

    public static void tryToCrossStreet(TrafficLight light) {
        if (TrafficLight.GREEN.equals(light)) {
            System.out.println("Переходите дорогу!");
        } else {
            System.out.println("Ждите");
        }
    }
}

enum TrafficLight {
    RED,
    YELLOW,
    GREEN
}
```
```
Результат
Ждите
```
Если же заменить equals на ==, то ошибки не будет в любом случае.

> В этом небольшом примере легко заметить, что в качестве аргумента 
> в метод передаётся `null`, но в больших программах отследить, 
> кто и что передаёт в метод — сложно. 
> Будьте осторожны и не забывайте о правильно порядке вызова метода equals.

### Метод `values()`

Возвращает массив, содержащий все значения перечисления в том же порядке, в котором они объявлены.

Вот, например, перечисление основных видов чая:

```java
public class Practicum {

    public static void main(String[] args) {
        for (TeaType type: TeaType.values()){
            System.out.println(type);
        }
    }
}

enum TeaType {

    BLACK,
    GREEN,
    WHITE,
    OOLONG,
    HERBAL
}

```
```
Результат
BLACK

GREEN

WHITE

OOLONG

HERBAL
```
> Чаще всего этот метод используется в тех частях приложения, где нужно предоставить все возможные значения: 
> в выпадающих списках, перечислениях доступных опций и так далее

### Метод `valueOf(String name)`
Находит и возвращает константу перечисления, которая равна значению строки name. 
Если элемент не будет найден, 
выполнение метода завершится с ошибкой.

```java
public class Practicum {

    public static void main(String[] args) {
        System.out.println(LanguageLevel.valueOf("BEGINNER"));
    }
}

enum LanguageLevel {
    BEGINNER,
    ELEMENTARY,
    INTERMEDIATE,
    UPPER_INTERMEDIATE,
    ADVANCED,
    PROFICIENT
}
```
```
Результат
BEGINNER
```


Если заменить `BEGINNER` на `beginner`, 
возникнет ошибка: “No enum constant `LanguageLevel.beginner`” 
(англ. «Константы перечисления `LanguageLevel.beginner` нет»).

---

Такой метод будет полезен,
когда одному приложению нужно принять константу 
перечисления от другого приложения.

### Метод `name()`

Возвращает имя элемента перечисления. Запустите этот код:
```java
public class Practicum {

    public static void main(String[] args) {
        DayOfWeek friday = DayOfWeek.FRIDAY;

        // До этого в примерах вывод значения выглядел так:
        System.out.println(friday);
	    // Используем метод name():
        System.out.println(friday.name());
        // Не забываем про методы класса Object:
        System.out.println(friday.toString());
    }
}

enum DayOfWeek {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}

```
```

Результат
FRIDAY

FRIDAY

FRIDAY
```
Когда мы передаём в `println(Object x)` имя переменной, 
автоматически вызывается метод `toString()` и выводит 
в консоль необходимое нам значение. 
На первый взгляд может показаться, что методы `name()` и `toString() `
дают одинаковый результат, но это не так.

Разница вот в чём:
- метод `name()` объявлен с модификатором `final` — его нельзя переопределять,
но можно уверенно использовать для получения оригинального имени
элемента перечисления;
- а метод `toString()` может быть переопределён — 
с его помощью можно вернуть адаптированное и более понятное 
для пользователя имя константы.

Например, в платёжной системе Visa есть несколько типов карт. 
Их названия универсальны для всех стран и могут храниться 
в коде как константы перечисления. 
Но для пользовательского вывода их лучше преобразовать и изменить регистр букв.

```java
public class Practicum {

    public static void main(String[] args) {
        for (VisaType type : VisaType.values()) {
            System.out.println("Константа: " + type.name() 
                + ", имя для вывода: " + type.toString());
        }
    }
}

enum VisaType {
    CLASSIC,
    GOLD,
    PLATINUM,
    SIGNATURE,
    INFINITE;

    @Override
    public String toString() {
        return name().charAt(0) + name().substring(1).toLowerCase();
    }
}

```

```
Результат
Константа: CLASSIC, имя для вывода: Classic

Константа: GOLD, имя для вывода: Gold

Константа: PLATINUM, имя для вывода: Platinum

Константа: SIGNATURE, имя для вывода: Signature

Константа: INFINITE, имя для вывода: Infinite
```


Обратите внимание, что если рядом с набором констант есть метод, 
то после последнего элемента перечисления нужно поставить символ `;`.

### Перечисления и оператор `switch`

Обычно каждый элемент перечисления требует особой обработки.
Удобнее всего делать это с помощью оператора выбора `switch`.

Предположим, вы сделали информационный сайт про раздельный сбор мусора. 
Потом выпустили приложение. И теперь хотите добавить на главную страницу 
кнопку со ссылкой для загрузки приложения. 
Ссылок при этом будет несколько, и они должны меняться, 
«переключаться» — в зависимости от типа устройства, 
с которого посетитель зашёл на сайт. 
Вот как может выглядеть реализация этой задачи:

```java
public class Practicum {

    public static void main(String[] args) {
        System.out.println(getDownloadLink(DeviceType.IOS));
    }

    public static String getDownloadLink(DeviceType type) {
        String link = null;

        switch (type) {
            case ANDROID:
                link = "https://play.google.com/store/apps/раздельный_сбор_мусора";
                break;
            case IOS:
                link = "https://apps.apple.com/ru/app/раздельный_сбор_мусора";
                break;
            default:
                link = "https://сайт_про_раздельный_сбор_мусора.ru";
                break;
        }

        return link;
    }
}

enum DeviceType {
    ANDROID,
    IOS,
    WEB
}
```

```
Результат
https://apps.apple.com/ru/app/раздельный_сбор_мусора

```

В этом примере всего три элемента перечисления. 
Их можно было бы обработать и через обычную конструкцию `if-else`.
Но в случаях, когда в перечислениях находятся десятки или даже сотни значений, 
оператор `switch` незаменим. Он делает код более понятным и читаемым.

</details>

<details>
<summary>Задание 4
</summary>

Перед вами метод getPopulationPercent. Он принимает на вход название континента и возвращает процент живущих на нём людей от общего числа населения планеты.
Перепишите код так, чтобы в нём использовался оператор switch

```java
class PopulationInformer {

    public static String getPopulationPercent(Continent continent) {
        String result;

        if (continent == Continent.ASIA) {
            result = "59.5%";
        } else if (continent == Continent.AFRICA) {
            result = "16.9%";
        } else if (continent == Continent.NORTH_AMERICA) {
            result = "7.7%";
        } else if (continent == Continent.SOUTH_AMERICA) {
            result = "5.6%";
        } else if (continent == Continent.ANTARCTICA) {
            result = "<0.1%";
        } else if (continent == Continent.EUROPE) {
            result = "9.7%";
        } else if (continent == Continent.AUSTRALIA) {
            result = "0.5%";
        } else {
            result = "Такого материка не существует.";
        }
     
        return result;
    }
}

enum Continent {
    ASIA,
    AFRICA,
    NORTH_AMERICA,
    SOUTH_AMERICA,
    ANTARCTICA,
    EUROPE,
    AUSTRALIA
}


public class Practicum {
    public static void main(String[] args) {
        PopulationInformer populatioInformer = new PopulationInformer();
        System.out.println(populatioInformer.getPopulationPercent(Continent.ASIA));
        System.out.println(populatioInformer.getPopulationPercent(Continent.AFRICA));
        System.out.println(populatioInformer.getPopulationPercent(Continent.NORTH_AMERICA));
        System.out.println(populatioInformer.getPopulationPercent(Continent.SOUTH_AMERICA));
        System.out.println(populatioInformer.getPopulationPercent(Continent.ANTARCTICA));
        System.out.println(populatioInformer.getPopulationPercent(Continent.AUSTRALIA));
    }
}

```

### Подсказки
* Условие для оператора `switch` — переменная `continent`.
* Не забывайте правильно расставлять двоеточия 
и скобки внутри блока оператора `switch`

</details>




<details>
<summary>Задание 5
</summary>
Компания «Собираем и перерабатываем» занимается переработкой вторсырья. 
Она планирует провести акцию: за каждый собранный килограмм вторсырья 
будут начисляться бонусы. 1 бонус = 1 рубль. 
Их можно потратить в магазинах партнёров.
Для привлечения внимания к акции, компания решила создать чат-бот, 
в котором можно будет:
* посмотреть карту с пунктами приёма вторсырья,
* проверить по коду на упаковке, подходит ли материал для переработки,
* также рассчитать количество бонусных баллов.
Ваша задача — создать этот чат-бот.


```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

public class Practicum {
    // объявите поле для ссылки на карту (англ. map link)
    ... = "https://recyclemap.ru/";
    public static final ArrayList<RecyclableMaterial> materials = getMaterials();
    public static final HashMap<MaterialType, String> containers = getContainers();

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        printMenu();

        String commandValue = scanner.nextLine();
        /* в зависимости от команды выполните следующие действия:
           map - вывести на экран ссылку на карту;
           recyclability - 1. напечатать сообщение "Введите код переработки:",
                           2. добавить ввод кода (целое число),
                           3. вызвать метод isRecycled;
           bonus - 1. напечатать сообщение "Введите количество вторсырья, кг:",
                   2. добавить ввод значения,
                   3. рассчитать бонус, умножив вес на коэффициент:
                       если вес меньше 10 кг, то коэффициент 10, иначе - 15,
                   4. вывести сообщение "Количество бонусных баллов: <баллы>."
        */

    }

    // добавьте модификаторы в заголовок метода
    ...  void isRecycled(int code) {
        for (RecyclableMaterial material : materials) {
            if (material.getCode() == code) {
                System.out.print("Это " + material.getDescription() + ". ");
                if (material.isRecyclable()) {
                    System.out.println("Положите его в контейнер с типом «" + containers.get(material.getType()) + "».");
                } else {
                    System.out.println("Он не подходит для вторичной переработки.");
                }
                return;
            }
        }
        System.out.println("Материал с таким кодом не найден.");
    }

    // добавьте модификаторы в заголовок метода
    ... HashMap<MaterialType, String> getContainers() {
        HashMap<MaterialType, String> containers = new HashMap<>();
        containers.put(MaterialType.PLASTIC, "Пластик");
        containers.put(MaterialType.METAL, "Металл");
        containers.put(MaterialType.GLASS, "Стекло");
        containers.put(MaterialType.PAPER, "Бумага");
        containers.put(MaterialType.UNSORTED_WASTE, "Общий мусор");

        return containers;
    }

    public static void printMenu() {
        System.out.println("Введите одну из команд: ");
        System.out.println(ChatCommand.MAP + " - посмотреть карту с пунктами приёма вторсырья.");
        System.out.println(ChatCommand.RECYCLABILITY + " - проверить по коду на упаковке, подходит ли материал для переработки.");
        System.out.println(ChatCommand.BONUS + " - рассчитать количество бонусных баллов.");
    }

    public static ArrayList<RecyclableMaterial> getMaterials() {
        ArrayList<RecyclableMaterial> materials = new ArrayList<>();

        materials.add(new RecyclableMaterial(1, MaterialType.PLASTIC, true, "полиэтилентерфталат"));
        materials.add(new RecyclableMaterial(2, MaterialType.PLASTIC, true, "полиэтилен высокой плотности"));
        materials.add(new RecyclableMaterial(3, MaterialType.PLASTIC, false, "поливинилхлорид"));
        materials.add(new RecyclableMaterial(4, MaterialType.PLASTIC, true, "полиэтилен низкой плотности"));
        materials.add(new RecyclableMaterial(5, MaterialType.PLASTIC, true, "полипропилен"));
        materials.add(new RecyclableMaterial(6, MaterialType.PLASTIC, false, "полистирол"));
        materials.add(new RecyclableMaterial(7, MaterialType.PLASTIC, false, "другие виды пластика"));
        materials.add(new RecyclableMaterial(20, MaterialType.PAPER, true, "гофрированный картон"));
        materials.add(new RecyclableMaterial(21, MaterialType.PAPER, true, "прочий картон"));
        materials.add(new RecyclableMaterial(22, MaterialType.PAPER, true, "бумага"));
        materials.add(new RecyclableMaterial(
                23, MaterialType.PAPER, false, "полиграфический картон (открытки, обложки книг и т.д.)"));
        materials.add(new RecyclableMaterial(40, MaterialType.METAL, true, "железо"));
        materials.add(new RecyclableMaterial(41, MaterialType.METAL, true, "алюминий"));
        materials.add(new RecyclableMaterial(70, MaterialType.GLASS, true, "бесцветное стекло"));
        materials.add(new RecyclableMaterial(71, MaterialType.GLASS, true, "зеленое стекло"));
        materials.add(new RecyclableMaterial(72, MaterialType.GLASS, true, "коричневое стекло"));
        materials.add(new RecyclableMaterial(73, MaterialType.GLASS, true, "бутылочное стекло (тёмно-коричневое)"));
        materials.add(new RecyclableMaterial(74, MaterialType.GLASS, true, "бутылочное стекло (светло-коричневое)"));
        materials.add(new RecyclableMaterial(75, MaterialType.GLASS, false, "стекло с малым содержанием свинца"));
        materials.add(new RecyclableMaterial(76, MaterialType.GLASS, false, "хрусталь"));
        materials.add(new RecyclableMaterial(
                77, MaterialType.GLASS, false, "стекло, покрытое медью (электроника, часы)"));
        materials.add(new RecyclableMaterial(
                78, MaterialType.GLASS, false, "стекло, покрытое серебром (зеркало, посуда для сервировки)"));
        materials.add(new RecyclableMaterial(
                79, MaterialType.GLASS, false, "позолоченное стекло (посуда для сервировки)"));

        return materials;
    }
}

```
```java
public class RecyclableMaterial {

    // объявите переменные с правильными модификаторами

    RecyclableMaterial(int code, MaterialType type, boolean isRecyclable, String description) {
        this.code = code;
        this.type = type;
        this.isRecyclable = isRecyclable;
        this.description = description;
    }

    public int getCode() {
        return code;
    }

    public MaterialType getType() {
        return type;
    }

    public boolean isRecyclable() {
        return isRecyclable;
    }

    public String getDescription() {
        return description;
    }
}

```

```java
// создайте перечисление MaterialType со следующими значениями:
//    PLASTIC,
//    METAL,
//    GLASS,
//    PAPER,
//    UNSORTED_WASTE
```

```java
// создайте перечисление ChatCommand со следующими значениями:
//    MAP,
//    RECYCLABILITY,
//    BONUS
```

### Подсказки
* Ссылку на карту нужно хранить как константу `public static final String MAP_LINK = "https://recyclemap.ru/"`.
* Чтобы перевести введённую команду в тип `ChatCommand`, используйте метод `ChatCommand.valueOf(commandValue)`.
* Для описания действий команды используйте оператор `switch`.
* Метод `isRecycled` должен быть `static`, чтобы его можно было вызвать из другого статического метода.
* Все переменные в классе `RecyclableMaterial` — финальные и приватные.

</details>

Предыдущее занятие | &nbsp; | Следующее занятие
:----------------:|:----------:|:----------------:
[Урок 7](Lesson7.md) | [Содержание](readme.md) | [Урок 9](Lesson9.md)