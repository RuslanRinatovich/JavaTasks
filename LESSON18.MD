   Предыдущее занятие   |         &nbsp;          |   Следующее занятие    
:----------------------:|:-----------------------:|:----------------------:
 [Урок 17](LESSON17.MD) | [Содержание](README.MD) | [Урок 19](LESSON19.MD) 

# Урок 18. Исключения

# Требования к сдаче работы

Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.

***Критерии оценивания***

* Оценка 5 - надо сделать все задания.
* Оценка 4 - надо сделать любые пять заданий.
* Оценка 3 - надо сделать любые четыре задания.

## Введение в тему

Исключения — это способ Java сообщить разработчику и программе,
что что-то пошло не так во время выполнения кода.

В этой теме научим вас не бояться исключений: разберём, из-за чего они происходят,
как их обрабатывать и избегать. А ещё:

* какие исключения бывают и что такое «иерархия исключений»;
* как научить ваш код правильно реагировать на ошибки;
* как предотвратить сбои в программе из-за непредвиденных проблем;
* как гарантировать, что определённые действия всё равно будут выполнены — даже если что-то пошло не так;
* как создавать собственные исключения, чтобы ещё эффективнее управлять программой и возможными ошибками.

В качестве практики вы потренируетесь отлавливать исключения.
Это подготовит вас к нештатным ситуациям, с которыми вы можете столкнуться
в профессиональной разработке.

<details>

<summary>Иерархия исключений</summary>

## Иерархия исключений

В ходе работы программ постоянно происходят сбои: в метод передано значение неподходящего типа,
произошёл выход за границы массива, закончилась память на компьютере или возникли неполадки
у провайдера при передаче данных.
Эти и другие ошибки и нештатные ситуации в программировании называют **исключениями** (англ. _exception_).

### Наследники Throwable

Исключения — это те ошибки и сбои, которые возникают, когда программа уже запустилась,
начала работать, но вдруг что-то пошло не так.
В стандартной библиотеке Java описано множество исключений.
Кроме того, разработчики могут создавать их сами.

Все исключения наследуют от одного класса — `Throwable` (англ. «выбрасываемый»).
Только экземпляры `Throwable` или его подклассов могут быть использованы
для генерации исключений. Кроме того, класс `Throwable` содержит все основные методы
для получения информации о произошедшей ошибке.

От `Throwable` наследуют две больших группы классов.
Вершина первой — подкласс `Exception`(англ. «исключение»), а второй `Error` (англ. «ошибка»).

![img.png](img.png)

Группа `Exception` охватывает основную часть исключений. В неё входят ошибки при работе
с файлами и сетью, сбои взаимодействия с базами данных и другие.
Кроме того, от `Exception` идёт ветвь исключений с особым поведением — `RuntimeException`
(от англ. _runtime_ — «выполнение, исполнение»). К ним относятся выход за пределы массива
или неверно переданные данные в метод, ошибки при арифметических операциях
(например, деление на ноль) и обращения к неинициализированным объектам.

Группа `Error` — это классы, описывающие критические ошибки, которые в большинстве случаев
создают аварийную ситуацию и требуют перезапуска программы. Именно в результате исключений
`Error` пользователь сталкивается с сообщением типа «Извините, произошла непредвиденная ошибка!!!».
Это могут быть сбои из-за нехватки памяти —
`OutOfMemoryError` (от англ. _out of memory_ — «за пределами памяти») или проблемы
с JVM — `VirtualMachineError`.

### Проверяемые и непроверяемые

Все исключения делятся на два типа: **проверяемые** (англ. _checked_) и **непроверяемые** (англ. _unchecked_).

**Проверяемые исключения** — это исключения, обработка которых обязательна и
является частью логики приложения. К примеру, программист может предусмотреть,
что вместо числа будет передана строка, и настроить повторный запрос данных для такого случая.
Или же пользователь введёт некорректный адрес интернет-ресурса и система не может его распознать.

> К проверяемым относятся исключения, наследуемые напрямую от `Throwable`,
> а также исключения класса `Exception` и его наследников,
> кроме ветви `RuntimeException`.
> Исключения `RuntimeException` ведут себя по-другому и относятся к непроверяемым.

Таким образом, проверяемые исключения — это те, **которые ожидаемо могут случиться**:
программист эту вероятность должен учесть и написать код, который их обрабатывает.
Если не настроить обработку проверяемых исключений, то программа не скомпилируется.

```java
public class Practicum {
    public static void main(String[] args) {
        parseUrl("httpasdas");
    }

    public static java.net.URL parseUrl(final String input) {

        /* Код не скомпилируется, потому что конструктор класса генерирует 
        проверяемое исключение MalformedURLException. */

        return new java.net.URL(input);
    }
}
```

![img_1.png](img_1.png)

Сообщение об ошибке будет примерно таким — `java: unreported exception
java.net.MalformedURLException; must be caught or declared to be thrown.`
Компилятор сообщает, что исключение `MalformedURLException`
должно быть «отловлено или объявлено выброшенным».

> К непроверяемым исключениям относятся те ошибки и нештатные ситуации,
> которые не были предусмотрены логикой
> программы и их обработка необязательна. Это исключения `Error` и ветвь `RuntimeException`.

В большинстве случаев при непроверяемых исключениях работа программы немедленно прекращается.
Например, разработчик так написал код, что программа начала бесконечно вызывать какой-то метод и переполнила стек
вызовов. Или забыл
создать объект, но попытался вывести его состояние на экран — в итоге ошибка заблокирует
работу приложения.

Поскольку разработчики заранее не обрабатывают непроверяемые исключения, если программа их выбросит, то пользователь
может увидеть какое-то странное сообщение.
Код с непроверяемым исключением успешно скомпилируется, но при выполнении упадёт с ошибкой:

```java
public class Practicum {
    public static void main(String[] args) {
        print(null);
    }

    private static void print(final Object object) {
        // Код скомпилируется, но непроверяемое исключение NullPointerException нарушит его работу.
        System.out.println(object.toString());
    }
}
```

К слову, `NullPointerException` — это, наверное, наиболее часто встречающееся исключение.
`NullPointerException` вездесуще и обязательно настигнет вас.

Определить, к какому из типов относится то или иное исключение, можно либо по иерархии классов,
либо по их поведению в коде. Главное запомнить, что проверяемые обязательны к обработке,
а непроверяемые
можно как обрабатывать за счёт добавления новой логики,
так и нет — решать проблемы по мере поступления.

### Самые распространённые исключения в Java

Типов исключений очень много.

![img_2.png](img_2.png)

#### Непроверяемые исключения, которые наследуют от Error.

| Название            | Описание                                                                                                                          |
|---------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| VirtualMachineError | Базовые ошибки JVM, связанные с тем, что исчерпаны ресурсы или обнаружены повреждения.                                            |
| OutOfMemoryError	   | Производный класс от VirtualMachineError, который показывает ошибки из-за нехватки памяти.                                        |
| StackOverflowError  | Производный класс от VirtualMachineError, показывает переполнение стека из-за того, что метод слишком много раз вызывал сам себя. |
| AssertionError      | Ошибка утверждения.                                                                                                               |
| IOError             | Исключение, которое происходит при серьёзных ошибках ввода-вывода.                                                                |
| ThreadDeath         | Возникает при вызове метода Thread.stop() у потока.                                                                               |

#### Проверяемые исключения, которые наследуют от Exception.

| Название              | Описание                                                                                                                                         |
|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| IOException           | Это базовый класс проверяемых исключений ввода-вывода.                                                                                           | 
| EOFException          | Исключение, которое сигнализирует о внезапном достижении конца файла или потока.                                                                 | 
| FileNotFoundException | Файл по указанному пути не существует.                                                                                                           | 
| FileSystemException   | Базовый класс для исключений файловой системы, таких как ошибка доступа, попытка создать уже существующий файл или удалить не пустую директорию. | 
| MalformedURLException | Неверный синтаксис при создании класса ссылки из строки.                                                                                         | 
| SocketException       | Ошибки при создании/обрыве соединения по сокету.                                                                                                 | 
| UnknownHostException	 | Невозможность определить IP-адрес узла по доменному имени.                                                                                       | 
| SQLException          | Ошибки при работе с базой данных.                                                                                                                | 
| TimeoutException	     | Исключение — происходит у методов, у которых ограничено выполнение по времени.                                                                   | 
| URISyntaxException    | Неверный формат универсального идентификатора ресурсов.                                                                                          | 

#### Непроверяемые исключения, которые унаследованы от RuntimeException.

| Название                      | Описание                                                                                    |
|-------------------------------|---------------------------------------------------------------------------------------------|
| ArithmeticException           | Исключения при арифметических операциях, например деление на 0.                             |
| IllegalArgumentException      | Возникает при неверно переданных в метод или конструктор параметрах.                        |
| IndexOutOfBoundsException     | Исключение при выходе за заданный диапазон.                                                 |
| NoSuchElementException        | Данного элемента больше не существует в перечислении.                                       |
| NullPointerException          | Приложение пытается использовать null в том месте, где требуется инициализированный объект. |
| UnsupportedOperationException | Операция не поддерживается вызываемым объектом.                                             |
| ClassCastException            | Невозможность привести объект к заданному типу.                                             |


</details>

<details>

<summary>Анатомия стек-трейса</summary>

## Анатомия стек-трейса

Если в программе не настроена обработка исключений, то в результате сбоя в терминале появится 
длинное сообщение об ошибке. В нём содержится ключевая информация, что за исключение произошло, 
где и почему. Такое сообщение называется **stack trace** (англ. «след стека») — или **стек-трейс**. 
В этом уроке расскажем, из чего состоят стек-трейсы и как их читать. 

![img_3.png](img_3.png)

Что такое стек

**Стек** — это структура данных, которая реализована по принципу **_lаst in, first out**_ 
(англ. «последний зашёл, первый вышел») или сокращённо **LIFO**. Это означает, что элемент, 
который добавлен в стек последним, будет взят первым. 

Посмотрим на примере. Представьте, посетители читального зала перед уходом должны вернуть взятую книгу 
— положить на стол библиотекарю. В итоге образуется стопка книг. 
Выше всего в этой стопке будет лежать книга того, кто ушёл последним, и именно её библиотекарь
первой поставит на место. 
А вот книга, сданная первой, наоборот, вернётся на свою полку последней. Именно так работает стек. 

![img_4.png](img_4.png)

### Внутри стек-трейса

Последовательность действий при выполнении программы обрабатывается внутри 
JVM как раз в виде стека. Каждый вызов метода при выполнении программы записывается 
как элемент класса `StackTraceElement`. Когда выполнение метода завершается, информация о нём удаляется из стека.

Если исключение прерывает работу программы, то один или несколько методов  
не могут завершиться и информация о них остаётся в памяти JVM в виде массива `StackTraceElement[]`. 
Перед тем как завершить программу, JVM печатает содержимое этого массива. 
Посмотрим, как это происходит на примере. Запустите такой код.

```java
public class Practicum {
    public static void main(String[] args) { // вызов main
        calculate1(); // вызов calculate1() 
    }

    public static void calculate1() {
        calculate2();  // вызов calculate2()
    }

    public static void calculate2() {
        calculate3(); // вызов calculate3()
    }

    public static void calculate3() {
        calculate4(); // вызов calculate4()
    }

    public static void calculate4() {
        System.out.println(10 / 0); // исключение - методы не могут завершить работу
    }
}
```

Из-за деления на ноль в методе `calculate4()` произошло исключение. В терминале мы видим его стек-трейс.

```java
Exception in thread "main" java.lang.ArithmeticException: / by zero
    at Practicum.calculate4(Practicum.java:19)
    at Practicum.calculate3(Practicum.java:15)
    at Practicum.calculate2(Practicum.java:11)
    at Practicum.calculate1(Practicum.java:7)
    at Practicum.main(Practicum.java:3) 
```

В первой строке стек-трейса сообщается базовая информация. 
О том, что исключение произошло в главном потоке — `Exception in thread "main"`, 
его тип `ArithmeticException` и описание / `by zero` — «деление на ноль». 

Затем в обратном порядке (так как мы имеем дело со стеком) идёт история вызовов методов — первым будет идти метод, 
где завершилось выполнение программы. При этом указывается класс каждого метода, его файл и местоположение в нём.

В нашем примере, перед тем, как произошла ошибка, был вызван метод `calculate4()` в классе `Practicum` на строке 
19 в файле `Practicum.java`, перед ним `calculate3()` в классе `Practicum` на строке 
15 также в файле `Practicum.java` и так далее. Первым был запущен метод `main` — информация о нём, 
соответственно, на последней строке.

</details>


<details>

<summary>Обработка исключений</summary>

## Обработка исключений

Чтобы контролировать реакцию программы на ошибки в ходе её выполнения,
нужно настроить в коде **обработку исключений**. В этом уроке научим вас, как это сделать. 

![img_5.png](img_5.png)

### Когда нужна обработка исключений

Изучите следующий код. Сейчас он отработает без ошибок.

```java
class IntegerConverter {
    public static int convert(final String input) {
        return Integer.parseInt(input, 10);
    }
}

public class Practicum {
    public static void main(String[] args) {
        System.out.println(IntegerConverter.convert("10"));
    }
}
```

Но если передать в метод `convert(final String input)` некорректную строку — возникнет исключение.

```java
class IntegerConverter {
    public static int convert(final String input) {
        return Integer.parseInt(input, 10);
    }
}

public class Practicum {
    public static void main(String[] args) {
        System.out.println(IntegerConverter.convert("10"));
        System.out.println(IntegerConverter.convert("abc10"));
    }
}

```

В терминале появится стек-трейс: `Exception in thread "main" java.lang.NumberFormatException: 
For input string: "abc10"` — англ. «Исключение в потоке `"main"` типа `NumberFormatException` 
для входной строки: `"abc10"`». 
Ошибка произошла, так как переданная строка `"abc10"` содержит не только цифры, но и буквы.
Перед нами **непроверяемое исключение** — компилятор заранее не подскажет, 
что тут может случиться ошибка. Однако можно добавить в код его обработку. 

### Конструкция try — catch

Для обработки исключений существует специальная конструкция из ключевых слов `try` (англ. «пробовать, пытаться») 
и `catch` (англ. «ловить»). В `try` передаётся код, из-за которого может произойти исключение. 
В `catch` в качестве аргумента — тип ошибки, а в тело — код, 
который выполнится, если произойдёт исключение, указанное в `try`. В коде `try` — `catch` выглядит так:

```java
try {
    ... // код, из-за которого может произойти исключение
} catch (Throwable throwable) { // параметр - тип возможного исключения
    // код, который выполнится, если произойдёт исключение указанного типа
}
```

Обработка исключения настраивается исходя из логики программы. Например, её можно добавить в тело метода. 
В случае ошибки при этом можно настроить возврат какого-то значения по умолчанию.

```java
class IntegerConverter {
    public static int convert(final String input) {
        try {
            return Integer.parseInt(input, 10); // если исключения нет - вернётся число
        } catch (Throwable exception) { 
            return 0; // если поймано исключение - вернётся 0
        }
    }
}

public class Practicum {
    public static void main(String[] args) {
        System.out.println(IntegerConverter.convert("10"));
        System.out.println(IntegerConverter.convert("abc10"));
    }
}

```

![img_6.png](img_6.png)

Плюс такого подхода в том, что в любом случае вернётся значение, 
с которым можно работать. Минус в том, что не получится определить, 
где нулевое значение возникло в результате исключения, а где было передано в метод. 

Другой вариант — добавить обработку исключения в тот метод, 
который вызывает код, где оно может произойти. Например, в метод `main`.


```java
class IntegerConverter {
    public static int convert(final String input) { 
        return Integer.parseInt(input, 10);
    }
}

public class Practicum {
    public static void main(String[] args) { 
        try {
            System.out.println(IntegerConverter.convert("10")); // печатаем число
        } catch (Throwable exception) {
            // или выводим сообщение об ошибке
            System.out.println("Строка для преобразования не является целым числом.");
        }
        try {
            System.out.println(IntegerConverter.convert("abc10"));
        } catch (Throwable exception) {
            System.out.println("Строка для преобразования не является целым числом.");
        }
    }
}
```

Нельзя сказать, что тот или иной вариант лучше или хуже. 
Поэтому логика обработки исключений через блок `try — catch` остаётся на выбор разработчика. 

Какой код будет внутри блоков `catch` — тоже решает сам разработчик.
Можно уведомить пользователя об ошибке, попросить его подождать, 
повторить попытку или выйти. Чаще всего с помощью `catch` принято отображать 
или сохранять информацию об ошибке. 

### Множественный catch

До этого момента мы использовали в `catch` тип параметра `Throwable`. Это позволяло нам сразу обрабатывать 
все исключения, производные от него.
То есть `catch` ловил все ошибки, которые могли бы произойти в `try`, включая ошибки `JVM`. Кажется, 
что так можно создать универсальный обработчик исключений. Однако запустим код с такой обработкой ещё раз.

```java
import java.net.URI;

public class Practicum {
    public static void main(String[] args) {
        System.out.println(parseStringToUri("https://ya.ru"));
        System.out.println(parseStringToUri(null));
        System.out.println(parseStringToUri(":/"));
    }

    public static URI parseStringToUri(final String input) {
        try {
            return new URI(input);
        } catch (Throwable exception) {
            System.out.println("Произошла ошибка!");
        }
        return null;
    }
}
```

При любом исключении мы теперь всегда видим одно и то же сообщение — `Произошла ошибка!`, 
однако ошибки при этом могут отличаться.
К примеру, в первом случае возникает исключение `NullPointerException` — строка не инициализирована, 
а во втором `URISyntaxException` — строка не может быть преобразована в идентификатор. 
Однако при использовании общей обработки с типом `Throwable` не получится узнать, что конкретно 
пошло не так и как это можно исправить.

Чтобы обрабатывать разные типы исключений, которые может сгенерировать метод или конструктор,
нужно добавить несколько блоков `catch`. Каждый из них будет отвечать за конкретное исключение 
и выдавать соответствующий ответ для него.

```java
import java.net.URI;
import java.net.URISyntaxException;

public class Practicum {
    public static void main(String[] args) {
        System.out.println(parseStringToUri("https://ya.ru"));
        System.out.println(parseStringToUri(null));
        System.out.println(parseStringToUri(":/"));
    }

    public static URI parseStringToUri(final String input) {
        try {
            return new URI(input);
        } catch (URISyntaxException exp) { // ловим исключение URISyntaxException
            System.out.println("Ошибка: неверный синтаксис URI!");
        } catch (NullPointerException exp) { // ловим исключение NullPointerException
            System.out.println("Ошибка: передан неинициализированный объект!");
        }
        return null;
    }
}
```

Теперь гораздо понятнее, где какая произошла ошибка. Это позволит быстрее исправить её. 
Если же отлавливать исключения по параметру `Throwable` 
или даже `Exception` — то придётся перебирать множество вариантов — от неправильного ввода до переполненной памяти.

--- 

Даже такая простая операция, как добавление нового элемента в хеш-таблицу может сгенерировать исключение. 
Чтобы было понятно, что пошло не так — добавим обработку конкретных исключений.
Для NullPointerException выведите текст — «Реализация не поддерживает неинициализированные объекты.».
Для UnsupportedOperationException — сообщение «Реализация не поддерживает добавление новых объектов.».

```java
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

public class Practicum {
    public static void main(String[] args) {
        System.out.println(addToMap(new HashMap<>(), "test", "test"));
        System.out.println(addToMap(new HashMap<>(), null, null));

        System.out.println(addToMap(new TreeMap<>(), "test", "test"));
        System.out.println(addToMap(new TreeMap<>(), null, null));

        System.out.println(addToMap(Map.of(), "test", "test"));
    }

    public static Map<String, Object> addToMap(final Map<String, Object> storage, 
                                               final String key, final Object value) {
        
       try {
            storage.put(key, value);
            
        } catch (NullPointerException exp) { // ловим исключение URISyntaxException
            System.out.println("Реализация не поддерживает неинициализированные объекты.");
        } catch (UnsupportedOperationException exp) { // ловим исключение NullPointerException
            System.out.println("Реализация не поддерживает добавление новых объектов.");
        }
        catch (Throwable exception) {
            return null;
        }
      return storage;
    }
}
```

### Порядок обработки исключений

При обработке исключений важно соблюдать правильную последовательность. 
Сначала обрабатываются исключения в классах-наследниках,
а только потом родительские. 

Например, исключение `ClassCastException` является дочерним от `RuntimeException`, 
который наследуется от базового Exception. В таком порядке их и нужно поместить 
в блоки catch. Код, где нарушен порядок обработки исключений, не будет скомпилирован.

```java

class Practicum {
    public static void main(String[] args) {
        System.out.println(convertToString(0));
    }

    private static String convertToString(Object x) {
        try {
            return (String) x;
        } catch (Exception e) {
            System.out.println("Произошла неизвестная ошибка");
        } catch (RuntimeException e) {
            System.out.println("Ошибка во время выполнения");
        } catch (ClassCastException e) {
            System.out.println("Некорректное приведение типов");
        }
        return null;
    }
}
```

![img_7.png](img_7.png)

д
Корректный порядок будет таким — сначала `ClassCastException`, потом — `RuntimeException`, в конце – `Exception`.

```java
class Practicum {
    public static void main(String[] args) {
        System.out.println(convertToString(0));
    }

    private static String convertToString(Object x) {
        try {
            return (String) x;
        } catch (ClassCastException e) {
            System.out.println("Некорректное приведение типов");
        } catch (RuntimeException e) {
            System.out.println("Ошибка во время выполнения");
        } catch (Exception e) {
            System.out.println("Произошла неизвестная ошибка");
        }
        return null;
    }
}

```

### Объединение исключений с одинаковым выводом

Часто требуется совместить два типа исключений, если инструкции для них являются одинаковыми. 
Сделать это можно в блоке catch с помощью символа `|`.
Например, вот такой код:

```java
import java.util.ArrayList;

public class Practicum {
    public static void main(String[] args) {
        try {
            new ArrayList<String>().add("1");
        } catch (UnsupportedOperationException exception) {
            System.out.println("Возникла ошибка, свяжитесь с нами!");
        } catch (IllegalArgumentException exception) {
            System.out.println("Возникла ошибка, свяжитесь с нами!");
        }
    }
}
```

Можно оптимизировать так:

```java
import java.util.ArrayList;

public class Practicum {
    public static void main(String[] args) {
        try {
            new ArrayList<String>().add("1");
        } catch (UnsupportedOperationException | IllegalArgumentException exception) {
            System.out.println("Возникла ошибка, свяжитесь с нами!");
        }
    }
} 
```

</details>

<details>

<summary>Задание 1</summary> 

## Задание 1

Добавьте обработку исключений при преобразовании строки в URL в метод parseStringToURI(). 
При ошибке возвращайте значение null.

```java
import java.net.URI;

public class Practicum {
    public static void main(String[] args) {
        System.out.println(parseStringToURI("https://ya.ru"));
        System.out.println(parseStringToURI("\\\\"));
        System.out.println(parseStringToURI(null));
    }

    public static URI parseStringToURI(final String input) {
        return new URI(input);
    }
}


```

### Подсказки

* Оберните код метода `parseStringToURI()` в конструкцию `try...catch`.
* В качестве типа отлавливаемого исключения укажите `Throwable`.

</details>

   Предыдущее занятие   |         &nbsp;          |   Следующее занятие    
:----------------------:|:-----------------------:|:----------------------:
 [Урок 17](LESSON17.MD) | [Содержание](README.MD) | [Урок 19](LESSON19.MD) 