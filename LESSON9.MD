Предыдущее занятие | &nbsp; | Следующее занятие
:----------------:|:----------:|:----------------:
[Урок 8](Lesson8.md) | [Содержание](readme.md) | [Урок 10](Lesson10.md)

# Урок 9. Абстракция и полиморфизм


# Требования к сдаче работы
Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.


***Критерии оценивания***
* Оценка 5 - надо сделать все три заданий.
* Оценка 4 - надо сделать любые два задания.
* Оценка 3 - надо сделать одно любое задание.

1. [Введение в тему](#введение-в-тему)
2. [Знакомимся с абстракцией](#знакомимся-с-абстракцией)
   * [Создаём абстрактный класс](#создаём-абстрактный-класс)
   * [Добавляем методы](#добавляем-методы)
     - [Обычные методы в абстрактном классе](#обычные-методы-в-абстрактном-классе)
     - [Абстрактные методы в абстрактном классе](#абстрактные-методы-в-абстрактном-классе)
   * [Создаём наследников абстрактного класса](#создаём-наследников-абстрактного-класса)
   * [Создаём объекты классов-наследников](#создаём-объекты-классов-наследников)
3. [Задание 1](#задание-1)
4. [Интерфейсы в Java](#интерфейсы-в-java)
    * [Что такое интерфейс](#что-такое-интерфейс)
    * [Объявляем и реализуем интерфейс](#объявляем-и-реализуем-интерфейс)
    * [Множественная реализация интерфейсов](#множественная-реализация-интерфейсов)
5. [Задание 2](#задание-2)
6. [Полиморфизм](#полиморфизм)
   * [Полиморфизм и интерфейсы](#полиморфизм-и-интерфейсы)
   * [Полиморфизм и наследование](#полиморфизм-и-наследование)
   * [Полиморфизм: объединяем вместе](#полиморфизм-объединяем-вместе)
7. [Виды полиморфизма](#виды-полиморфизма)
   * [Сабтайпинг. Полиморфизм подтипов](#сабтайпинг-полиморфизм-подтипов)
   * [Ad-hoc полиморфизм](#ad-hoc-полиморфизм)
8. [Задание 3](#задание-3)
9. [Полиморфизм в стандартной библиотеке Java](#полиморфизм-в-стандартной-библиотеке-java)
   * [Ad-hoc полиморфизм](#ad-hoc-полиморфизм-1)
   * [Пример переопределения метода](#пример-переопределения-метода)

<details>
<summary>Введение в тему</summary>

# Введение в тему

Вы уже знаете, что в основе объектно-ориентированного программирования (ООП) лежат четыре принципа: инкапсуляция, наследование, абстракция и полиморфизм. С первыми двумя вы познакомились в прошлом спринте. А в этой теме вы рассмотрите абстракцию и полиморфизм.

Вы научитесь создавать абстрактные классы и узнаете, как в Java решена проблема множественного наследования. Расширите свои знания о приведении типов и научитесь:

* реализовывать абстрактный класс из нескольких классов;
* реализовывать интерфейс из одного или нескольких классов;
* перегружать метод.

Ещё вы изучите, как концепция полиморфизма реализована в стандартной библиотеке Java, и поймёте разницу между автоматическим и явным приведением ссылочных типов.

Но обо всём по порядку! Начнём с абстракции.

</details>

<details>
<summary>Знакомимся с абстракцией</summary>

# Знакомимся с абстракцией

Абстракция (англ. abstraction, «отвлечение»), применительно к ООП, это принцип, при котором пользователю класса доступны только методы, описывающие основное поведение, а остальные детали скрыты внутри реализации. Одним из инструментов для достижения абстракции является инкапсуляция. Используя этот принцип, программист описывает, что делает класс, а не то как он это делает.

Например, когда вы спрашиваете у своей умной колонки «Какая завтра будет погода?», запускается примерно такая цепочка действий:

* голосовой помощник анализирует ваш вопрос;
* переводит его в машинный код, понятный компьютеру;
* отправляет запрос на сервер;
* получает данные о погоде;
* переводит их в голосовое представление;
* и наконец воспроизводит ответ.

Всё это выполняется молниеносно, совершенно незаметно для пользователя. Вам не нужно понимать, какие процессы происходят внутри колонки, чтобы взаимодействовать с ней. Достаточно знать, что она умеет отвечать на вопросы.

Таким образом, разработчики предоставили вам простой в использовании голосовой интерфейс и дали возможность **абстрагироваться** от деталей его реализации.

![img_4.png](images1-9/img_4.png)

Именно принцип абстракции в ООП позволяет программисту работать с объектами и классами, даже если он не знает, как они устроены и какие алгоритмы скрыты в их реализации.

Например, для работы с объектами класса `ArrayList` вам не обязательно знать о том, что они хранят элементы в обычном массиве и создают новый, если в старом заканчивается свободное место. Вам достаточно знать, что они умеют хранить элементы и добавлять новые.

А вот ещё один пример абстракции. Вы работали с классом `Random`, 
когда изучали цикл `while`. Чтобы сгенерировать случайное число,
нужно вызвать метод `nextInt(int bound)`. 
А вот конкретный алгоритм, реализованный внутри этого класса и 
отвечающий за генерацию, знать совсем не обязательно.

## Создаём абстрактный класс

Абстрактный класс — это базовый класс, у которого не может быть экземпляров.
На его основе создаются обычные классы, объединённые общими чертами.

В абстрактном классе могут быть различные поля и даже конструкторы,
основное отличие заключается в методах. 
Наряду с конкретными методами он может содержать и абстрактные — заготовки 
методов без реализации (без тела метода), только с их описанием. 
То есть абстрактные заготовки с информацией о том, **что** сможет делать объект. 
А реализация методов, то есть то, **как** объект будет что-то делать, 
будет находиться в классах-наследниках этого абстрактного класса.

Рассмотрим, как устроены абстрактные классы и для чего они нужны, 
на примере жаб и лягушек. И те, и другие относятся к одному классу животных — амфибиям.
И действительно, у них много общих черт:
* строение тела (четыре конечности, голова и отсутствие хвоста),
* гастрономические предпочтения (они едят насекомых),
* способ размножения (откладывают икру) и прочее.

Но есть и различия. И те, и другие умеют передвигаться по суше и дышать,
правда, делают это разными способами:

* лягушки прыгают, а жабы ходят;
* лягушки дышат лёгкими и кожей, а жабы — только лёгкими.

Допустим, нам нужно написать программу, 
в которой будет два класса — `Frog` (англ. «лягушка») и `Toad` (англ. «жаба»). 
Если у этих классов не будет общего родителя, то, 
во-первых, у нас появится много повторяющегося кода, а во-вторых, 
не будет прослеживаться их сходство.

Удобнее будет создать общий для них класс `Amphibian` (англ. «амфибия») и 
перечислить в нём названия методов, которые относятся ко всем земноводным: 
есть, размножаться, передвигаться, дышать. 
Это и будет нашей заготовкой для будущих амфибий — абстрактный класс `Amphibian`! 
А `Frog` и `Toad` станут его классами-наследниками, 
в которых пропишем конкретную реализацию методов: прыгучесть для лягушек, 
ходьбу для жаб и так далее.

![img_5.png](images1-9/img_5.png)

Пришло время объявить **абстрактный** класс. 
Для этого нужно указать специальное ключевое слово `abstract`:

```java
public abstract class Amphibian {
    
} 
```

Отлично! Получился абстрактный класс `Amphibian`, который будет описывать всех 
земноводных животных.

У абстрактных классов есть одна важная особенность: 
**у них не может быть объектов**.
В природе тоже из икры не может появиться какая-нибудь абстрактная амфибия — 
она всегда будет либо жабой, либо лягушкой (или другим конкретным представителем вида земноводных).

Создавать объекты, относящиеся к абстрактным классам, 
можно в классах-наследниках. Об этом расскажем дальше.



```java
public class Practicum {

    public static void main(String[] args) {
        Amphibian abstractAmphibian = new Amphibian();
    }
}

abstract class Amphibian {
    
}
```
```
Если же вы всё-таки попытаетесь в своей программе создать абстрактную амфибию, 
Java выдаст ошибку: “`Amphibian is abstract; cannot be instantiated`” 
(англ. «`Amphibian` — абстрактный класс; у него не может быть объектов»).

```

> 💡 В коде стандартной библиотеки Java есть много абстрактных классов. 
> Например, в классе AbstractList представлены заготовки методов, 
> которые реализованы в классе-наследнике ArrayList. 
> Коллекция LinkedList тоже наследуется от AbstractList, 
> поэтому набор её базовых методов такой же, как и у ArrayList, 
> но способ хранения данных внутри класса другой.


## Добавляем методы

Итак, вы объявили абстрактный класс `Amphibian`. 
Теперь добавим в него методы, которые в абстрактных классах могут быть двух видов:

* обычные (они пишутся с реализацией, которая будет общей для всех классов-наследников);
* и абстрактные (они указываются без реализации, потому что у каждого из классов-наследников она будет своя).

Рассмотрим каждый из них подробнее.

### Обычные методы в абстрактном классе
Если у группы разных объектов реализация какого-то действия совпадает, то её лучше написать сразу в абстрактном классе, внутри обычного метода. В таком случае не придётся дублировать один и тот же код во множестве классов.

Например, и лягушки, и жабы одинаковым образом реализуют метод `eat()` — и те, и другие с удовольствием едят насекомых. Поэтому можно сделать его общим. 
Для этого внутри абстрактного класса объявим обычный метод `eat()` и напишем его реализацию:

```java
public abstract class Amphibian {

    public void eat() { 
        System.out.println("Кушаю насекомых!");
    }
} 
```

Теперь метод `eat()` и его реализация будут общими для всех классов-наследников абстрактного класса `Amphibian`.

### Абстрактные методы в абстрактном классе

Как вы выяснили, у лягушек и жаб есть ещё и такие совпадающие 
действия — передвигаться по суше и дышать, но реализуют они их разными способами. 
Чтобы корректно отобразить это в программе, нам понадобятся **абстрактные методы**.

При объявлении абстрактного метода указывается только его 
сигнатура(_имя метода вместе с упорядоченным набором его параметров._) и 
тип возвращаемого значения, а тело не требуется.

Абстрактные методы дают информацию только о том, 
что сможет делать объект класса-наследника. Например, передвигаться по суше — `move()`. 
Информацию о том, как именно он будет это делать (прыгать или ходить),
будут содержать классы-наследники абстрактного класса `Amphibian` — `Frog` и `Toad`.

Чтобы объявить абстрактный метод, 
перед типом возвращаемого значения необходимо указать ключевое слово `abstract`. 
Тело метода при этом будет отсутствовать — вместо него ставится точка с запятой:

```java
public abstract class Amphibian {

    public void eat() { // обычный метод с реализацией
        System.out.println("Кушаю насекомых!");
    }

    public abstract void move(); // абстрактный метод без реализации
}
```

Метод `move()` будет общим для всех классов-наследников абстрактного класса `Amphibian`,
но реализовывать его они будут по-разному. Как именно — расскажем дальше.

Бывают случаи, когда разработчику нужно создать базовый класс с общей логикой. 
Тогда абстрактных методов в абстрактном классе может не быть.

Например, в математике есть фигура параллелограмм — четырёхугольник, 
у которого противоположные стороны попарно параллельны. 
Частные случаи параллелограмма — ромб, квадрат и прямоугольник.
У них есть два одинаковых свойства — высота и ширина, 
а также общий способ подсчёта площади фигуры.


![img_6.png](images1-9/img_6.png)

В коде это можно представить следующим образом:

```java
public abstract class Parallelogram { // объявление абстрактного класса
    private double height; // высота
    private double width; // ширина

    // класс будет содержать только обычный метод
    // для нахождения площади
    public double getArea() { // 
        return height * width;
    }
}
```
Абстрактный класс, в котором есть только обычные методы, 
всё равно будет абстрактным. 
А вот если в обычном классе появится хотя бы один абстрактный метод — 
нужно будет этот класс объявить абстрактным, иначе возникнет ошибка.

### Создаём наследников абстрактного класса

Абстрактный класс — это только заготовка,
которая становится конкретной и реализуется в полной мере только в классах-наследниках.

Класс-наследник должен реализовать 
все унаследованные абстрактные методы, 
иначе при компиляции программы возникнет ошибка:
“`<Class name> is not abstract and does not override abstract method <method name> in 
<abstract class name`>” (англ. «[Класс] не является абстрактным и не переопределяет метод из [абстрактного класса]»).

От абстрактного класса `Amphibian` с помощью ключевого слова `extends` объявим 
два класса-наследника — `Frog` и `Toad`. 
И опишем в них реализацию абстрактного метода `move()`. 
Для этого укажем сигнатуру метода и напишем тело метода в фигурных скобках с 
аннотацией `@Override`:

`Frog.java`
```java
public class Frog extends Amphibian {

    @Override
    public void move() {
        System.out.println("Я передвигаюсь по суше прыжками.");
    }

}
```

`Toad.java`
```java
public class Toad extends Amphibian {

    @Override
    public void move() {
        System.out.println("Я важно хожу.");
    }

}
```

> Допустим, разработчик не хочет реализовывать в классе-наследнике 
> все абстрактные методы базового класса. 
> Тогда он обязательно должен объявить класс-наследник также абстрактным.


### Создаём объекты классов-наследников

У абстрактного класса не может быть объектов. 
Зато они могут быть у его классов-наследников.
И объявляются эти объекты через конструктор конкретного класса.

Например, чтобы создать экземпляр класса `Frog`, 
необходимо вызвать его конструктор `new Frog()`:

```java
public class Practicum {

    public static void main(String[] args) {
        Frog frog = new Frog();
        System.out.println("Привет! Я - зелёная лягушка.");
        frog.move();

        Toad toad = new Toad();
        System.out.println("Привет! Я - коричневая жаба.");
        toad.move();
    }

}
```

Обратите внимание, что при создании объектов в программе будет
вызван конструктор конкретного класса `Frog` или `Toad`, а не `Amphibian`.

Абстрактный класс содержит конструктор по умолчанию, 
но вы можете определить вместо него любые конструкторы с параметрами.

Например, создадим общую переменную `color` в абстрактном классе `Amphibian` и будем передавать в неё конкретный цвет из классов-наследников:

`Amphibian.java`
```java
public abstract class Amphibian {
    private String color;

    protected Amphibian(String color) {
        this.color = color;
    }

    public abstract void move();

    public abstract String getColor();

    public void eat() {
        System.out.println("Кушаю насекомых");
    }

}
```
У абстрактного класса `Amphibian` появился конструктор с параметром! 
До этого конструкторы по умолчанию классов-наследников обращались к
конструктору родителя без параметров. Но теперь его нет, поэтому возникнет ошибка.

Чтобы её исправить, необходимо доработать классы `Frog` и `Toad`. 
Они должны вызывать конструктор абстрактного класса с параметром `color`:

`Frog.java`

```java
public class Frog extends Amphibian {

    protected Frog() {
        super("зеленая");
    }

    @Override
    public void move() {
        System.out.println("Я передвигаюсь по суше прыжками.");
    }

    @Override
    public String getColor() {
        return color;
    }
}
```
`Toad.java`
```java
public class Toad extends Amphibian {

    protected Toad() {
        super("коричневая");
    }

    @Override
    public void move() {
        System.out.println("Я важно хожу.");
    }

    @Override
    public String getColor() {
        return color;
    }
}
```

Теперь, когда вы создаёте объекты классов `Frog` и `Toad`, 
вам не нужно указывать, зелёные они или коричневые.
Цвет находится внутри этих классов и одинаков для всех их объектов.

> Если у большинства классов-наследников 
> реализация какого-нибудь метода совпадает 
> — её можно перенести в абстрактный класс, чтобы избежать дублирования. 

Но при этом метод будет возвращать разное значение для разных классов: 
это будет зависеть от значения переменной color, переданной в конструктор.

Например, реализация метода `getColor()` у классов `Frog` и `Toad` получилась одинаковой.
Вынесем её в базовый класс `Amphibian`:

`Practicum.java`

```java
public class Practicum {

    public static void main(String[] args) {
        Frog frog = new Frog();
        System.out.println("Привет! Я - " + frog.getColor() + " лягушка.");
        frog.move();

        Toad toad = new Toad();
        System.out.println("Привет! Я - " + toad.getColor() + " жаба.");
        toad.move();
    }

}
```

`Amphibian.java`

```java
public abstract class Amphibian {
    protected String color;

    protected Amphibian(String color) {
        this.color = color;
    }

    public abstract void move();

    public String getColor() {
        return color;
    }

    public void eat() {
        System.out.println("Кушаю насекомых");
    }

}
```

`Frog.java`
```java
public class Frog extends Amphibian {

    protected Frog() {
        super("зеленая");
    }

    @Override
    public void move() {
        System.out.println("Я передвигаюсь по суше прыжками.");
    }

}
```
`Toad.java`
```java
public class Toad extends Amphibian {

    protected Toad() {
        super("коричневая");
    }

    @Override
    public void move() {
        System.out.println("Я важно хожу.");
    }

}
```
> Теперь классы-наследники могут использовать реализацию метода из родительского класса либо переопределить её.
</details>

<details>
<summary>Задание 1 </summary>

# Задание 1

В уроке вы столкнулись с задачей выбора методов будущего абстрактного класса. 
Такие решения лучше принимать до написания программы. 
Этот этап — проектирование будущего решения, отличает дилетантов от профессионалов. 
Теперь, опираясь на результаты этапа проектирования, 
вы можете реализовать свою иерархию классов для питомцев.

У любого домашнего питомца `Pet` есть несколько действий:

* спать `sleep()` (при вызове этого метода ваша программа должна выводить слово Сплю),
* играть `play()` (программа должна вывести Играю)
* издавать какой-то звук `giveVoice()`

а также свойство — количество лапок `pawsCount`.   

Дополнительно к базовым возможностям, 
кошка может поймать мышку `catchMouse()` (в этом случае выведите `Поймала мышку!`), 
хомяк — спрятать еду `hideFood()` (`Вся еда — в щёчках!`), 
а собака — принести палку `bringStick()` (`Принёс палочку, как хороший мальчик!`).

`Practicum.java`
```java
public class Practicum {

    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.catchMouse();
        cat.giveVoice();

        Dog dog = new Dog();
        dog.bringStick();
        dog.play();

        Hamster hamster = new Hamster();
        hamster.hideFood();
        hamster.sleep();

        Fish fish = new Fish();
        fish.sleep();

        Spider spider = new Spider();
        System.out.println("У паука " + spider.getPawsCount() + " лапок.");
    }

}
```

`Pet.java`
```java
public class Pet {
}
```

`Fish.java`
```java
public class Fish {
}
```

`Spider.java`
```java
public class Spider {
}
```
`Dog.java`
```java
public class Dog {
}
```

`Cat.java`
```java
public class Cat {
}
```

`Hamster.java`
```java
public class Hamster {
}
```

# Подсказки

* Чтобы объявить абстрактный класс, используйте ключевое слово `abstract`
перед объявлением класса — `public abstract class Pet`.
* Чтобы указать, что классы наследуется от абстрактного, 
используйте ключевое слово `extends` и название абстрактного класса — 
`public class Cat extends Pet`.
* Реализации методов `sleep()`, `play()` 
у всех питомцев совпадают — эти методы можно вынести в абстрактный класс
в виде обычных, не абстрактных методов.

* Во всех классах есть метод с одинаковой сигнатурой `giveVoice()`,
но значение, которое возвращает метод, отличается. 
Это можно выразить с помощью добавления в класс `Pet` 
конструктора с параметром `Pet(String voice)` и перенести метод в абстрактный класс.

* Ключевое слово `super` позволяет вызвать метод или конструктор суперкласса, 
а также обратиться к его полям. (Вызов конструктора класса-родителя через `super`
должен быть первой строкой в конструкторе класса-наследника.)

* Геттеры и сеттеры нужны для работы с полями класса, закрытыми модификатором private.

</details>


<details>
<summary>Интерфейсы в Java</summary>

# Интерфейсы в Java

Механизм наследования в Java очень удобен, но у него есть важное ограничение 
— **наследоваться можно только от одного класса**. 
Этот запрет поставлен для того, чтобы предотвратить ситуацию конфликтного наследования,
которая называется **проблемой ромба, или алмаза** (англ. _diamond problem_) и может возникать в языках с множественным наследованием.

> Встречается и более устрашающее название: убийственный ромб (алмаз) смерти (англ. deadly diamond of death).

Предположим, у нас есть абстрактный класс `Animal` (англ. «животное») с
абстрактным методом `eat()` (англ. «есть»). От класса `Animal` наследуются класс `Pet` 
(англ. «домашнее животное») и класс `Mammal` (англ. «млекопитающее»).

В каждом из них метод `eat()` реализован по-своему:
* «Кушаю еду, которую даёт мне хозяин!» — в классе `Pet`;
* «Кушаю еду, которую раздобуду сам!» — в классе `Mammal`.

Кроме этого, и у `Pet`, и у `Mammal` есть уникальные методы:

* `playWithToy()` (англ. «играть с игрушкой»), актуальный для домашних питомцев,
* `feedWithMilk()` (англ. «кормить потомство молоком»), характерный для млекопитающих.

А теперь представьте, что нам нужно создать ещё один класс — `Cat` (англ. «кошка»).
Он должен описывать кошку, которая является и млекопитающим, 
и домашним животным. 

В языке с множественным наследованием было бы удобно унаследовать класс `Cat` и от `Pet`,
и от `Mammal`, потому что кошка совмещает в себе 
уникальные методы и домашних питомцев, и млекопитающих.

Но и у `Pet`, и у `Mammal` есть общий метод `eat()` — с разными реализациями. 
Какую же из них в таком случае должен использовать класс `Cat` при вызове метода `eat()` 
у своего объекта?

![img_7.png](images1-9/img_7.png)

Это и есть проблема ромба. Из-за неё программа бы не смогла выполнить метод `eat()`
и завершила бы работу с ошибкой. Или ещё хуже: выполнила бы не ту реализацию, 
на которую рассчитывал разработчик.
Именно поэтому в `Java` и запрещено множественное наследование: 
ещё на стадии компиляции будет выдана ошибка.

И всё же в некоторых случаях сложная иерархия необходима. 
Например, чтобы обозначить, что кошка — это и млекопитающее,
и домашний питомец. Для этого используют **интерфейсы**. Рассмотрим подробнее, что это такое.


## Что такое интерфейс

Чтобы, с одной стороны, обойти ограничение множественного наследования,
а с другой — решить проблему ромба, в Java добавили **интерфейсы** (англ. interface — «взаимодействие»).

В обычной жизни вы не раз сталкивались с интерфейсами. 
Например, у любого автомобиля есть педаль газа, педаль тормоза и руль — это интерфейс, 
с помощью которого водитель взаимодействует с машиной. 
Интерфейс описывает общую концепцию функциональности (автомобиль умеет набирать и 
снижать скорость, менять направление движения), 
а её конкретная реализация (форма педалей, дизайн руля) зависит от производителя.

В программировании **интерфейс** (англ. _interface_)— это набор сигнатур методов, 
которые описывают функциональность объектов относящихся к интерфейсу, 
но не реализуют её. 
Интерфейс может быть имплементирован, или реализован (от англ. _implement_ — «реализовывать»), 
его классах-реализациях, которые наполняют методы конкретным поведением. 
Можно воспринимать интерфейс как контракт: класс, который реализует интерфейс,
обязуется выполнять методы, описанные в нём.

На основе интерфейса нельзя создавать объект: у него нет конструктора по умолчанию 
и в него нельзя добавить конструкторы с параметрами.

В чём-то интерфейсы похожи на абстрактные классы, но всё же между ними есть различия. И самое главное — концептуальное:
* Абстрактные классы нужны для того, чтобы у всех классов-наследников создавать 
и поддерживать общую _структуру_. 
Они как бы говорят: «Все мои наследники будут похожи на меня: и свойствами, и методами!».

* Интерфейсы нужны для обозначения, что класс-реализация обладает 
определённой функциональностью. Их девиз мог бы быть таким: «Объекты класса, 
который имплементирует меня, умеют делать кое-что определённое!».

![img_8.png](images1-9/img_8.png)

Представим, что нам нужно написать приложение для орнитологов-любителей.
Первым делом создадим абстрактный класс `Bird`, который описывает птиц. 
А дальше нужно решить: если мы прямо внутри него создадим абстрактный метод `fly()`, 
то что делать с пингвинами, страусами и другими птицами, которые не летают?

Можно, конечно, вместо одного создать два абстрактных класса:
для летающих и для нелетающих птиц. Они будут различаться всего лишь одним параметром,
а в остальном — дублировать друг друга. Это явно не лучшее решение.

Правильнее будет функциональность полёта вынести в интерфейс 
`Flyable` (от англ. «способный летать») с относящимися к нему методами взлёта, 
посадки и так далее. Все классы-наследники абстрактного класса `Bird`, 
описывающие летающих птиц, будут реализовывать этот интерфейс.

![img_9.png](images1-9/img_9.png)

Интерфейс лишь указывает, что класс, реализующий его, обладает функциональностью, 
которая описана в этом интерфейсе. В нашем примере это — способность летать.

При этом один и тот же интерфейс может реализовывать множество разных, 
ни чём больше не связанных друг с другом классов. 
И в то же время один и тот же класс может реализовывать множество разных интерфейсов. 
Таким образом, при необходимости можно применить этот же интерфейс `Flyable` не только к птицам, 
но и к летучим мышам, самолётам, летающим белкам или воздушным змеям!

## Объявляем и реализуем интерфейс

Предположим, у нас есть готовое приложение-календарь, которое реализовано в классе `CalendarApp`. 
И мы хотим добавить в него новую функцию — возможность создавать, редактировать и 
удалять заметки. Для решения этой задачи удобнее всего будет создать отдельный интерфейс
с нужным нам функционалом. Назовём его `NoteBook`.

> 💡 В Java названия интерфейсов как правило являются прилагательными и заканчиваются 
> на суффикс -able (например, Serializable, Clonable или Iterable).
> Но иногда разработчики отступают от этого правила даже в коде 
> стандартной библиотеки — например, когда интерфейс представляет 
> собой семейство классов. В этом случае интерфейсы называют именами существительными 
> (например, List и Map).


Объявление интерфейса похоже на объявление класса, только вместо `class` 
используется ключевое слово `interface`. 
Внутри указываются методы без реализации: все методы интерфейса являются абстрактными 
по умолчанию. Мы пока добавим только один из них:

```java
public interface NoteBook { // Объявление интерфейса
    void addNote(String note); // Сигнатура метода добавления заметки
}

```

Модификаторы доступа писать не нужно — все методы интерфейса по умолчанию являются публичными.

Итак, объявили интерфейс `NoteBook`. Теперь имплементируем его в классе `CalendarApp`.
Чтобы класс реализовывал интерфейс, необходимо после названия класса указать ключевое
слово `implements` и имя интерфейса, 
а над реализацией метода интерфейса указать аннотацию `@Override` :

```java
import java.util.ArrayList;
import java.util.List;

public class CalendarApp implements NoteBook {
    List<String> notes = new ArrayList<>();

    @Override
    public void addNote(String note) {
        notes.add(note);
        System.out.println("Заметка успешно добавлена!");
    }
}

```

> Класс обязательно должен либо реализовать все методы интерфейса, 
> либо объявить себя абстрактным — иначе при компиляции возникнет ошибка:
> “`<Class name> is not abstract and does not override abstract method <method name> 
> in <interface name>`” 
> (англ. «[Класс] не является абстрактным и не переопределяет метод из [интерфейса]»).

В интерфейс `NoteBook` был добавлен метод для удаления 
заметок — `deleteNote(int index)`. 

```java
import java.util.ArrayList;
import java.util.List;

interface NoteBook {
    void addNote(String note);

    void deleteNote(int index);
}

class CalendarApp implements NoteBook {
    List<String> notes = new ArrayList<>();

    @Override
    public void addNote(String note) {
        notes.add(note);
        System.out.println("Заметка успешно добавлена!");
    }
    @Override
    public void deleteNote(int index)
    {
        if (index >= 0 && index < notes.size() )
        {   notes.remove(index);
            System.out.println("Заметка успешно удалена!");
        }
        else {
            System.out.println("Неверный индекс для удаления заметки");
        }
    }
}

public class Practicum {

    public static void main(String[] args) {
        CalendarApp noteBook = new CalendarApp();
        noteBook.addNote("Зайти в магазин после работы.");
        noteBook.addNote("Позвонить маме.");

        noteBook.deleteNote(0);
    }

}
```

В интерфейсе можно объявить поля, но они всегда будут **статическими константами**(Поля интерфейсов по умолчанию будут иметь модификаторы `static final`). 
Поэтому в полях интерфейса сохраняют значения, которые нужно использовать 
в различных частях программы — их модификатор по умолчанию тоже будет `public`, как и у методов.


```java
interface Math {
    double PI = 3.141592653589793;
}

public class Practicum {

    public static void main(String[] args) {
       System.out.println("Значение числа Pi = " + Math.PI);
    }
}
```


## Множественная реализация интерфейсов

Один класс может реализовывать сразу несколько интерфейсов.

Вернёмся к примеру с птицами. Допустим, чайка в нашей программе реализует несколько интерфейсов:
`Flyable()` (от англ. «способность летать»), `Waterfowl()` (от англ. «способность плавать»),
`Hunter()` (от англ. «способность охотиться»). 
А утка только два: `Flyable()` и `Waterfowl()`.

В коде это можно описать следующим образом:
```java
public interface Flyable { // способность летать
    void fly(); //метод полёта
    void land(); //метод посадки
}

public interface Waterfowl { // способность плавать
    void swim(); // метод плаванья
}

public interface Hunter { // способность охотиться
    void hunt(); // метод охоты
}

public Seagull implements Flyable, Waterfowl, Hunter {

    @Override
    public void fly() {
        System.out.println("Парю над морем!"); 
    }

    @Override    
    public void land() {
        System.out.println("Мягкая посадка.");
    }

    @Override
    public void swim() {
        System.out.println("Качаюсь на волнах!");
    }

    @Override
    public void hunt() {
        System.out.println("Ловлю рыбку.");
    }
}

public Duck implements Flyable, Waterfowl {

    @Override
    public void fly() {
          System.out.println("Лечу над камышами!");
    }
    
    @Override
    public void land() {
        System.out.println("Смешно сажусь на воду.");
    }

    @Override
    public void swim() {
        System.out.println("Плаваю в пруду!");
    }
}

```

Возможность реализовывать несколько интерфейсов решает проблему ромба, 
которая описывалась в начале урока. Заменим классы `Animal`, `Pet` и `Mammal` на интерфейсы, 
а класс `Cat` будет их реализовывать.  
В результате получаем следующую иерархию:

![img_10.png](images1-9/img_10.png)

В этом случае «проблемы ромба» уже не возникнет. 
Так как реализация метода `eat()` будет только одна — в классе `Cat`. 
Интерфейсы содержат только сигнатуру метода, поэтому неоднозначности, 
какую из реализаций метода вызвать, не возникнет.
Но теперь объект класса `Cat` можно использовать в качестве `Animal`, `Pet` или `Mammal`.

Начнём работать над этой схемой: дополним описание интерфейса `Pet` методом `eat() `
и добавим описание интерфейса `Mammal`:

`Mammal.java`
```java
public interface Mammal {
    // У интерфейса Mammal есть аналогичный метод
    void eat();
    void giveMilk();
}
```
`Pet.java`
```java
public interface Pet {
    int getPawsCount();
    void makeNoise();
    void play();
    //Добавляем метод eat()
    void eat();
} 
```

Чтобы указать, что класс `Cat` реализует оба интерфейса, 
необходимо перечислить их после ключевого слова implements через запятую и 
реализовать методы обоих интерфейсов. При этом «проблемы ромба» 
уже не возникнет — реализация метода `eat()` будет всего одна (в самом классе `Cat`):

```java
public class Cat implements Pet, Mammal {
    @Override
    public int getPawsCount() {
        return 4;
    }

    @Override
    public void makeNoise() {
        System.out.println("Мяу!");
    }

    @Override
    public void play() {
        System.out.println("Играю с мячиком.");
    }

    // Метод будет переопределять и метод из интерфейса Pet, и метод из интерфейса Mammal
    @Override
    public void eat() {
        System.out.println("Люблю покушать рыбку.");
    }

    @Override
    public void giveMilk() {
        System.out.println("Кормлю котят молоком.");
    }
}
```

Отлично, с множественной реализацией интерфейсов разобрались! 
Теперь объекты класса `Cat` можно использовать в программе,
указывая им любой из типов интерфейсов, которые имплементирует этот класс. 
Если нам необходимо в коде программы обращаться к кошке как к домашнему питомцу, 
мы укажем тип переменной `Pet`, а если как с млекопитающим — тип `Mammal`.


> Создайте проект и скопируйте в него код ниже и проверьте, что будут доступны только те методы, которые есть у указанного типа.

```java
public class Practicum {

    public static void main(String[] args) {
        Pet pet = new Cat();
        pet.play();
        pet.eat();
        // Такого метода в интерфейсе Pet нет - произойдет ошибка
        pet.giveMilk();

        Mammal mammal = new Cat();
        mammal.giveMilk();
        mammal.eat();
        // Такого метода в интерфейсе Mammal нет - произойдет ошибка
        mammal.play();
    }
}
class Cat implements Pet, Mammal {
    @Override
    public int getPawsCount() {
        return 4;
    }

    @Override
    public void makeNoise() {
        System.out.println("Мяу!");
    }

    @Override
    public void play() {
        System.out.println("Играю с мячиком.");
    }

    // Метод будет переопределять и метод из интерфейса Pet, и метод из интерфейса Mammal
    @Override
    public void eat() {
        System.out.println("Люблю покушать рыбку.");
    }

    @Override
    public void giveMilk() {
        System.out.println("Кормлю котят молоком.");
    }
}
interface Mammal {
    // У интерфейса Mammal есть аналогичный метод
    void eat();
    void giveMilk();
}
interface Pet {
    int getPawsCount();
    void makeNoise();
    void play();
    //Добавляем метод eat()
    void eat();
}
```

```dtd
submission/Practicum.java:8: error: cannot find symbol

        pet.giveMilk();

           ^

  symbol:   method giveMilk()

  location: variable pet of type Pet

submission/Practicum.java:14: error: cannot find symbol

        mammal.play();

              ^

  symbol:   method play()

  location: variable mammal of type Mammal

2 errors
```

Осталось совсем немного, чтобы закончить иерархию — давайте теперь унаследуем 
от `Animal` интерфейсы `Pet` и `Mammal`. 
Для того чтобы указать, что один интерфейс наследует другой,
в Java используется ключевое слово `extends`
(да, то самое, которое ранее мы использовали для наследования классов!):

```java
public interface Animal {
    int TYPES_OF_ANIMALS_COUNT = 1_600_000;

    void eat();
} 
```
```java
public interface Pet extends Animal {
    int getPawsCount();
    void makeNoise();
    void play();
    void eat();
}
```
```java
public interface Mammal extends Animal {
    void eat();
    void giveMilk();
}
```
Получается, теперь у нас кисулькены наследуют сразу три интерфейса! 
Использовать их в программе мы теперь можем,
указывая интерфейс `Animal`, который котики будут наследовать от интерфейсов `Pet` и `Mammal`:

```java
public class Practicum {

    public static void main(String[] args) {
        Pet pet = new Cat();
        pet.play();
        pet.eat();

        Mammal mammal = new Cat();
        mammal.giveMilk();
        mammal.eat();

        Animal animal = new Cat();
        animal.eat();
    }
}
class Cat implements Pet, Mammal {
    @Override
    public int getPawsCount() {
        return 4;
    }

    @Override
    public void makeNoise() {
        System.out.println("Мяу!");
    }

    @Override
    public void play() {
        System.out.println("Играю с мячиком.");
    }

    // Метод будет переопределять и метод из интерфейса Pet, и метод из интерфейса Mammal
    @Override
    public void eat() {
        System.out.println("Люблю покушать рыбку.");
    }

    @Override
    public void giveMilk() {
        System.out.println("Кормлю котят молоком.");
    }
}
interface Mammal extends Animal {
    void eat();
    void giveMilk();
}
interface Pet extends Animal {
    int getPawsCount();
    void makeNoise();
    void play();
    void eat();
}
interface Animal {
    int TYPES_OF_ANIMALS_COUNT = 1_600_000;

    void eat();
}

```

Подведём итоги. С помощью интерфейсов можно реализовать сложную иерархию сущностей, 
которую не получается сделать, используя классы.

Интерфейсы — это мощный механизм, который вы будете много использовать 
в своих программах. А
ещё они очень часто встречаются в коде стандартной библиотеки Java — например, 
уже знакомый вам класс `ArrayList` на самом деле реализует общий интерфейс 
для всех списков `List`, и в коде программы с `ArrayList`-ом можно работать, 
указывая переменной тип интерфейса, а не конкретного класса:

```java
import java.util.ArrayList;
import java.util.List;

public class Practicum {

    public static void main(String[] args) {
        List<Integer> fibonacciNumbers = new ArrayList<>();

        fibonacciNumbers.add(0);
        fibonacciNumbers.add(1);
        fibonacciNumbers.add(1);
        fibonacciNumbers.add(2);
        fibonacciNumbers.add(3);

        System.out.println("Первые 5 чисел Фибоначчи:");
        for (int i = 0; i < fibonacciNumbers.size(); i++) {
            System.out.println(fibonacciNumbers.get(i));
        }
    }

} 
```
</details>

<details>
<summary>Задание 2</summary>

# Задание 2

В этом задании вам необходимо применить полученные знания об интерфейсах и 
абстрактных классах так, чтобы связать все фигуры в единую иерархию и 
написать программу-калькулятор, вычисляющую площадь фигур: ромба, квадрата,
прямоугольника и круга. Перед тем как вы начнёте, изучите одно небольшое, но важное примечание.

### Примечание

В случае наследования интерфейсов следует быть осторожными.  
Соблюдайте логическую непротиворечивость и базовые принципы подстановки. 
Например, в этом тренажёре вам необходимо связать прямоугольник и квадрат 
в цепочку наследования. 
Если рассматривать вопрос с математической точки зрения, 
то сомнений не будет. Но с точки зрения логики методов, 
которые будут исполняться в  классах, может возникнуть парадокс.

Представьте, что у интерфейса `Прямоугольник` есть методы, 
устанавливающие ширину и высоту фигуры — `getWidth()/setWidth(int w)`
и `getHeight()/setHeight(int h)`.
А у интерфейса `Квадрат` может появиться метод `getSize()/setSize(int s)` — сторона квадрата.

В классе, который реализует интерфейс `Квадрат` вы будете вынуждены реализовать 
все три метода.  Таким образом, меняя сторону квадрата, 
вы будете неявно менять два значения: ширину и высоту фигуры. 
И такое поведение может быть неожиданным для того кода, который использует ваш объект, 
считая его `Прямоугольником`.

Чтобы избежать этого парадокса, нужно добавить в интерфейсы только общие методы.

### код 
```java
public class Practicum {

    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle(4, 6);
        System.out.println("Площадь прямоугольника 4см*6см = " + rectangle.getArea());

        Square square = new Square(3);
        System.out.println("Площадь квадрата 3см*3см = " + square.getArea());

        Rhombus rhombus = new Rhombus(4, 3);
        System.out.println("Площадь ромба со стороной 4см и высотой 3см = " + rhombus.getArea());

        Circle circle = new Circle(2);
        System.out.println("Площадь круга с радиусом 2см = " + circle.getArea());
    }

}
```

```java
public class Circle {
    // Радиус круга
    private final double r;

    public Circle(double r) {
        this.r = r;
    }

    public double getArea() {
        return Math.PI * r * r;
    }
}
```

```java
// В качестве корня иерархии всех фигур необходимо использовать заготовку интерфейса Figure
public interface Figure {
    // Ниже напишите объявление метода/ов, которые будут общими для всей иерархии классов
    ...
}
```

```java
public ... Parallelogram ... {
}
```

```java
public class Rectangle {
    // Длины сторон прямоугольника
    private final double a;
    private final double b;

    public Rectangle(double a, double b) {
        this.a = a;
        this.b = b;
    }

    public double getArea() {
        return a * b;
    }
}
```

```java
public class Rhombus {
    // Длина стороны ромба
    private final double a;
    // Высота ромба
    private final double h;

    public Rhombus(double a, double h) {
        this.a = a;
        this.h = h;
    }

    public double getArea() {
        return a * h;
    }
}
```

```java
public class Square {
    // Длина стороны квадрата
    private final double a;

    public Square(double a) {
        this.a = a;
    }

    public double getArea() {
        return a * a;
    }
}
```

### Подсказки

* У классов `Square`, `Rhombus` и `Rectangle` совпадает реализация метода `double getArea()`. 
Такой метод можно вынести в абстрактный класс `Parallelogram`.
* У всех классов есть метод double `getArea()`. Поскольку сигнатура метода одинаковая,
а способ подсчёта площади фигуры внутри метода — разный, метод можно вынести в 
базовый интерфейс `Figure`.
* Классы `Square`, `Rhombus` и `Rectangle` используют одинаковый набор параметров, 
эти параметры можно вынести в абстрактный класс и создать конструктор с параметрами.
* Некоторые из фигур являются частными случаями других. 
Например, квадрат — это частный случай прямоугольника, 
а прямоугольник — частный случай параллелограмма.
Такие фигуры можно унаследовать друг от друга. 
Если затрудняетесь построить иерархию фигур, воспользуйтесь схемой:
![img_11.png](images1-9/img_11.png)


</details>

<details>

<summary>Полиморфизм</summary>

# Полиморфизм

Пришло время познакомить вас с последним, четвёртым принципом объектно-ориентированного программирования — **полиморфизмом**.

**Полиморфизм** (в переводе с греческого означает «многообразный») — это способность принимать разные формы. 
Он встречается не только в программировании. Например, у бабочек-пестрокрыльниц весной крылья оранжевые с тёмными пятнами, а летом — тёмные с белыми полосами.

Один из ярких примеров полиморфизма в химии — модификации углерода. 
Он может принимать форму графита (и тогда его вставляют в карандаши) или форму алмаза (и тогда он отправляется на огранку к ювелиру).

![img_12.png](images1-9/img_12.png)

### Полиморфизм и интерфейсы


В применении к языкам программирования **полиморфизм** означает способность кода, например, одного и того же метода, одинаково работать с данными разных типов.

Допустим, в программе есть интерфейс MailClient, который описывает функциональность отправки и получения писем:

```java
public interface MailClient {
    void send(String from, String to, String text);
    void recieve();
}
```

Этот интерфейс могут реализовывать разные классы: голубь, почтальон, электронная почта. 
С каждым из них программа будет работать одинаковым образом. 
Если же мы захотим отправить письмо с помощью телеграфа (или с помощью его улучшенного варианта - телетайпа), 
достаточно будет сделать так, чтобы он реализовывал интерфейс MailClient.

В коде это реализуется следующим образом:
```java
public class Dove implements MailClient {
    @Override
    public void send(String from, String to, String text) {
        System.out.println("Голубь полетел к " + to + " от " + from + " с письмом: " + text);
    }

    @Override
    public void recieve() {
        System.out.println("Голубь вернулся с ответным письмом!");
    }
}
```
```java
public class Telegraph implements MailClient {
    @Override
    public void send(String from, String to, String text) {
        System.out.println("Телеграф передал для " + to + " от " + from + " коды букв с посланием: " + text);
    }

    @Override
    public void recieve() {
        System.out.println("Телеграф напечатал ответное сообщение.");
    }
} 
```

Как вы уже знаете, на основе интерфейса нельзя создавать объекты. 
Но можно объявить переменную с типом интерфейса и присвоить ей в качестве значения объект любого класса, который реализует этот интерфейс.

```java
    MailClient mailClient; // объявили переменную с типом интерфейса MailClient
    
    if(currentCentury < 20) {
        // присваеваем переменной в качестве значения объект класса Dove
        mailClient = new Dove();
    } else {
        // присваеваем переменной в качестве значения объект класса Telegraph
        mailClient = new Telegraph();
    }
    
    // конкретный тип объекта не важен, если он реализует 
    // интерфейс MailClient, потому что у него есть метод send()
    mailClient.send();
```

Если коду требуется только функциональность, описанная в интерфейсе MailClient, 
то не важно, какой конкретный тип будет у объекта, способного отправить и получить почту. 
С телеграфом программа будет взаимодействовать так же, как с голубем — если у них одинаковый интерфейс.

Такой подход позволяет выбирать конкретную реализацию (голубь или телеграф) 
Например в зависимости от настроек программы, 

Дан интерфейс Openable, описывающий предметы, которые можно открыть, и два класса: `Can` и `Window`.
Доработаем классы таким образом, чтобы они реализовывали интерфейс Openable.

```java

class Can implements Openable {
    @Override
    public void open() {
        System.out.println("Чтобы открыть жестяную банку, нужно потянуть кольцо-ключ.");
    }
}

interface Openable {
    void open();
}

public class Practicum {

    public static void main(String[] args) {
        Openable can = new Can();
        can.open();

        Openable window = new Window();
        window.open();
    }
}

class Window implements Openable {
    @Override
    public void open() {
        System.out.println("Чтобы открыть окно, нужно повернуть ручку.");
    }
}
```

### Полиморфизм и наследование

Полиморфизм в программировании проявляется не только в особенностях работы с интерфейсами, но и в механизме наследования.
По аналогии с интерфейсами можно сохранять объект наследника в переменную с родительским типом.

Например, создадим класс, описывающий грызунов — `Rodent` (англ. «грызун»). Добавим в него методы, 
общие для всех его представителей: `crunch()` (англ. «грызть») и `sleep()` (англ. «спать»). 
Кроме них, у наследников класса `Rodent` будут и уникальные свойства:

* `dive()` (англ. «нырять») у класса `Capybara` (англ. «капибара»),
* `jump()` (англ. «прыгать») у класса `Jerboa` (англ. «тушканчик»).

Поскольку все тушканчики и капибары являются грызунами, а значит умеют спать и грызть, объекты этих классов можно сохранять в переменные с родительским типом:

```java
// тип переменной - абстрактный класс Rodent, тип присваемого объекта Capybara
Rodent a = new Capybara();
// тип переменной - абстрактный класс Rodent, тип присваемого объекта Jerboa
Rodent b = new Jerboa();
```

При этом, если вы попытаетесь, наоборот, в переменной с типом класса наследника сохранить объект с типом класса родителя, произойдёт ошибка.

```java
// нельзя присвоить объект родительского типа переменной с типом-наследником
Capybara c = new Rodent(); // Ошибка!
```

Так делать нельзя, потому что объект более общего класса `Rodent` не может полностью заменить объект расширенного класса `Capybara`.

Другими словами, капибары подходят и под общее понятие «грызун», и под частное — «капибара». 
Эти зверьки могут выступать в обеих ролях. Но общее понятие «грызун» нельзя просто так свести к частному понятию «капибара».
Объект типа `Rodent` ничего не знает про то, как нырять. И если попытаться вызвать метод `dive`, присущий капибарам, 
то объект не смог бы его выполнить. Ведь в нём нет информации об этом методе. Поэтому такое присваивание запрещено.

Запустите код .
```java
class Rodent {
    public void crunch() {
        System.out.println("Грызун грызёт что угодно.");
    }

    public void sleep() {
        System.out.println("Грызун уснул.");
    }
}

class Capybara extends Rodent {

    @Override
    public void crunch() {
        System.out.println("Капибара любит грызть кукурузу.");
    }

    @Override
    public void sleep() {
        System.out.println("Капибара крепко спит.");
    }

    public void dive() {
        System.out.println("Капибара умеет нырять.");
    }
}

public class Practicum {

    public static void main(String[] args) {
        Rodent capybara = new Capybara();
        capybara.crunch();
        capybara.sleep();
       
    }

}
```

При наследовании в Java классы связываются отношением **IS-A** (англ. «является»): 
один класс является подклассом другого. Все капибары — грызуны, но не все грызуны — капибары.

![img_13.png](images1-9/img_13.png)

### Полиморфизм: объединяем вместе

А вот более сложный пример полиморфмизма: программистка Катя.

Да-да, полиморфизм применим и к ней тоже: дома Катя выступает в роли обычного человека, который спит и кушает, — это можно описать с помощью класса `Person`.
Но у Кати есть и дополнительная функциональность: на работе, как и любой другой наёмный сотрудник, 
она выполняет свои задачи и получает за это зарплату. Это лучше вынести в отдельный интерфейс — `Employee`, 
потому что не все люди работают. Кроме того, у Кати есть специфичные «методы», 
характерные для программистов: ей приходится часто и подолгу обдумывать решение своих задач и дебажить код.

Поэтому логично будет описать Катю как объект класса `SoftwareDeveloper`, который наследуется от класса `Person` и реализует интерфейс `Employee`.

![img_14.png](images1-9/img_14.png)

В таких случаях говорят, что класс `SoftwareDeveloper` является **полиморфным**, потому что для него выполняется следующее условие: он связан отношением IS-A
с более чем одним типом (классом или интерфейсом).

Проверим это утверждение:
* Класс `SoftwareDeveloper` является подтипом типа `Employee` (A Software Developer IS-A Employee),
* Класс `SoftwareDeveloper` является подтипом типа `Person` (A Software Developer IS-A Person).

Но это ещё не всё! Класс `SoftwareDeveloper` также наследуется от базового класса `Object`, поэтому следующее утверждение тоже будет верным:
Класс `SoftwareDeveloper` является подтипом типа `Object` (A Software Developer IS-A Object).

> 💡 В Java все классы наследуются от класса Object. Поэтому все классы полиморфные.

> Способность одинаково работать с объектами разного типа — лишь один из видов полиморфизма. Об остальных вы узнаете дальше.

 
</details>

<details>

<summary>Виды полиморфизма</summary>

# Виды полиморфизма

В прошлом уроке вы начали знакомиться с полиморфизмом. У него есть несколько видов. В большинстве случаев выделяют три вида полиморфизма:
* **Параметрический полиморфизм** (от англ. parametric polymorphism).
* **Полиморфизм подтипов** (от англ. _subtype polymorphism_), или по-другому **сабтайпинг** (от англ. _subtyping_).
Этот вид также называют **полиморфизм включения** (от англ _inclusion polymorphism_).
* **Ad-hoc полиморфизм**, или перегрузка (англ. _overloading_). 

> В программировании также есть понятие переопределения (от англ. overriding),
> которое относится к наследованию. Перегрузку не следует путать с переопределением.

В этом уроке вы рассмотрите полиморфизм подтипов и ad-hoc полиморфизм. С параметрическим полиморфизмом познакомимся в следующей теме.

## Сабтайпинг. Полиморфизм подтипов

Идея сабтайпинга состоит в том, что вместо значений **одного типа** можно использовать значения его **подтипов**.

Например, в Java можно присвоить число `5` переменной с типом `int`. 
Но число `5` также можно присвоить и переменной с типом `float`. 
Это означает, что данные типа `int` могут использоваться там, где требуется `float`, потому что `int` является его подтипом.

```java
class Practicum {
    public static void main(String[] args) {
        int a = 3;
        int b = 19;

        // вызываем метод sum и передаём ему аргументы типа int
        System.out.println("Сумма " + a + " и " + b + " равна " + sum(a, b));
    }

    // параметры метода sum имеют тип float
    public static float sum(float a, float b) {
        return a + b;
    }
}
```

Важно не путать сабтайпинг с наследованием. Тип `int` не наследует от `float`, следовательно, он не является его подклассом.
> Понятие подкласса не применимо к типу int, так как это примитивный тип данных.

Но `float` содержит и дробные, и целые числа, то есть он **включает** в себя значения типа `int`. 
Поэтому, с точки зрения системы типов, `int` — это подтип `float`.

Однако в Java механизм наследования позволяет воспользоваться сабтайпингом. 
Рассмотрим пример. Предположим, у нас есть базовый класс `Person`, который может описать любого человека.
У него есть наследники — классы `Teacher` и `Student`, описывающие людей конкретных профессий.

И студенты, и учителя — люди, так что тип данных `Person` **включает** в себя два подтипа: `Teacher`
и `Student`. Таким образом, объекты этих классов могут использоваться везде, где требуются объекты типа `Person`, ведь они наследуют его характеристики.

```java
class Person {
    private final String name;

    Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

class Teacher extends Person {
    Teacher(String name) {
        super(name);
    }
}

class Student extends Person {
    Student(String name) {
        super(name);
    }
}


class Practicum {
    public static void main(String[] args) {
        // создаём объект типа Teacher и передаём его в метод, ожидающий тип Person
        Teacher teacher = new Teacher("Василий Петрович");
        printPersonName(teacher);

        // создаём объект типа Student и передаём его в метод, ожидающий тип Person
        Student student = new Student("Мария");
        printPersonName(student);
    }

    // параметр метода printPersonName имеет тип Person
    public static void printPersonName(Person person) {
        System.out.println("Меня зовут " + person.getName());
    }
}
```

Подытожим. С точки зрения наследования, `Teacher` и `Student` — это подклассы `Person`. А с точки зрения полиморфизма, 
`Teacher` и `Student` — подтипы `Person`. Разница в том, что понятие типа данных и его подтипов более общее. 
Вы это увидели в первом примере, где вообще не использовались классы.

Взаимосвязь тип-подтип распространяется и на использование интерфейсов. 
Все классы, которые реализуют какой-либо интерфейс, автоматически становятся его подтипами.

```java
interface Printable {
    void print();
}

class Book implements Printable {
    private final String title;

    public Book(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }

    @Override
    public void print() {
        System.out.println("Книга \"" + title + '"');
    }
}

class Point implements Printable {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    public void print() {
        System.out.println("x: " + x + ", y: " + y);
    }
}

public class Practicum {
    public static void main(String[] args) {
        // создаём объект типа Book и передаём его в метод, ожидающий тип Printable
        Book book = new Book("Анна Каренина");
        printThis(book);

        // Создаём объект типа Point и передаём его в метод, ожидающий тип Printable
        Point point = new Point(5, -12);
        printThis(point);
    }

    // параметр метода printThis имеет тип Printable
    public static void printThis(Printable printable) {
        printable.print();
    }
}
```

Разберём этот пример. Метод `printThis` ожидает аргумент с типом данных `Printable`. 
Так как `Printable` — интерфейс, создать объект непосредственно этого типа нельзя. 

> У интерфейсов нет конструкторов и нет возможности создать объект интерфейса.

Такой метод был бы бессмысленным, если бы система типов Java не реализовывала сабтайпинг.

Благодаря полиморфизму подтипов вместо объекта с типом `Printable` 
можно передать объект любого его подтипа. В нашем случае  — это объекты классов `Book` и `Point`.

> Полиморфизм включения позволяет использовать значения других типов, если они являются подтипами требуемого типа. 
> (Например, все классы, реализующие интерфейс, являются его подтипами и могут быть использованы вместо него.)
> 
> Объекты дочерних классов можно использовать вместо родительского.
> (Дочерние классы являются подтипами родительского, и их объекты могут быть использованы в качестве значений родительского типа.)

Отметим ещё один важный аспект работы с сабтайпингом. Если вместо родительского типа подставить объекты его подтипов, 
то у них будут доступны только общие с родительским типом методы. Если в объектах подтипов есть другие методы,
отсутствующие в родительском типе, то они будут недоступны.  

Вернёмся к предыдущему примеру. Тип параметра у метода `printThis` указан как `Printable`.
Этот интерфейс декларирует только один метод — `print`. Полиморфизм подтипов позволяет передать в метод `printThis`
объекты классов `Book` и `Point`. Но внутри этого метода они будут восприниматься только как объекты типа `Printable`,
поэтому у них будет доступен только метод `print`. И если попытаться вызывать другие методы, 
например, `getTitle` или `getX`, то компилятор выдаст ошибку.

Запустите программу и изучите её код. Обратите внимание на полиморфный класс `SoftwareDeveloper` и то, 
как ведут себя его объекты в зависимости от указанного типа переменной.
Добавьте ввод имени с клавиатуры и попробуйте заменить имя «Катя» на своё.

```java

import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        String name = "Катя";

        System.out.println("Что " + name + " делает как работник:");
        Employee employee = new SoftwareDeveloper(name);
        employee.work();
        System.out.println("Получает зарплату за месяц: " + employee.getSalary() + " р.");
        // Таких методов в интерфейсе Employee нет - произойдет ошибка
        // employee.eat();
        // employee.doDebug();

        System.out.println("\nЧто " + name + " делает как человек:");
        Person person = new SoftwareDeveloper(name);
        person.eat();
        person.sleep();
        // Таких методов в классе Person нет - произойдет ошибка
        // person.work();
        // person.doDebug();

        System.out.println("\nЧто " + name + " делает как программист:");
        SoftwareDeveloper softwareDeveloper = new SoftwareDeveloper(name);
        softwareDeveloper.doDebug();
        softwareDeveloper.think();
    }
}
interface Employee {
    void work();

    double getSalary();
}
class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public void eat() {
        System.out.println("Обедает в кафе.");
    }

    public void sleep() {
        System.out.println("Крепко спит всю ночь.");
    }
}
class SoftwareDeveloper extends Person implements Employee {

    public SoftwareDeveloper(String name) {
        super(name);
    }

    @Override
    public void work() {
        System.out.println("Выполняет свою работу - пишет код весь день.");
    }

    @Override
    public double getSalary() {
        return 100500.0;
    }

    public void doDebug() {
        System.out.println("Ищет ошибки в коде.");
    }

    public void think() {
        System.out.println("Обдумывает решение задачи.");
    }
}
```

Полиморфизм подтипов — относят к универсальному полиморфизму. 
Это означает, что с его помощью можно написать одну версию метода, и он сможет работать с множеством типов. 
В последнем примере метод `printThis` может работать с объектами любых классов, реализующих интерфейс `Printable`. 
При этом не нужно для каждого отдельного типа добавлять новую версию метода `printThis`. В
этом и выражается универсальность: одна реализация, множество типов.

А теперь перейдём к ad-hoc полиморфизму. Его можно назвать противоположным **универсальному полиморфизму**: он основан на различении типов.

> К универсальному полиморфизму относят параметрический полиморфизм и сабтайпинг.

### Ad-hoc полиморфизм

Ad-hoc можно перевести как «специальный» полиморфизм. При использовании сабтайпинга можно один раз определить функцию, 
и она будет работать для любого количества подтипов. А в ad-hoc полиморфизме нужно каждый раз определять специальный вариант функции.

В Java ad-hoc полиморфизм реализуется через перегрузку (англ. _overloading_) методов. 
Этот механизм позволяет создавать множество реализаций **одного и того же метода**(_То есть метода с одним и тем же именем_.) до тех пор, пока различаются типы,
порядок или количество его параметров. 
При этом тип возвращаемого значения можно как менять, так и оставить одинаковым во всех реализациях.

```java
import java.util.ArrayList;
import java.util.Arrays;

class Printer {
    void print(int i) {
        System.out.println("Целое число: " + i);
    }

    void print(double d) {
        System.out.println("Дробное число: " + d);
    }

    void print(String s) {
        System.out.println("Строка: " + s);
    }

    void print(Object o) {
        System.out.println("Объект: " + o);
    }

    void print(int[] ints) {
        System.out.println("Массив: " + Arrays.toString(ints));
    }

    void print(int x, int y) {
        System.out.println("Сумма чисел " + x + " и " + y + " равна " + (x+y));
    }
}

public class Practicum {
    public static void main(String[] args) {
        Printer printer = new Printer();

        printer.print(5);
        printer.print(2.5);
        printer.print("Шла Саша по шоссе");
        printer.print(new ArrayList<>());
        printer.print(new int[]{1,2,3,4,5});
        printer.print(999, 1);
    }
}
```

Если посмотреть на код в методе `main`, можно увидеть, что метод `print` объекта типа `Printer` отлично работает с данными разных типов. 
Это означает, что метод `print` полиморфен. Но количество вариантов типов, с которыми этот метод может работать,
ограничено специальными перегруженными реализациями, что определены в классе `Printer`. 
При таком подходе компилятор сам выберет нужную реализацию — в зависимости от типа переданного аргумента, который становится известен на этапе компиляции.

>💡 Пример с принтером мы выбрали неспроста: хорошо известный вам метод для вывода `println` — пример перегрузки методов. 
> У него есть много разных реализаций, каждая из которых принимает свой параметр. 
> Поэтому можно вызывать его с разными типами: и с примитивами, и с объектами.

Ad-hoc полиморфизм позволяет подстраивать поведение конкретной реализации метода в зависимости от переданных аргументов. Эта возможность иногда очень помогает: например, при оптимизации работы метода с конкретными типами.

> 💡 Overloading vs overridng
> Очень важно не путать перегрузку (англ. _overloading_), относящуюся к ad-hoc полиморфизму, 
> и переопределение (англ. _overriding_), относящееся к наследованию. 
> Перегрузка позволяет создать множество реализаций для метода с одним и тем же названием.
> При этом не задействуются никакие механизмы наследования. Переопределение же, 
> наоборот, позволяет предоставить свою реализацию только для наследуемых методов.


Полиморфизм довольно не простая тема: в неё можно до бесконечности погружаться и узнавать новые аспекты и возможности. 
Если у вас голова идёт кругом от обилия производных слова «тип» и прочих терминов, это нормально!
Вы не раз пользовались возможностями полиморфизма, даже не подозревая это. А теперь вы разбираетесь, что к чему. И это прекрасно!

</details>

<details>

<summary>Задание 3</summary>

# Задание 3

Помогите пользователю вашего приложения связаться с другом через виртуальную АТС. Допишите модуль АТС, используя принципы полиморфизма.
Способ связи будет зависеть от модели телефона, принимающего вызов пользователя.
* Если у пользователя стационарный или мобильный телефон, то позвонить ему можно только по сотовой связи 
(в этом случае необходимо вывести сообщение `Набираем номер <targetNumber> и звоним по сотовой связи`).
* Любой смартфон — это мобильный телефон, но не любой мобильный телефон — смартфон! 
У смартфона есть возможность принимать звонки и сообщения как по сотовой связи, 
так и через сторонние приложения — в этом случае перед звонком нужно вывести сообщение `Позвоним через приложение <appName> по номеру <targetNumber>`.
* Если у пользователя мобильный телефон, ему можно отправить SMS: `Отправляем сообщение <messageText> по номеру <targetNumber>`.

* А пользователь смартфона может отправлять не только SMS, но и email — в этом случае нужно вывести сообщение `Напишем другу сообщение <messageText> по email <email>`.

`Phone.java`

```java
public ... Phone {
    private final String number;

    public Phone(String number) {
        this.number = number;
    }

    public final void makeCall(String targetNumber) {
        System.out.println("Звоним с номера " + number);
        System.out.println("Набираем номер " + targetNumber + " и звоним по сотовой связи");
        System.out.println("Привет!");
    }
}
```

`LandlinePhone.java`

```java
// допишите реализацию класса LandlinePhone
public class LandlinePhone {

}
```

`MobilePhone.java`

```java
public class MobilePhone {
    ...

    //объявите метод sendSms()
    ... {
        System.out.println("Отправляем сообщение " + messageText + " по номеру " + targetNumber);
    }
}
```

`Smartphone.java`

```java
// допишите реализацию класса Smartphone
public class Smartphone {

    ...
    // объявите метод sendEmail()
    ... {
        System.out.println("Напишем другу сообщение " + messageText + " по email " + email);
    }

}
```

`Practicum.java`

```java
import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        System.out.println("Вас приветствует виртуальная АТС!");

        Scanner scanner = new Scanner(System.in);
        System.out.println("Введите ваш номер телефона:");
        String number = scanner.next();
        System.out.println("Введите номер пользователя, которому хотите позвонить:");
        String friendNumber = scanner.next();
        System.out.println("Выберите модель телефона собеседника, 1 - стационарный телефон, 2 - мобильный телефон, 3 - смартфон:");
        int type = scanner.nextInt();

        if (type < 1 || type > 3) {
            System.out.println("Введена неверная модель телефона");
            return;
        }

        getPhone(type, number).makeCall(friendNumber);
    }

    public static ... getPhone(int type, String number) {
        if (...) {
            // если выбран стационарный телефон, создайте объект класса LandlinePhone
            return new LandlinePhone(number);
        } else if (...) {
            // если выбран мобильный телефон, создайте объект класса MobilePhone
            return new MobilePhone(number);
        } else {
            // иначе создайте экземпляр класса Smartphone
            ...
        }
    }

}
```

## Подсказки

* Базовые функции и свойства телефона, такие как номер
и возможность позвонить через сотовую связь, стоит вынести в абстрактный класс `Phone`. От этого класса будут наследоваться все остальные.
* Смартфон — это частный случай мобильного телефона. Ему доступны все те же функции, что и на мобильном, поэтому класс `Smartphone` необходимо унаследовать от класса `MobilePhone`.
* Чтобы добавить возможность пользователю смартфона звонить через сторонние приложения, добавьте в класс `Smartphone` перегрузку метода `makeCall(String targetNumber, String appName)`.
* Для отправки email метод смартфона должен принимать две строки — адрес почты и текст сообщения. 
Но при этом должна остаться возможность отправлять сообщения и с помощью SMS, поэтому переопределение метода не подойдёт — нужно добавить новый метод `sendEmail`, который будет принимать два параметра.

</details>


<details>

<summary>Полиморфизм в стандартной библиотеке Java</summary>

# Полиморфизм в стандартной библиотеке Java

В предыдущих уроках вы рассматривали концепцию полиморфизма на простых примерах из окружающего мира. Теперь расскажем, как она реализована в программировании — в стандартной библиотеке классов Java.

> 💡 В этом уроке будут даны сокращённые представления различных классов из JDK. Чтобы у вас была возможность ознакомиться с полным кодом классов, в комментариях к каждому листингу представлена ссылка на исходный код.

## Ad-hoc полиморфизм

Ad-hoc полиморфизм часто встречается в стандартной библиотеке Java.
Он позволяет расширить интерфейс класса через перегрузку метода.

Например, перегрузку метода можно встретить в классе `ArrayList`. В нём есть два метода для добавления элемента: по индексу и в конец списка.

Перегрузка позволяет сделать класс более удобным для разработчиков,
покрывая часто используемые случаи, например,  добавление нового элемента в конец списка.
Если бы метод для вставки элемента был только один (например, только метод добавления по индексу),
то разработчикам пришлось бы постоянно добавлять элемент в конец списка длинной командой `list.add(list.size(), element)`
(а добавление элемента в конец списка — частая операция!).

Поэтому, чтобы упростить написание кода, в интерфейс класса `ArrayList` добавили ещё один метод. 
Он принимает в качестве единственного аргумента сам элемент и автоматически добавляет его именно в конец списка:

```java
/* Ниже представлен упрощённый вид класса ArrayList, в котором */
/* показаны только интересующие нас методы. С полным кодом класса */
/* вы можете ознакомиться в стандартной библиотеке Java */
/* https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/ArrayList.java */

/* В этом примере E -- тип параметра списка */
/* Например, для списка строк E = String */
public class ArrayList<E> implements List<E> {

    public boolean add(E element) {
        // добавляет элемент в конец списка
    }

    public void add(int index, E element) {
        // добавляет элемент по индексу -- на указанную позицию
    }
}
```

Вы можете поступать аналогично и в ваших программах: если есть метод, который часто вызывается с одинаковым значением параметра,
то можно перегрузить его, зафиксировав это значение внутри метода. Так его станет проще вызывать.

Перед вами список студентов, в конец которого добавляются новые фамилии.
Изучите код и обратите внимание на различия методов `add(E element)` и `add(int index, E element)`.

```java

import java.util.ArrayList;
import java.util.List;

public class Practicum {

    public static void main(String[] args) {
        List<String> students = new ArrayList<>();
        // Если бы в ArrayList был только один метод для добавления элементов в список
        // Добавлять их в конец списка пришлось бы так:
        students.add(students.size(), "Петрова");
        students.add(students.size(), "Иванов");
        students.add(students.size(), "Васечкин");

        // Так как разработчики Java позаботились о программистах,
        // Добавлять элементы в конец списка можно проще:
        students.add("Последкина");
        students.add("Финальный");

        for (String student: students) {
            System.out.println(student);
        }
    }
}
```

Ещё один интересный пример перегрузки методов можно увидеть в классе `String`. 
Разработчикам часто приходится преобразовывать объекты к их строковому представлению — например,
чтобы вывести их на экран. Для этого в классе `String` есть целый набор перегруженных методов `valueOf()` 
под разные типы аргументов. В зависимости от того, какой тип аргумента будет передан в метод `valueOf()`, программа выберет подходящую реализацию метода:

```java
/* Ниже представлен упрощённый вид класса String, в котором */
/* показаны только интересующие нас методы. С полным кодом класса */
/* вы можете ознакомиться в стандартной библиотеке Java */
/* https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/String.java */

public final class String {

    public static String valueOf(Object obj) {
        return (obj == null) ? "null" : obj.toString();
    }

    public static String valueOf(char data[]) {
        return new String(data);
    }

    public static String valueOf(boolean b) {
        return b ? "true" : "false";
    }

    public static String valueOf(int i) {
        return Integer.toString(i);
    }

    public static String valueOf(double d) {
        return Double.toString(d);
    }

}

```

Изучите код примера, который использует различные перегрузки метода `valueOf` из класса `String`.

Это можно также пронаблюдать в вашей среде разработки: скопируйте код локально и перейдите к реализации метода `valueOf`.
Для этого наведите курсор на одно из использований метода `valueOf`, зажмите клавишу `Ctrl` и нажмите левой кнопкой мыши на название метода `valueOf`. 
В этом случае вы перейдёте на реализацию метода. Обратите внимание, что для разных типов вы перейдёте на разные реализации методов.

```java
public class Practicum {

    public static void main(String[] args) {
        int i = 100;
        // Будет вызван метод valueOf(int i)
        System.out.println(String.valueOf(i));

        double d = 100;
        // Будет вызван метод valueOf(double d)
        // Это можно заметить по выводу значения - оно будет отличаться от вывода переменной i
        System.out.println(String.valueOf(d));

        boolean b = true;
        // Будет вызван метод valueOf(boolean b)
        System.out.println(String.valueOf(b));

        Boolean o = null;
        // Будет вызван метод valueOf(Object obj), т.к. Boolean - это объект
        System.out.println(String.valueOf(o));
    }
}
```

При разработке библиотек всегда необходимо учитывать кейсы использования ваших классов другими разработчиками. 
И предоставлять как можно больше перегрузок методов для решения разных задач.

## Пример переопределения метода

Для контраста с перегрузкой, рассмотрим также пример переопределения метода родительского класса. 
Переопределение используется, чтобы поменять унаследованное поведение класса, не меняя код родительского класса.

Возьмём для примера класс `HashMap`, который используется для хранения пар «ключ-значение» и
хранит элементы в обычном массиве, и унаследованный от него класс `LinkedHashMap`, 
у которого отличается принцип хранения элементов — они хранятся в виде связного списка.

В классе `LinkedHashMap` переопределён внутренний метод создания нового элемента коллекции `newNode`. 
При этом поведение метода добавления нового элемента `put` изменится по сравнению с поведением родительского класса —
при обращении к нему для создания нового элемента будет использован метод `newNode` класса-наследника, 
и элемент будет добавлен в коллекцию в конец связного списка.

```java

/* Ниже представлен упрощённый вид класса HashMap, в котором */
/* показаны только интересующие нас методы. С полным кодом класса */
/* вы можете ознакомиться в стандартной библиотеке Java */
/* https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/HashMap.java */

/* В данном примере K, V -- типы параметров ключа и значения */
public class HashMap<K, V> {

    public V put(K key, V value) {
        Node node = this.newNode(hash, key, value, null);
        // Элемент node сохраняется в мапу
        return node.getValue();
    }

    Node<K, V> newNode(int hash, K key, V value, Node<K, V> next) {
        return new Node(hash, key, value, next);
    }
}
```
```java
/* Ниже представлен упрощённый вид класса LinkedHashMap, в котором */
/* показаны только интересующие нас методы. С полным кодом класса */
/* вы можете ознакомиться в стандартной библиотеке Java */
/* https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/LinkedHashMap.java */

/* В данном примере K, V -- типы параметров ключа и значения */
public class LinkedHashMap<K,V> extends HashMap<K,V> {

    Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
        LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<>(hash, key, value, e);
        linkNodeLast(p);
        return p;
    }
}
```

Поздравляем! Теперь вы знаете, какие принципы лежат в основе объектно-ориентированного программирования и умеете работать с ними.

Чтобы картина сложилась полностью, объединим их в одном образе. Например, автомобиля:

* Инкапсуляция — все механизмы скрыты внутри автомобиля, водитель их не видит;
* Наследование — время от времени появляются новые модели конкретной марки автомобиля, но все они будут похожи на предыдущие версии;
* Абстракция — водитель может не знать, как устроен автомобиль, но умеет взаимодействовать с ним благодаря понятному интерфейсу в виде педалей и руля;
* Полиморфизм — если какая-то деталь двигателя вышла из строя, её можно заменить на точно такую же деталь другой марки, и это никак не повлияет на работу автомобиля.

Ниже представлен пример программы, которая умеет складывать любые переданные ей на вход данные.

```java
class Appender {

    public static int add(int a, int b) {
        return a + b;
    }
  
   public static String add(String a, String b) {
     
        return a + b;
    }
   public static boolean add(boolean a, boolean b) {
        return a || b;
    }
   public static double add(double a, double b) {
        return a + b;
    }
}

public class Practicum {
    public static void main(String[] args) {
        System.out.println("2 + 3 = " + Appender.add(2, 3));
        System.out.println("9.4 + 1.2 = " + Appender.add(9.4, 1.2));
        System.out.println("Кофе + машина = " + Appender.add("Кофе", "машина"));
        System.out.println("true + false = " + Appender.add(true, false));
    }
}
```
</details>

Предыдущее занятие | &nbsp; | Следующее занятие
:----------------:|:----------:|:----------------:
[Урок 8](Lesson8.md) | [Содержание](readme.md) | [Урок 10](Lesson10.md)