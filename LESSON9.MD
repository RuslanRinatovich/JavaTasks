# Урок 9. Абстракция и полиморфизм


# Требования к сдаче работы
Задание выполняется в среде программирования Idea. Результат надо разместить в своем репозитории на GitHub.
Прислать в гугл-формы(размещенная на моем сайте) ссылку на репозиторий.


***Критерии оценивания***
* Оценка 5 - надо сделать все пять заданий.
* Оценка 4 - надо сделать любые три задания.
* Оценка 3 - надо сделать одно любое задание.

1. [Введение в тему](#введение-в-тему)
2. [Знакомимся с абстракцией](#знакомимся-с-абстракцией)
   * [Создаём абстрактный класс](#создаём-абстрактный-класс)
   * [Добавляем методы](#добавляем-методы)
     - [Обычные методы в абстрактном классе](#обычные-методы-в-абстрактном-классе)
     - [Абстрактные методы в абстрактном классе](#абстрактные-методы-в-абстрактном-классе)
   * [Создаём наследников абстрактного класса](#создаём-наследников-абстрактного-класса)
   * [Создаём объекты классов-наследников](#создаём-объекты-классов-наследников)
3. [Задание 1](#задание-1)
4. [Интерфейсы в Java](#интерфейсы-в-java)


<details>
<summary>Введение в тему</summary>

# Введение в тему

Вы уже знаете, что в основе объектно-ориентированного программирования (ООП) лежат четыре принципа: инкапсуляция, наследование, абстракция и полиморфизм. С первыми двумя вы познакомились в прошлом спринте. А в этой теме вы рассмотрите абстракцию и полиморфизм.

Вы научитесь создавать абстрактные классы и узнаете, как в Java решена проблема множественного наследования. Расширите свои знания о приведении типов и научитесь:

* реализовывать абстрактный класс из нескольких классов;
* реализовывать интерфейс из одного или нескольких классов;
* перегружать метод.

Ещё вы изучите, как концепция полиморфизма реализована в стандартной библиотеке Java, и поймёте разницу между автоматическим и явным приведением ссылочных типов.

Но обо всём по порядку! Начнём с абстракции.

</details>

<details>
<summary>Знакомимся с абстракцией</summary>

# Знакомимся с абстракцией

Абстракция (англ. abstraction, «отвлечение»), применительно к ООП, это принцип, при котором пользователю класса доступны только методы, описывающие основное поведение, а остальные детали скрыты внутри реализации. Одним из инструментов для достижения абстракции является инкапсуляция. Используя этот принцип, программист описывает, что делает класс, а не то как он это делает.

Например, когда вы спрашиваете у своей умной колонки «Какая завтра будет погода?», запускается примерно такая цепочка действий:

* голосовой помощник анализирует ваш вопрос;
* переводит его в машинный код, понятный компьютеру;
* отправляет запрос на сервер;
* получает данные о погоде;
* переводит их в голосовое представление;
* и наконец воспроизводит ответ.

Всё это выполняется молниеносно, совершенно незаметно для пользователя. Вам не нужно понимать, какие процессы происходят внутри колонки, чтобы взаимодействовать с ней. Достаточно знать, что она умеет отвечать на вопросы.

Таким образом, разработчики предоставили вам простой в использовании голосовой интерфейс и дали возможность **абстрагироваться** от деталей его реализации.

![img_4.png](img_4.png)

Именно принцип абстракции в ООП позволяет программисту работать с объектами и классами, даже если он не знает, как они устроены и какие алгоритмы скрыты в их реализации.

Например, для работы с объектами класса `ArrayList` вам не обязательно знать о том, что они хранят элементы в обычном массиве и создают новый, если в старом заканчивается свободное место. Вам достаточно знать, что они умеют хранить элементы и добавлять новые.

А вот ещё один пример абстракции. Вы работали с классом `Random`, 
когда изучали цикл `while`. Чтобы сгенерировать случайное число,
нужно вызвать метод `nextInt(int bound)`. 
А вот конкретный алгоритм, реализованный внутри этого класса и 
отвечающий за генерацию, знать совсем не обязательно.

## Создаём абстрактный класс

Абстрактный класс — это базовый класс, у которого не может быть экземпляров.
На его основе создаются обычные классы, объединённые общими чертами.

В абстрактном классе могут быть различные поля и даже конструкторы,
основное отличие заключается в методах. 
Наряду с конкретными методами он может содержать и абстрактные — заготовки 
методов без реализации (без тела метода), только с их описанием. 
То есть абстрактные заготовки с информацией о том, **что** сможет делать объект. 
А реализация методов, то есть то, **как** объект будет что-то делать, 
будет находиться в классах-наследниках этого абстрактного класса.

Рассмотрим, как устроены абстрактные классы и для чего они нужны, 
на примере жаб и лягушек. И те, и другие относятся к одному классу животных — амфибиям.
И действительно, у них много общих черт:
* строение тела (четыре конечности, голова и отсутствие хвоста),
* гастрономические предпочтения (они едят насекомых),
* способ размножения (откладывают икру) и прочее.

Но есть и различия. И те, и другие умеют передвигаться по суше и дышать,
правда, делают это разными способами:

* лягушки прыгают, а жабы ходят;
* лягушки дышат лёгкими и кожей, а жабы — только лёгкими.

Допустим, нам нужно написать программу, 
в которой будет два класса — `Frog` (англ. «лягушка») и `Toad` (англ. «жаба»). 
Если у этих классов не будет общего родителя, то, 
во-первых, у нас появится много повторяющегося кода, а во-вторых, 
не будет прослеживаться их сходство.

Удобнее будет создать общий для них класс `Amphibian` (англ. «амфибия») и 
перечислить в нём названия методов, которые относятся ко всем земноводным: 
есть, размножаться, передвигаться, дышать. 
Это и будет нашей заготовкой для будущих амфибий — абстрактный класс `Amphibian`! 
А `Frog` и `Toad` станут его классами-наследниками, 
в которых пропишем конкретную реализацию методов: прыгучесть для лягушек, 
ходьбу для жаб и так далее.

![img_5.png](img_5.png)

Пришло время объявить **абстрактный** класс. 
Для этого нужно указать специальное ключевое слово `abstract`:

```java
public abstract class Amphibian {
    
} 
```

Отлично! Получился абстрактный класс `Amphibian`, который будет описывать всех 
земноводных животных.

У абстрактных классов есть одна важная особенность: 
**у них не может быть объектов**.
В природе тоже из икры не может появиться какая-нибудь абстрактная амфибия — 
она всегда будет либо жабой, либо лягушкой (или другим конкретным представителем вида земноводных).

Создавать объекты, относящиеся к абстрактным классам, 
можно в классах-наследниках. Об этом расскажем дальше.



```java
public class Practicum {

    public static void main(String[] args) {
        Amphibian abstractAmphibian = new Amphibian();
    }
}

abstract class Amphibian {
    
}
```
```
Если же вы всё-таки попытаетесь в своей программе создать абстрактную амфибию, 
Java выдаст ошибку: “`Amphibian is abstract; cannot be instantiated`” 
(англ. «`Amphibian` — абстрактный класс; у него не может быть объектов»).

```

> 💡 В коде стандартной библиотеки Java есть много абстрактных классов. 
> Например, в классе AbstractList представлены заготовки методов, 
> которые реализованы в классе-наследнике ArrayList. 
> Коллекция LinkedList тоже наследуется от AbstractList, 
> поэтому набор её базовых методов такой же, как и у ArrayList, 
> но способ хранения данных внутри класса другой.


## Добавляем методы

Итак, вы объявили абстрактный класс `Amphibian`. 
Теперь добавим в него методы, которые в абстрактных классах могут быть двух видов:

* обычные (они пишутся с реализацией, которая будет общей для всех классов-наследников);
* и абстрактные (они указываются без реализации, потому что у каждого из классов-наследников она будет своя).

Рассмотрим каждый из них подробнее.

### Обычные методы в абстрактном классе
Если у группы разных объектов реализация какого-то действия совпадает, то её лучше написать сразу в абстрактном классе, внутри обычного метода. В таком случае не придётся дублировать один и тот же код во множестве классов.

Например, и лягушки, и жабы одинаковым образом реализуют метод `eat()` — и те, и другие с удовольствием едят насекомых. Поэтому можно сделать его общим. 
Для этого внутри абстрактного класса объявим обычный метод `eat()` и напишем его реализацию:

```java
public abstract class Amphibian {

    public void eat() { 
        System.out.println("Кушаю насекомых!");
    }
} 
```

Теперь метод `eat()` и его реализация будут общими для всех классов-наследников абстрактного класса `Amphibian`.

### Абстрактные методы в абстрактном классе

Как вы выяснили, у лягушек и жаб есть ещё и такие совпадающие 
действия — передвигаться по суше и дышать, но реализуют они их разными способами. 
Чтобы корректно отобразить это в программе, нам понадобятся **абстрактные методы**.

При объявлении абстрактного метода указывается только его 
сигнатура(_имя метода вместе с упорядоченным набором его параметров._) и 
тип возвращаемого значения, а тело не требуется.

Абстрактные методы дают информацию только о том, 
что сможет делать объект класса-наследника. Например, передвигаться по суше — `move()`. 
Информацию о том, как именно он будет это делать (прыгать или ходить),
будут содержать классы-наследники абстрактного класса `Amphibian` — `Frog` и `Toad`.

Чтобы объявить абстрактный метод, 
перед типом возвращаемого значения необходимо указать ключевое слово `abstract`. 
Тело метода при этом будет отсутствовать — вместо него ставится точка с запятой:

```java
public abstract class Amphibian {

    public void eat() { // обычный метод с реализацией
        System.out.println("Кушаю насекомых!");
    }

    public abstract void move(); // абстрактный метод без реализации
}
```

Метод `move()` будет общим для всех классов-наследников абстрактного класса `Amphibian`,
но реализовывать его они будут по-разному. Как именно — расскажем дальше.

Бывают случаи, когда разработчику нужно создать базовый класс с общей логикой. 
Тогда абстрактных методов в абстрактном классе может не быть.

Например, в математике есть фигура параллелограмм — четырёхугольник, 
у которого противоположные стороны попарно параллельны. 
Частные случаи параллелограмма — ромб, квадрат и прямоугольник.
У них есть два одинаковых свойства — высота и ширина, 
а также общий способ подсчёта площади фигуры.


![img_6.png](img_6.png)

В коде это можно представить следующим образом:

```java
public abstract class Parallelogram { // объявление абстрактного класса
    private double height; // высота
    private double width; // ширина

    // класс будет содержать только обычный метод
    // для нахождения площади
    public double getArea() { // 
        return height * width;
    }
}
```
Абстрактный класс, в котором есть только обычные методы, 
всё равно будет абстрактным. 
А вот если в обычном классе появится хотя бы один абстрактный метод — 
нужно будет этот класс объявить абстрактным, иначе возникнет ошибка.

### Создаём наследников абстрактного класса

Абстрактный класс — это только заготовка,
которая становится конкретной и реализуется в полной мере только в классах-наследниках.

Класс-наследник должен реализовать 
все унаследованные абстрактные методы, 
иначе при компиляции программы возникнет ошибка:
“`<Class name> is not abstract and does not override abstract method <method name> in 
<abstract class name`>” (англ. «[Класс] не является абстрактным и не переопределяет метод из [абстрактного класса]»).

От абстрактного класса `Amphibian` с помощью ключевого слова `extends` объявим 
два класса-наследника — `Frog` и `Toad`. 
И опишем в них реализацию абстрактного метода `move()`. 
Для этого укажем сигнатуру метода и напишем тело метода в фигурных скобках с 
аннотацией `@Override`:

`Frog.java`
```java
public class Frog extends Amphibian {

    @Override
    public void move() {
        System.out.println("Я передвигаюсь по суше прыжками.");
    }

}
```

`Toad.java`
```java
public class Toad extends Amphibian {

    @Override
    public void move() {
        System.out.println("Я важно хожу.");
    }

}
```

> Допустим, разработчик не хочет реализовывать в классе-наследнике 
> все абстрактные методы базового класса. 
> Тогда он обязательно должен объявить класс-наследник также абстрактным.


### Создаём объекты классов-наследников

У абстрактного класса не может быть объектов. 
Зато они могут быть у его классов-наследников.
И объявляются эти объекты через конструктор конкретного класса.

Например, чтобы создать экземпляр класса `Frog`, 
необходимо вызвать его конструктор `new Frog()`:

```java
public class Practicum {

    public static void main(String[] args) {
        Frog frog = new Frog();
        System.out.println("Привет! Я - зелёная лягушка.");
        frog.move();

        Toad toad = new Toad();
        System.out.println("Привет! Я - коричневая жаба.");
        toad.move();
    }

}
```

Обратите внимание, что при создании объектов в программе будет
вызван конструктор конкретного класса `Frog` или `Toad`, а не `Amphibian`.

Абстрактный класс содержит конструктор по умолчанию, 
но вы можете определить вместо него любые конструкторы с параметрами.

Например, создадим общую переменную `color` в абстрактном классе `Amphibian` и будем передавать в неё конкретный цвет из классов-наследников:

`Amphibian.java`
```java
public abstract class Amphibian {
    private String color;

    protected Amphibian(String color) {
        this.color = color;
    }

    public abstract void move();

    public abstract String getColor();

    public void eat() {
        System.out.println("Кушаю насекомых");
    }

}
```
У абстрактного класса `Amphibian` появился конструктор с параметром! 
До этого конструкторы по умолчанию классов-наследников обращались к
конструктору родителя без параметров. Но теперь его нет, поэтому возникнет ошибка.

Чтобы её исправить, необходимо доработать классы `Frog` и `Toad`. 
Они должны вызывать конструктор абстрактного класса с параметром `color`:

`Frog.java`

```java
public class Frog extends Amphibian {

    protected Frog() {
        super("зеленая");
    }

    @Override
    public void move() {
        System.out.println("Я передвигаюсь по суше прыжками.");
    }

    @Override
    public String getColor() {
        return color;
    }
}
```
`Toad.java`
```java
public class Toad extends Amphibian {

    protected Toad() {
        super("коричневая");
    }

    @Override
    public void move() {
        System.out.println("Я важно хожу.");
    }

    @Override
    public String getColor() {
        return color;
    }
}
```

Теперь, когда вы создаёте объекты классов `Frog` и `Toad`, 
вам не нужно указывать, зелёные они или коричневые.
Цвет находится внутри этих классов и одинаков для всех их объектов.

> Если у большинства классов-наследников 
> реализация какого-нибудь метода совпадает 
> — её можно перенести в абстрактный класс, чтобы избежать дублирования. 

Но при этом метод будет возвращать разное значение для разных классов: 
это будет зависеть от значения переменной color, переданной в конструктор.

Например, реализация метода `getColor()` у классов `Frog` и `Toad` получилась одинаковой.
Вынесем её в базовый класс `Amphibian`:

`Practicum.java`

```java
public class Practicum {

    public static void main(String[] args) {
        Frog frog = new Frog();
        System.out.println("Привет! Я - " + frog.getColor() + " лягушка.");
        frog.move();

        Toad toad = new Toad();
        System.out.println("Привет! Я - " + toad.getColor() + " жаба.");
        toad.move();
    }

}
```

`Amphibian.java`

```java
public abstract class Amphibian {
    protected String color;

    protected Amphibian(String color) {
        this.color = color;
    }

    public abstract void move();

    public String getColor() {
        return color;
    }

    public void eat() {
        System.out.println("Кушаю насекомых");
    }

}
```

`Frog.java`
```java
public class Frog extends Amphibian {

    protected Frog() {
        super("зеленая");
    }

    @Override
    public void move() {
        System.out.println("Я передвигаюсь по суше прыжками.");
    }

}
```
`Toad.java`
```java
public class Toad extends Amphibian {

    protected Toad() {
        super("коричневая");
    }

    @Override
    public void move() {
        System.out.println("Я важно хожу.");
    }

}
```
> Теперь классы-наследники могут использовать реализацию метода из родительского класса либо переопределить её.
</details>

<details>
<summary>Задание 1 </summary>

# Задание 1

В уроке вы столкнулись с задачей выбора методов будущего абстрактного класса. 
Такие решения лучше принимать до написания программы. 
Этот этап — проектирование будущего решения, отличает дилетантов от профессионалов. 
Теперь, опираясь на результаты этапа проектирования, 
вы можете реализовать свою иерархию классов для питомцев.

У любого домашнего питомца `Pet` есть несколько действий:

* спать `sleep()` (при вызове этого метода ваша программа должна выводить слово Сплю),
* играть `play()` (программа должна вывести Играю)
* издавать какой-то звук `giveVoice()`

а также свойство — количество лапок `pawsCount`.   

Дополнительно к базовым возможностям, 
кошка может поймать мышку `catchMouse()` (в этом случае выведите `Поймала мышку!`), 
хомяк — спрятать еду `hideFood()` (`Вся еда — в щёчках!`), 
а собака — принести палку `bringStick()` (`Принёс палочку, как хороший мальчик!`).

`Practicum.java`
```java
public class Practicum {

    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.catchMouse();
        cat.giveVoice();

        Dog dog = new Dog();
        dog.bringStick();
        dog.play();

        Hamster hamster = new Hamster();
        hamster.hideFood();
        hamster.sleep();

        Fish fish = new Fish();
        fish.sleep();

        Spider spider = new Spider();
        System.out.println("У паука " + spider.getPawsCount() + " лапок.");
    }

}
```

`Pet.java`
```java
public class Pet {
}
```

`Fish.java`
```java
public class Fish {
}
```

`Spider.java`
```java
public class Spider {
}
```
`Dog.java`
```java
public class Dog {
}
```

`Cat.java`
```java
public class Cat {
}
```

`Hamster.java`
```java
public class Hamster {
}
```

# Подсказки

* Чтобы объявить абстрактный класс, используйте ключевое слово `abstract`
перед объявлением класса — `public abstract class Pet`.
* Чтобы указать, что классы наследуется от абстрактного, 
используйте ключевое слово `extends` и название абстрактного класса — 
`public class Cat extends Pet`.
* Реализации методов `sleep()`, `play()` 
у всех питомцев совпадают — эти методы можно вынести в абстрактный класс
в виде обычных, не абстрактных методов.

* Во всех классах есть метод с одинаковой сигнатурой `giveVoice()`,
но значение, которое возвращает метод, отличается. 
Это можно выразить с помощью добавления в класс `Pet` 
конструктора с параметром `Pet(String voice)` и перенести метод в абстрактный класс.

* Ключевое слово `super` позволяет вызвать метод или конструктор суперкласса, 
а также обратиться к его полям. (Вызов конструктора класса-родителя через `super`
должен быть первой строкой в конструкторе класса-наследника.)

* Геттеры и сеттеры нужны для работы с полями класса, закрытыми модификатором private.

</details>


<details>
<summary>Интерфейсы в Java</summary>

# Интерфейсы в Java

Механизм наследования в Java очень удобен, но у него есть важное ограничение 
— **наследоваться можно только от одного класса**. 
Этот запрет поставлен для того, чтобы предотвратить ситуацию конфликтного наследования,
которая называется **проблемой ромба, или алмаза** (англ. _diamond problem_) и может возникать в языках с множественным наследованием.

> Встречается и более устрашающее название: убийственный ромб (алмаз) смерти (англ. deadly diamond of death).

Предположим, у нас есть абстрактный класс `Animal` (англ. «животное») с
абстрактным методом `eat()` (англ. «есть»). От класса `Animal` наследуются класс `Pet` 
(англ. «домашнее животное») и класс `Mammal` (англ. «млекопитающее»).

В каждом из них метод `eat()` реализован по-своему:
* «Кушаю еду, которую даёт мне хозяин!» — в классе `Pet`;
* «Кушаю еду, которую раздобуду сам!» — в классе `Mammal`.

Кроме этого, и у `Pet`, и у `Mammal` есть уникальные методы:

* `playWithToy()` (англ. «играть с игрушкой»), актуальный для домашних питомцев,
* `feedWithMilk()` (англ. «кормить потомство молоком»), характерный для млекопитающих.

А теперь представьте, что нам нужно создать ещё один класс — `Cat` (англ. «кошка»).
Он должен описывать кошку, которая является и млекопитающим, 
и домашним животным. 

В языке с множественным наследованием было бы удобно унаследовать класс `Cat` и от `Pet`,
и от `Mammal`, потому что кошка совмещает в себе 
уникальные методы и домашних питомцев, и млекопитающих.

Но и у `Pet`, и у `Mammal` есть общий метод `eat()` — с разными реализациями. 
Какую же из них в таком случае должен использовать класс `Cat` при вызове метода `eat()` 
у своего объекта?

![img_7.png](img_7.png)

Это и есть проблема ромба. Из-за неё программа бы не смогла выполнить метод `eat()`
и завершила бы работу с ошибкой. Или ещё хуже: выполнила бы не ту реализацию, 
на которую рассчитывал разработчик.
Именно поэтому в `Java` и запрещено множественное наследование: 
ещё на стадии компиляции будет выдана ошибка.

И всё же в некоторых случаях сложная иерархия необходима. 
Например, чтобы обозначить, что кошка — это и млекопитающее,
и домашний питомец. Для этого используют **интерфейсы**. Рассмотрим подробнее, что это такое.


## Что такое интерфейс

</details>