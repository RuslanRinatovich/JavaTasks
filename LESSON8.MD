# Урок 8. Статические поля и методы, константы и перечисления

<details>

<summary>О чем эта тема?</summary>

> Вы уже знакомы с модификаторами доступа ```public```, ```private```, 
> ```protected```, ```default```. > В Java есть ещё одна группа 
> ключевых слов, которую принято называть другими модификаторами (англ. non-access modifiers — «модификаторы не-доступа»). Они уведомляют JVM об особом поведении класса, метода или переменной. 

![S3_02_1695902792.png](L8%2FS3_02_1695902792.png)

В этой теме вы изучите два самых популярных модификатора этой группы 
— ```final``` и ```static```. 
А ещё вы узнаете: 
- какие есть особенности при работе со ```static```-полями и методами;
-  что такое enum и для чего он используется;
- как создать своё перечисление и использовать его элементы в конструкции ```switch```;
- как объявить константу.
</details>

<details>

<summary>Модификатор static</summary>

# Модификатор static

Вы уже встречали модификатор ```static``` (англ. «статический», «неподвижный»), 
когда объявляли метод ```main()```. Из этого урока вы узнаете, 
почему ```static``` обязателен для ```main()```, 
в каких случаях его нужно применять к другим методам и что будет, 
если добавить ```static``` в объявлении переменной.

## Переменная с модификатором static
Переменная, объявленная внутри класса с модификатором ```static```, называется **статической**, 
потому что она привязана исключительно к самому классу и существует независимо от 
его экземпляров. 

Если значение обычной переменной можно менять у каждого из объектов 
по отдельности, то статическая переменная является общей для всех экземпляров класса. 

Это значит, что:
- внутри класса существует только одна копия статической переменной;
- на её значение ссылаются все экземпляры класса;
- если изменить значение статической переменной, оно изменится у всех объектов класса.

Чтобы сделать переменную статической, при её объявлении нужно добавить слово ```static```. 
Модификатор доступа может быть любым: public, private или protected. 
Например, создадим статическую переменную, которая будет хранить значение, 
равное количеству крыльев у класса ```Bird``` (англ. «птица»):
```java
public class Bird {
    public static int numberOfWings = 2;
}
```
Теперь у экземпляров класса ```Bird``` будет по два крыла. 
Если мы увеличим значение статической переменной ```numberOfWings``` в два раза,
то количество крыльев удвоится одновременно у всех объектов. 
А без модификатора ```static``` нам пришлось бы менять значение переменной 
в каждом из них по отдельности. Или останавливать программу, вносить правку в код 
и запускать всё заново.

Обращаться к статическим переменным нужно через имя класса — в формате

```<имя класса>.<имя переменной>```. 

Ведь статическая переменная относится не к конкретному экземпляру, а к самому классу:

```java
public class Practicum {

    public static void main(String[] args) {
        Bird.numberOfWings = 4;
    }
}
```

Теперь добавим в класс ```Bird``` статическую переменную `count` и будем увеличивать её 
значение на единицу при создании нового объекта. 

Так как переменная `count` **статическая**, при создании нового объекта в конструкторе класса `Bird` её значение не перезаписывается заново, а увеличивается на единицу:

Запустите код. Затем уберите ключевое слово static и проверьте, изменился ли результат.

```java
public class Practicum {
    public static void main(String[] args) {

        Bird tweety = new Bird();
        Bird pepper = new Bird();
        Bird flossie = new Bird();
    }
}

class Bird {

    private static int count = 0;

    Bird() {
        count++;
        System.out.println("Количество созданных объектов: " + count);
    }
}
```
```commandline
Результат
Количество созданных объектов: 1

Количество созданных объектов: 2

Количество созданных объектов: 3
```
Итак, переменную нужно делать **статической**, если:
- её значение не зависит от объектов (например, в коде будильника «Бодрое утро»
всем объектам пригодится одинаковый параметр — название приложения, 
поэтому его можно записать в статическую переменную ```static String nameOfApp = "Бодрое утро");```
- её значение будет совместно использоваться всеми объектами одного класса (например, в статической переменной удобно хранить переключатель состояния персонажей: если в компьютерной игре применить к противникам эффект заморозки, все они должны одновременно замереть).

## Метод с модификатором static
```Static```-метод так же, как и ```static```-переменная, принадлежит классу, 
а не конкретному экземпляру, и может использоваться без создания объекта. 
Для того чтобы создать свой статический метод, достаточно при его объявлении 
добавить ключевое слово ```static```:

```java
public static void method() {
} 
```
Внутри класса к **статическому** методу можно обратиться так же, как к обычному, — по имени. 
А для внешнего вызова можно обратиться через имя класса ```<имя класса>.<имя метода>```.

Например, у класса ```Integer``` есть статический метод ```max(int a, int b)```, 
который определяет наибольшее из двух переданных чисел. Вот как его можно применить в коде:
```java
public class Practicum {

    public static void main(String[] args) {
        int max = Integer.max(5, 7);

        System.out.println(max);
    }
}
```

Чаще всего статические методы применяются в утилитарных _(англ. utility — «полезный»)_ 
задачах — они отвечают за выполнение полезных действий, которые не меняют состояние объекта. 
Например, в стандартной библиотеке Java есть класс ```Arrays``` (англ. «множества»). 

Внутри него можно найти статические методы для работы с массивами: сортировку, поиск, сравнение и другие. 
Представим, что у нас есть массив ```int[] buses``` (англ. _bus_ — «автобус») с номерами междугородных автобусов,
которые ездят из Ярославля в Кострому. 
Для вывода на экран всех значений воспользуемся статическим методом ```Arrays.toString(int[] a)```:

```java
import java.util.Arrays;

public class Practicum {

    public static void main(String[] args) {
        int[] buses = {123, 29, 500, 738, 960};
        System.out.println(Arrays.toString(buses));
    }
}
```

## Ограничения статических методов
1. >Статический метод может обращаться только к статическим переменным или методам
```java
public class Practicum {
    String aphorism = "Не рискуя, мы рискуем в сто раз больше.";

    public static void main(String[] args) {
        System.out.println(aphorism);
    }
}
```
Если запустить этот код, то будет получена ошибка. Нестатическая переменная `aphorism` так же, 
как и любая обычная переменная класса, находится внутри объекта. 
Обратиться к ней можно только через ссылку на этот экземпляр. 
А при вызове статического метода ссылка на объект не передаётся. 
Поэтому программа завершилась с ошибкой: “Non-static field ```aphorism``` cannot be referenced from a static context” 
(англ. «На нестатическое поле ```aphorism``` нельзя ссылаться из статического контекста»). 

Если сделать обычную переменную aphorism (англ. «афоризм») статической и запустить код ещё раз, то ошибки уже не будет.
```java
public class Practicum {
    static String aphorism = "Не рискуя, мы рискуем в сто раз больше.";

    public static void main(String[] args) {
        System.out.println(aphorism);
    }
}
```

2. > @Override и static несовместимы

Ещё одно правило: переопределять статические методы нельзя. 
Но вы можете объявить статический метод с одинаковой сигнатурой в родительском классе и классе-наследнике. 
Это один из вариантов сокрытия (_hiding_) — вы уже сталкивались с этим явлением в теме про наследование.

3. > Ключевые слова ```this``` и ```super``` запрещены в ```static```-методах

И последнее ограничение: внутри статического метода нельзя использовать ключевые слова ```this``` и ```super```. 
Потому что они относятся к конкретным объектам класса, 
а ```static```-методы — к самому классу.

Предположим, нам нужно создать класс для хранения фамилии и имени.
И в нём должен быть метод ```parse```, который на вход принимает строку, 
а на выходе возвращает объект класса ```PersonName```.

```java
public class PersonName {

    private String lastName;
    private String firstName;

    // возвращает PersonName из заданной строки:
    public static PersonName parse(String fullName) {
        /* Метод разделяет (англ. split) строку по символу пробела.
        В результате в переменной parts будет массив из двух элементов: фамилия, имя*/ 
        String[] parts = fullName.split(" "); 

        this.lastName = parts[0];
        this.firstName = parts[1];
        
        return this;
    }
}

```

Такой код не скомпилируется. 
Возникнет ошибка: “```PersonName.this``` cannot be referenced from a static context” 
(англ. «Нельзя ссылаться из статического контекста на ```PersonName.this```»).
Чтобы этот код выполнился, необходимо добавить явное создание объекта:

```java
public class Practicum {

    public static void main(String[] args) {
        PersonName name = PersonName.parse("Добронравова Юлия");

        System.out.println(name.getFullName());
    }
}

class PersonName {

    private String lastName;
    private String firstName;

    public PersonName(String lastName, String firstName) {
        this.lastName = lastName;
        this.firstName = firstName;
    }

    public String getFullName() {
        return lastName + " " + firstName;
    }

    public String getFirstName() {
        return firstName;
    }

    // возвращает PersonName из заданной строки:
    public static PersonName parse(String fullName) {
        String[] parts = fullName.split(" ");

        return new PersonName(parts[0], parts[1]);
    }
}
```

## Статический импорт

К переменным и методам с модификатором ```static``` можно обращаться ещё одним способом —
через **_статический импорт_** (англ. ```static import```). 
Благодаря ему со статическими переменными и методами другого класса можно работать как с внутренними.

Например, в этой программе для вычисления площади круга 
мы обращаемся к статической переменной PI на уровне класса:

```java
public class Practicum {
   public static void main(String args[]) {
      int radius = 5;
      double area = Math.PI * (radius * radius); // обращение к переменной PI
      System.out.println("Площадь круга равна: " + area);
   }
}
```
А вот эта же программа, но со статическим импортом:

```java
import static java.lang.Math.PI;

public class Practicum {
   public static void main(String args[]) {
      int radius = 5;
      double area = **PI** * (radius * radius); // обращение к переменной PI
      System.out.println("Площадь круга равна: " + area);
   }
}
```

Благодаря статическому импорту мы смогли обратиться к статической переменной ```PI``` не через класс, а как к обычной переменной. 

Будьте аккуратны: излишне частое использование статического импорта внутри одного куска кода может
сделать программу нечитаемой и неподдерживаемой. 
Используйте ```import static```, только когда вам нужен частый доступ к статическим членам из одного или двух классов. 

## Модификатор ```static``` перед методом ```main()```

JVM выполняет код, начиная с метода ```main()``` — это одно из основных соглашений, принятых разработчиками. 
Если бы не ```main()```, нам приходилось бы для каждой программы указывать метод старта. 

А слово ```static``` необходимо для того, чтобы проект мог запускаться без объектов. 
Иначе нужно было бы каждую программу сопровождать пояснениями о том, какие параметры передавать в конструкторы экземпляров. 

Каждый из модификаторов метода ```public static void main(String[] args)``` обязателен. 
Если не указать ```static```, программа будет скомпилирована без каких-либо ошибок.
Но потом, во время выполнения, JVM будет искать метод `main()` с уровнем доступа `public`, статический,
с типом возвращаемого значения `void` и массивом `String` в качестве аргумента. 

Если такой метод не будет найден, выполнение прервётся с ошибкой: 
“Main method not found in class `A`, please define the main method as: `public static void main(String[] args)`”
(англ. «Ошибка: основной метод не найден в классе `A`. Пожалуйста, определите основной метод как: 
`public static void main(String[] args)`»).



</details>

<details>

<summary>Задача 1</summary>

>Перед вами кусок кода компьютерной игры про Средневековье. 
> В ней есть много разных локаций, в том числе — смешанные леса с хвойными и лиственными деревьями. 
> Вам нужно создать симулятор такого леса, поселить в нём зайцев-беляков. 
> Обратите внимание, что цвет шести у всех зайцев  ```color``` меняется в зависимости от времени года 
> ```season```: зимой — белый, летом — серо-рыжий.
- класс `Practicum`
```java
import java.util.ArrayList;

public class Practicum {

    public static void main(String[] args) {
        ArrayList<MountainHare> hares = new ArrayList<>();
        hares.add(new MountainHare(4, 4.4, 120));
        hares.add(new MountainHare(7, 3.6, 150));
        hares.add(new MountainHare(1, 2.3, 100));

        System.out.println("В лесу лето!");
        // создайте объект "летний лес с зайцами"
       
        System.out.println("Список зайцев:");
        // напечатайте список всех зайцев

        System.out.println("В лесу зима!");
        // поменяйте время года на зиму

		System.out.println("Список зайцев:");
        // напечатайте список всех зайцев
    }

}
```

- класс `MountainHare`
```java
public class MountainHare {

    // добавьте переменные и конструктор

    @Override
    public String toString() {
        return "Заяц-беляк: " +
            "age=" + age +
            ", weight=" + weight +
            ", jumpLength=" + jumpLength +
            ", color=" + color +
            '.';
    }
}
```

- класс `Forest`
```java
import java.util.ArrayList;

public class Forest {
private ArrayList<MountainHare> hares;

    // объявите недостающие переменные и добавьте конструктор

    // добавьте метод setSeason(String newSeason)
    // в этом методе реализуйте логику смены цвета шубок зайцев-беляков

	    // добавьте метод printHares()
    
}
```
### Подсказки

- Так как цвет шерсти у всех зайцев одинаковый и меняется одновременно, 
переменная `color` должна быть статической. А остальные параметры индивидуальны для каждого зайца.
- Время года одинаково для всех лесов смешанного типа, 
поэтому переменная `season` должна быть статической. 
Чтобы запретить смену времени года без изменения цвета шубок, 
необходимо объявить эту переменную с модификатором `private`.
- Метод `setSeason(String newSeason)` должен быть статическим,
так как смена времени года не зависит от конкретного объекта леса. 
В этом методе реализуйте логику смены цвета шубок зайцев-беляков: 
если время года — `"зима"`, то цвет зайцев — `"белый"`, а иначе — `"серо-рыжий"`.
- Команда автогенерации `alt+Insert` (`⌘ + N`— для Mac OS X) поможет с конструкторами и сеттером.
- Печать списка зайцев можно реализовать с помощью цикла `for` по списку `(MountainHare hare : hares)`.
- Для того чтобы создать летний лес, воспользуйтесь сеттером и поменяйте сезон на `"лето"`.

</details>

<details>
<summary>Модификатор final</summary>
Одни элементы кода могут обновлять свои значения — например, обычные и ```static```-переменные,
а другие должны оставаться неизменными. Для всего, что в программе менять нельзя, есть модификатор 
```final``` (англ. «окончательный»).
Рассмотрим разницу между обычной переменной и final 
на примере птиц. Живая птица находится в постоянном движении. 
Она летает, поёт и меняет цвет оперения. 
Эти характеристики удобнее всего хранить в обычных переменных.
Другое дело — бронзовая птица. Статуэтки не меняются, и в этом их ценность. 
Если мы хотим, чтобы такая птица «застыла» в нашем коде, 
её положение нужно записать в ```final```-переменную. 

</details>