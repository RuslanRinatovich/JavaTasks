# Урок 8. Статические поля и методы, константы и перечисления

<details>

<summary>О чем эта тема?</summary>

> Вы уже знакомы с модификаторами доступа ```public```, ```private```, 
> ```protected```, ```default```. > В Java есть ещё одна группа 
> ключевых слов, которую принято называть другими модификаторами (англ. non-access modifiers — «модификаторы не-доступа»). Они уведомляют JVM об особом поведении класса, метода или переменной. 

![S3_02_1695902792.png](L8%2FS3_02_1695902792.png)

В этой теме вы изучите два самых популярных модификатора этой группы 
— ```final``` и ```static```. 
А ещё вы узнаете: 
- какие есть особенности при работе со ```static```-полями и методами;
-  что такое enum и для чего он используется;
- как создать своё перечисление и использовать его элементы в конструкции ```switch```;
- как объявить константу.
</details>

<details>

<summary>Модификатор static</summary>

# Модификатор static

Вы уже встречали модификатор ```static``` (англ. «статический», «неподвижный»), 
когда объявляли метод ```main()```. Из этого урока вы узнаете, 
почему ```static``` обязателен для ```main()```, 
в каких случаях его нужно применять к другим методам и что будет, 
если добавить ```static``` в объявлении переменной.

## Переменная с модификатором static
Переменная, объявленная внутри класса с модификатором ```static```, называется **статической**, 
потому что она привязана исключительно к самому классу и существует независимо от 
его экземпляров. 

Если значение обычной переменной можно менять у каждого из объектов 
по отдельности, то статическая переменная является общей для всех экземпляров класса. 

Это значит, что:
- внутри класса существует только одна копия статической переменной;
- на её значение ссылаются все экземпляры класса;
- если изменить значение статической переменной, оно изменится у всех объектов класса.

Чтобы сделать переменную статической, при её объявлении нужно добавить слово ```static```. 
Модификатор доступа может быть любым: public, private или protected. 
Например, создадим статическую переменную, которая будет хранить значение, 
равное количеству крыльев у класса ```Bird``` (англ. «птица»):
```java
public class Bird {
    public static int numberOfWings = 2;
}
```
Теперь у экземпляров класса ```Bird``` будет по два крыла. 
Если мы увеличим значение статической переменной ```numberOfWings``` в два раза,
то количество крыльев удвоится одновременно у всех объектов. 
А без модификатора ```static``` нам пришлось бы менять значение переменной 
в каждом из них по отдельности. Или останавливать программу, вносить правку в код 
и запускать всё заново.

Обращаться к статическим переменным нужно через имя класса — в формате

```<имя класса>.<имя переменной>```. 

Ведь статическая переменная относится не к конкретному экземпляру, а к самому классу:

```java
public class Practicum {

    public static void main(String[] args) {
        Bird.numberOfWings = 4;
    }
}
```

Теперь добавим в класс ```Bird``` статическую переменную `count` и будем увеличивать её 
значение на единицу при создании нового объекта. 

Так как переменная `count` **статическая**, при создании нового объекта в конструкторе класса `Bird` её значение не перезаписывается заново, а увеличивается на единицу:

Запустите код. Затем уберите ключевое слово static и проверьте, изменился ли результат.

```java
public class Practicum {
    public static void main(String[] args) {

        Bird tweety = new Bird();
        Bird pepper = new Bird();
        Bird flossie = new Bird();
    }
}

class Bird {

    private static int count = 0;

    Bird() {
        count++;
        System.out.println("Количество созданных объектов: " + count);
    }
}
```
```commandline
Результат
Количество созданных объектов: 1

Количество созданных объектов: 2

Количество созданных объектов: 3
```
Итак, переменную нужно делать **статической**, если:
- её значение не зависит от объектов (например, в коде будильника «Бодрое утро»
всем объектам пригодится одинаковый параметр — название приложения, 
поэтому его можно записать в статическую переменную ```static String nameOfApp = "Бодрое утро");```
- её значение будет совместно использоваться всеми объектами одного класса (например, в статической переменной удобно хранить переключатель состояния персонажей: если в компьютерной игре применить к противникам эффект заморозки, все они должны одновременно замереть).

## Метод с модификатором static
```Static```-метод так же, как и ```static```-переменная, принадлежит классу, 
а не конкретному экземпляру, и может использоваться без создания объекта. 
Для того чтобы создать свой статический метод, достаточно при его объявлении 
добавить ключевое слово ```static```:

```java
public static void method() {
} 
```
Внутри класса к **статическому** методу можно обратиться так же, как к обычному, — по имени. 
А для внешнего вызова можно обратиться через имя класса ```<имя класса>.<имя метода>```.

Например, у класса ```Integer``` есть статический метод ```max(int a, int b)```, 
который определяет наибольшее из двух переданных чисел. Вот как его можно применить в коде:
```java
public class Practicum {

    public static void main(String[] args) {
        int max = Integer.max(5, 7);

        System.out.println(max);
    }
}
```

Чаще всего статические методы применяются в утилитарных _(англ. utility — «полезный»)_ 
задачах — они отвечают за выполнение полезных действий, которые не меняют состояние объекта. 
Например, в стандартной библиотеке Java есть класс ```Arrays``` (англ. «множества»). 

Внутри него можно найти статические методы для работы с массивами: сортировку, поиск, сравнение и другие. 
Представим, что у нас есть массив ```int[] buses``` (англ. _bus_ — «автобус») с номерами междугородных автобусов,
которые ездят из Ярославля в Кострому. 
Для вывода на экран всех значений воспользуемся статическим методом ```Arrays.toString(int[] a)```:

```java
import java.util.Arrays;

public class Practicum {

    public static void main(String[] args) {
        int[] buses = {123, 29, 500, 738, 960};
        System.out.println(Arrays.toString(buses));
    }
}
```

## Ограничения статических методов
1. >Статический метод может обращаться только к статическим переменным или методам
```java
public class Practicum {
    String aphorism = "Не рискуя, мы рискуем в сто раз больше.";

    public static void main(String[] args) {
        System.out.println(aphorism);
    }
}
```
Если запустить этот код, то будет получена ошибка. Нестатическая переменная `aphorism` так же, 
как и любая обычная переменная класса, находится внутри объекта. 
Обратиться к ней можно только через ссылку на этот экземпляр. 
А при вызове статического метода ссылка на объект не передаётся. 
Поэтому программа завершилась с ошибкой: “Non-static field ```aphorism``` cannot be referenced from a static context” 
(англ. «На нестатическое поле ```aphorism``` нельзя ссылаться из статического контекста»). 

Если сделать обычную переменную aphorism (англ. «афоризм») статической и запустить код ещё раз, то ошибки уже не будет.
```java
public class Practicum {
    static String aphorism = "Не рискуя, мы рискуем в сто раз больше.";

    public static void main(String[] args) {
        System.out.println(aphorism);
    }
}
```

2. > @Override и static несовместимы

Ещё одно правило: переопределять статические методы нельзя. 
Но вы можете объявить статический метод с одинаковой сигнатурой в родительском классе и классе-наследнике. 
Это один из вариантов сокрытия (_hiding_) — вы уже сталкивались с этим явлением в теме про наследование.

3. > Ключевые слова ```this``` и ```super``` запрещены в ```static```-методах

И последнее ограничение: внутри статического метода нельзя использовать ключевые слова ```this``` и ```super```. 
Потому что они относятся к конкретным объектам класса, 
а ```static```-методы — к самому классу.

Предположим, нам нужно создать класс для хранения фамилии и имени.
И в нём должен быть метод ```parse```, который на вход принимает строку, 
а на выходе возвращает объект класса ```PersonName```.

```java
public class PersonName {

    private String lastName;
    private String firstName;

    // возвращает PersonName из заданной строки:
    public static PersonName parse(String fullName) {
        /* Метод разделяет (англ. split) строку по символу пробела.
        В результате в переменной parts будет массив из двух элементов: фамилия, имя*/ 
        String[] parts = fullName.split(" "); 

        this.lastName = parts[0];
        this.firstName = parts[1];
        
        return this;
    }
}

```

Такой код не скомпилируется. 
Возникнет ошибка: “```PersonName.this``` cannot be referenced from a static context” 
(англ. «Нельзя ссылаться из статического контекста на ```PersonName.this```»).
Чтобы этот код выполнился, необходимо добавить явное создание объекта:

```java
public class Practicum {

    public static void main(String[] args) {
        PersonName name = PersonName.parse("Добронравова Юлия");

        System.out.println(name.getFullName());
    }
}

class PersonName {

    private String lastName;
    private String firstName;

    public PersonName(String lastName, String firstName) {
        this.lastName = lastName;
        this.firstName = firstName;
    }

    public String getFullName() {
        return lastName + " " + firstName;
    }

    public String getFirstName() {
        return firstName;
    }

    // возвращает PersonName из заданной строки:
    public static PersonName parse(String fullName) {
        String[] parts = fullName.split(" ");

        return new PersonName(parts[0], parts[1]);
    }
}
```

## Статический импорт

К переменным и методам с модификатором ```static``` можно обращаться ещё одним способом —
через **_статический импорт_** (англ. ```static import```). 
Благодаря ему со статическими переменными и методами другого класса можно работать как с внутренними.

Например, в этой программе для вычисления площади круга 
мы обращаемся к статической переменной PI на уровне класса:

```java
public class Practicum {
   public static void main(String args[]) {
      int radius = 5;
      double area = Math.PI * (radius * radius); // обращение к переменной PI
      System.out.println("Площадь круга равна: " + area);
   }
}
```
А вот эта же программа, но со статическим импортом:

```java
import static java.lang.Math.PI;

public class Practicum {
   public static void main(String args[]) {
      int radius = 5;
      double area = **PI** * (radius * radius); // обращение к переменной PI
      System.out.println("Площадь круга равна: " + area);
   }
}
```

Благодаря статическому импорту мы смогли обратиться к статической переменной ```PI``` не через класс, а как к обычной переменной. 

Будьте аккуратны: излишне частое использование статического импорта внутри одного куска кода может
сделать программу нечитаемой и неподдерживаемой. 
Используйте ```import static```, только когда вам нужен частый доступ к статическим членам из одного или двух классов. 

## Модификатор ```static``` перед методом ```main()```

JVM выполняет код, начиная с метода ```main()``` — это одно из основных соглашений, принятых разработчиками. 
Если бы не ```main()```, нам приходилось бы для каждой программы указывать метод старта. 

А слово ```static``` необходимо для того, чтобы проект мог запускаться без объектов. 
Иначе нужно было бы каждую программу сопровождать пояснениями о том, какие параметры передавать в конструкторы экземпляров. 

Каждый из модификаторов метода ```public static void main(String[] args)``` обязателен. 
Если не указать ```static```, программа будет скомпилирована без каких-либо ошибок.
Но потом, во время выполнения, JVM будет искать метод `main()` с уровнем доступа `public`, статический,
с типом возвращаемого значения `void` и массивом `String` в качестве аргумента. 

Если такой метод не будет найден, выполнение прервётся с ошибкой: 
“Main method not found in class `A`, please define the main method as: `public static void main(String[] args)`”
(англ. «Ошибка: основной метод не найден в классе `A`. Пожалуйста, определите основной метод как: 
`public static void main(String[] args)`»).



</details>

<details>

<summary>Задача 1</summary>

>Перед вами кусок кода компьютерной игры про Средневековье. 
> В ней есть много разных локаций, в том числе — смешанные леса с хвойными и лиственными деревьями. 
> Вам нужно создать симулятор такого леса, поселить в нём зайцев-беляков. 
> Обратите внимание, что цвет шести у всех зайцев  ```color``` меняется в зависимости от времени года 
> ```season```: зимой — белый, летом — серо-рыжий.
- класс `Practicum`
```java
import java.util.ArrayList;

public class Practicum {

    public static void main(String[] args) {
        ArrayList<MountainHare> hares = new ArrayList<>();
        hares.add(new MountainHare(4, 4.4, 120));
        hares.add(new MountainHare(7, 3.6, 150));
        hares.add(new MountainHare(1, 2.3, 100));

        System.out.println("В лесу лето!");
        // создайте объект "летний лес с зайцами"
       
        System.out.println("Список зайцев:");
        // напечатайте список всех зайцев

        System.out.println("В лесу зима!");
        // поменяйте время года на зиму

		System.out.println("Список зайцев:");
        // напечатайте список всех зайцев
    }

}
```

- класс `MountainHare`
```java
public class MountainHare {

    // добавьте переменные и конструктор

    @Override
    public String toString() {
        return "Заяц-беляк: " +
            "age=" + age +
            ", weight=" + weight +
            ", jumpLength=" + jumpLength +
            ", color=" + color +
            '.';
    }
}
```

- класс `Forest`
```java
import java.util.ArrayList;

public class Forest {
private ArrayList<MountainHare> hares;

    // объявите недостающие переменные и добавьте конструктор

    // добавьте метод setSeason(String newSeason)
    // в этом методе реализуйте логику смены цвета шубок зайцев-беляков

	    // добавьте метод printHares()
    
}
```
### Подсказки

- Так как цвет шерсти у всех зайцев одинаковый и меняется одновременно, 
переменная `color` должна быть статической. А остальные параметры индивидуальны для каждого зайца.
- Время года одинаково для всех лесов смешанного типа, 
поэтому переменная `season` должна быть статической. 
Чтобы запретить смену времени года без изменения цвета шубок, 
необходимо объявить эту переменную с модификатором `private`.
- Метод `setSeason(String newSeason)` должен быть статическим,
так как смена времени года не зависит от конкретного объекта леса. 
В этом методе реализуйте логику смены цвета шубок зайцев-беляков: 
если время года — `"зима"`, то цвет зайцев — `"белый"`, а иначе — `"серо-рыжий"`.
- Команда автогенерации `alt+Insert` (`⌘ + N`— для Mac OS X) поможет с конструкторами и сеттером.
- Печать списка зайцев можно реализовать с помощью цикла `for` по списку `(MountainHare hare : hares)`.
- Для того чтобы создать летний лес, воспользуйтесь сеттером и поменяйте сезон на `"лето"`.

</details>

<details>

<summary>Модификатор final</summary>

Одни элементы кода могут обновлять свои значения — например, обычные и ```static```-переменные,
а другие должны оставаться неизменными. Для всего, что в программе менять нельзя, 
есть модификатор ```final``` (англ. «окончательный»).
Рассмотрим разницу между обычной переменной и ```final``` на примере птиц. 
Живая птица находится в постоянном движении. Она летает, поёт и меняет цвет оперения. 
Эти характеристики удобнее всего хранить в обычных переменных.
Другое дело — бронзовая птица. Статуэтки не меняются, и в этом их ценность. 
Если мы хотим, чтобы такая птица «застыла» в нашем коде, 
её положение нужно записать в `final`-переменную.

### Переменная с модификатором `final`
Если при объявлении переменной добавить модификатор `final`,
то после инициализации её значение станет окончательным — изменить его будет нельзя. Например:

```java
public class Practicum {
 
    public static void main(String[] args) {
        final String figureOfEarth = "spherical"; // инициализация final-переменной 
        figureOfEarth = "flat"; // попытка изменить значение final-переменной

        System.out.println(figureOfEarth);
    }
}

```
Такая программа вызовет ошибку, поскольку идет попытка присвоить новое значение `final`-переменной.
```
submission/Practicum.java:5: error: cannot assign a value to final variable figureOfEarth

        figureOfEarth = "flat"; // попытка изменить значение final-переменной

        ^

1 error
```
> Мы попытались присвоить переменной `figureOfEarth` (от англ. «форма Земли») 
> новое значение `"flat"`, и программа завершила работу с ошибкой. 
> Потому что `figureOfEarth` — это `final`-переменная, а значит, она может быть проинициализирована только один раз.


Для переменных с примитивным типом это правило работает всегда. Если же `final`-переменная ссылается на объект,
то ситуация более сложная:
- состояние объекта менять можно;
- а вот присваивать `final`-переменной другой объект нельзя.

Запустите программу и посмотрите, как меняется состояние объекта,
на который ссылается `final`-переменная `incomeBook` (от англ. «книга доходов»):
```java
import java.util.ArrayList;
import java.util.List;

public class Practicum {

    public static void main(String[] args) {
				
				// инициализация final-переменной:
        final List<Integer> incomeBook = new ArrayList<>();
        
        System.out.println(sum(incomeBook));

        // изменение состояния объекта:
        incomeBook.add(4300);
        incomeBook.add(1500);

        System.out.println(sum(incomeBook));
    }

    public static int sum(List<Integer> list) {
        int sum = 0;

        for (int i : list) {
            sum = sum + i;
        }

        return sum;
    }
}

```
Попробуем переменной `incomeBook` после её инициализации присвоить другой объект.
Например, добавим строку: `incomeBook` = new ArrayList<>();.
```java
import java.util.ArrayList;
import java.util.List;

public class Practicum {

    public static void main(String[] args) {
				
				// инициализация final-переменной:
        final List<Integer> incomeBook = new ArrayList<>();
        
        System.out.println(sum(incomeBook));

        // изменение состояния объекта:
        incomeBook.add(4300);
        incomeBook.add(1500);
        incomeBook = new ArrayList<>(); // попытка final-переменной присвоить новый объект 
        System.out.println(sum(incomeBook));
    }

    public static int sum(List<Integer> list) {
        int sum = 0;

        for (int i : list) {
            sum = sum + i;
        }

        return sum;
    }
}
```
> при запуске этой программы мы получим ошибку, так как пытаемся `final`-переменной присвоить новый объект


```
submission/Practicum.java:16: error: cannot assign a value to final variable incomeBook

        incomeBook = new ArrayList<>();

        ^

1 error
```


Переменную с модификатором `final` необязательно инициализировать сразу.
Это можно сделать в любой момент после её объявления и до первого применения в коде.
Будьте аккуратны: любое присвоенное ей значение станет финальным.
Например, добавим инициализацию переменной `yearOfBirth` (от англ. «год рождения») после объявления:

```java
import java.util.ArrayList;
import java.util.List;

public class Practicum {

    public static void main(String[] args) {
        final int yearOfBirth; // объявление final-переменной
        yearOfBirth = 1989;
        System.out.println("Я родился в " + yearOfBirth + " году."); // первое применение final-переменной
    }
}

```

Есть ещё одно правило. Переменная с модификатором `final` уровня класса обязательно должна 
быть проинициализирована:
- при объявлении — если значение для всех объектов одинаково;
- или в теле конструктора — если значение для каждого экземпляра класса уникально.

При этом и в том, и в другом случае у каждого из объектов будет своё финальное поле,
а не общее, как в случае с модификатором `static`.

Если вы запустите этот код, возникнет ошибка.
```java
public class Practicum {

    private final int busTicket = 990;
    private final int airplaneTicket;
    private final int trainTicket;

    public Practicum() {
        this.airplaneTicket = 3590;
    }

    public int getTotalPrice() {
        return busTicket + airplaneTicket + trainTicket;
    }

    public static void main(String[] args) {
        Practicum practicum = new Practicum();
        System.out.println("Расходы на транспорт в путешествии: " + practicum.getTotalPrice() + " р.");
    }
}
```
Появится ошибка, поскольку мы пытаемся обратиться к значению переменной `trainTicket`, которая не проинициализирована.
```
submission/Practicum.java:9: error: variable trainTicket might not have been initialized

    }

    ^

1 error

```
На практике такой вариант инициализации финальных переменных уровня класса, 
как у  `busTicket` из примера выше, встречается редко. 
Обычно такие переменные инициализируют значением из входных параметров конструктора.

### Метод с модификатором `final`

Модификатор `final` защищает метод от переопределения в подклассе. 
Это значит, что реализация метода самодостаточна и завершена — 
дорабатывать или менять его в дочернем классе нельзя.
Допустим, у нас есть класс `Bicycle` (англ. «велосипед»). 
От него можно унаследовать подклассы для велосипедов с разными спецификациями:
- спортивных или шоссейных;
- двух-, трёх- или четырёхколёсных и т. д.

Но независимо от вида велосипеда, он обязательно должен делать две вещи:
- снижать скорость — если велосипедист нажимает на тормоз,
- и разгоняться — если активно крутятся педали.

Поэтому метод торможения `applyBrake` и 
метод разгона `speedUp` можно объявить с модификатором `final`, 
чтобы их нельзя было переопределить.

```java
public class Bicycle {
    
    protected int speed;
        
    public final void applyBrake() {
        speed--;
    }
        
    public final void speedUp() {
        speed++;
    }
}
```

А вот к `private`-методам применять ключевое слово `final` 
не нужно — их и без него никогда и нигде нельзя переопределять. 
К конструктору тоже нет необходимости добавлять `final`,
потому что он никогда не наследуется.

### Класс с модификатором `final`

Чтобы запретить наследование класса, объявите его `final`. 
Тогда создать от него подклассы будет невозможно.

Посмотрите на этот код:

```java
public final class Bicycle {
}

public class MountainBike extends Bicycle {
} 
```

Так как класс `Bicycle` объявлен с модификатором `final`, от него нельзя наследоваться.

На этапе компиляции программа завершится с ошибкой:
“Cannot inherit from final `Bicycle`” (англ. «У класса `Bicycle` не может быть подклассов».)

А ещё все его методы тоже становятся `final`. Это логично: раз от класса нельзя ничего наследовать, то и переопределить его методы не получится.

> 📌 Если автор кода создал класс с модификатором `final`, 
> значит, он хотел, чтобы его структура оставалась 
> постоянной из соображений логики или безопасности.

Вы уже встречались с `final`-классами. 
Как правило, это классы-обёртки: `Integer`, `Boolean`, `Double` и другие.
</details>

<details>
<summary>Константы</summary>

Переменная — не единственный способ хранения данных в программе. 
Есть ещё «постоянная», или **константа** (англ. _constant_), — она называется так, потому что изменить её значение во время работы программы невозможно.

Вы наверняка встречались с константами в школе — на уроках математики, химии или физики. 
Там константами называются величины, которые не меняются никогда: 
скорость света в вакууме или число π.


В отличие от них, константы в программировании постоянны 
только во время выполнения программы. Например, в коде онлайн-магазина может б
ыть константа для хранения минимальной суммы заказа: `MIN_ORDER_PRICE = 1000;`.
Если через год количество покупателей вырастет и затраты на логистику снизятся, 
эту сумму можно будет уменьшить. Разработчик просто заменит в коде
значение константы `MIN_ORDER_PRICE = 500;` и выпустит новую версию приложения.

В этом уроке мы расскажем о том, как создавать и правильно применять константы.

### Как сделать переменную константой

В стандартной библиотеке Java есть много констант. Вот некоторые из них:
* `MIN_VALUE` (минимальное значение) и `MAX_VALUE` (максимальное значение) класса `Integer`,
* `TRUE` и `FALSE` класса `Boolean` и многие другие.

Программист может не только обращаться к стандартным константам, «зашитым» в язык программирования, но и создать свои.

Константа в Java — это статическое финальное поле. 
Чтобы его создать, примените модификаторы static и final. 
И обязательно инициализируйте его при объявлении. Делается это так:

```java
static final тип ИМЯ_КОНСТАНТЫ = значение; // объявление и инициализация константы
```
> Если не инициализировать `static final` константу сразу — произойдёт ошибка компиляции.

При этом порядок написания модификаторов не имеет значения: `static final` или `final static`.
И в том, и в другом случае мы получим константу.

```java
public static final double PI = 3.14; // объявление и инициализация числа π 
```
Для имён констант в Java принято использовать стиль **SCREAMING_SNAKE_CASE** 
(англ. «регистр кричащей змеи») — слова внутри имени пишутся в верхнем регистре 
и разделяются символом подчёркивания. 
Благодаря этому константы можно быстро отличить от обычных переменных:

```java
static final int MAX_VALUE = 1000; //это константа
static final String PLAN_IDENTIFICATOR = "planId"; // и это константа

final double length = 4.5; // финальная переменная
boolean isCompleted = false; // логическая переменная
```
![img.png](img.png)


Переменную с модификатором `final` тоже можно назвать **константой**. 
Она константна на уровне отдельных объектов, при этом её значение для каждого из них может быть разным.

Например, в классе `Cat` можно создать финальную переменную `final String furColor;`.
В конструкторе объектов у `firstCat` ей будет присвоено значение `"grey"`, а у `secondCat` — `"white"`. 
И в том, и в другом случае переменная `furColor` — неизменяемая, 
но значения у неё при этом разные.

А константы, которые объявляются через `static final`, общие для всех объектов.
У того же класса `Cat` может быть константа `static final SOUND = "МЯУ!"`, и она будет храниться в единственном экземпляре для всех объектов класса.

![img_1.png](img_1.png)

### Значения констант

В константе может храниться не только единичное значение, 
но и полноценное выражение, включающее обращения к другим статическим полям или вызовы статических методов. Такие выражения помогают улучшить читаемость кода.

Представьте, что вы участвуете в разработке приложения, 
с помощью которого можно бронировать отели по всему миру и оставлять о них отзывы. 
Вам нужно поставить ограничение на максимальный размер загружаемого фото — 5 Мбайт. 
В Java основная единица измерения при работе с файлами — байт, 
поэтому допустимый размер файла необходимо преобразовать в байты.
Есть два основных варианта действий:

* завести константу с единичным значением: `static final int MAX_FILE_SIZE = 5242880;`
* или поместить в неё выражение: `static final int MAX_FILE_SIZE = 5 * 1024 * 1024;`.

В первом случае программисту придётся посчитать значение в калькуляторе и 
вписать это огромное число в константу. 
А тот, кто будет работать с кодом после него, вряд ли сможет сразу понять, 
сколько мегабайтов прячется за этими цифрами.

Если же в константу `MAX_FILE_SIZE` записать выражение, 
оно вычислится один раз и сохранится в памяти компьютера. 
Любой программист, которому потом понадобится уточнить, 
каким может быть максимальный размер файла, 
сразу поймёт, что это 5 Мбайт. Ещё один плюс: изменить значение такой константы очень легко. 
Например, чтобы увеличить её до 10 Мбайт, достаточно заменить в выражении `5` на `10`. 
И никакой калькулятор не нужен!

### Применение
Константы помогают бороться с **магическими**, 
то есть не понятно что означающими числами (от англ. _magic numbers_) в коде.
Посмотрите на этот метод:

```java
public class Registration {

    public void validateCredentials(String phone, String password) {
        if (phone.length() != 11) {
            System.out.println("Введите номер в формате 7xxxxxxxxxxx, где x - любая цифра.");
        }
        if (password.length() < 8) {
            System.out.println("Минимальная длина пароля: 8 знаков.");
        }
    }
}
```

В нём есть две проблемы:
* Во-первых, чтобы понять, что такое 11 и 8, вам нужно прочитать весь код. 
Это и есть магические числа.
* Во-вторых, если мы захотим изменить одно из них, например, 
значение минимальной длины пароля, нужно будет искать это число и менять его во всём коде. 
Потому что это значение используется не только в условии оператора `if`, 
но и в сообщении, которое выводится на экран пользователя. А теперь представьте,
что у вас не два магических числа, а несколько десятков, и все они разбросаны по
разным строчкам кода.
* 

Чтобы исправить это, нужно добавить в метод константы с подходящими именами.

Вынесем магические числа в константы с именами `MIN_PASSWORD_LENGTH` и `PHONE_LENGTH`.

```java

public class Registration {
   public static final int MIN_PASSWORD_LENGTH = 8;
  public static final int PHONE_LENGTH = 11;
    public static void validateCredentials(String phone, String password) {
        if (phone.length() != PHONE_LENGTH) {
            System.out.println("Введите номер в формате 7xxxxxxxxxxx, где x - любая цифра.");
        }
        if (password.length() < MIN_PASSWORD_LENGTH) {
            System.out.println("Минимальная длина пароля: 8 знаков.");
        }
    }

    public static void main(String[] args) {
        validateCredentials("7901000000", "Qwerty");
    }
}

```

Обратите внимание, что строки из метода `println()` в общем случае не выносятся в константы, 
потому что их назначение и так понятно. 
Но если какой-то текст в программе повторяется слишком часто, то можно и его сделать константой.

</details>

<details>
<summary>Задание 2</summary>

Во всех банковских приложениях есть возможность перевода денег. 
Как правило, прежде чем выполнить перевод, система должна проверить, 
правильно ли введены все необходимые данные.
Ваша задача — реализовать класс `TransactionValidator`, 
в котором будет находиться логика проверки суммы перевода. 
Минимальная сумма перевода — `MIN_AMOUNT` (1 р.), 
максимальная сумма перевода — `MAX_AMOUNT` (5000 р.).

### Practicum
```java
import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Пожалуйста, введите сумму перевода в рублях.");
        // считайте сумму перевода при помощи scanner.nextDouble()

        boolean isValid = ... // добавьте вызов метод isValidAmount
        if (isValid) 
            System.out.println("Спасибо! Ваш перевод на сумму " + amount + " р. успешно выполнен.");
        }
    }
}
```
### TransactionValidator
```java
public class TransactionValidator {
    // объявите константы

    // объявите метод isValidAmount()
    // внутри метода добавьте проверки на минимальную и максимальную сумму перевода
    System.out.println("Минимальная сумма перевода: " + ... + " р. Попробуйте ещё раз!");
    System.out.println("Максимальная сумма перевода: " + ... + " р. Попробуйте ещё раз!");
}

```


### Подсказки

* Метод `isValidAmount` нужно сделать статическим.
* Метод `isValidAmount` на вход будет принимать сумму перевода, а на выходе возвращать `true`, если все проверки успешно пройдены, или `false`, если обнаружены ошибки.
* Для объявления констант используйте модификаторы `public static final`.
* Сумма перевода может содержать цифры после запятой.
* Константы должны быть не только в выражении `if`, но и в сообщениях об ошибке.

</details>

<details>
<summary>Перечисляемый тип enum</summary>


Кроме примитивов и классов, в Java есть специальный тип данных, 
который называется **перечисление** (англ. _enumerated type_, «перечисляемый тип»).
Он нужен для хранения множества значений — но не любого, а ограниченного.

Вот примеры таких ограниченных множеств: четыре времени года, семь нот, четыре стороны света, 
семь дней недели, двенадцать месяцев и так далее. 
В этом уроке вы научитесь создавать перечисления и узнаете, как с ними работать.

### Как создать перечисление
Для объявления перечисления применяется ключевое слово `enum`. 
После него пишется имя в UpperCamelCase, 
а затем в фигурных скобках перечисляются элементы ограниченного множества — списком, 
через запятую.
Например, перечисление дней недели выглядит так:

```java
public enum DayOfWeek {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```
Все элементы перечисления принято писать как константы: 
в верхнем регистре, разделяя слова внутри названий символами подчёркивания.
Дело в том, что перечисляемый тип по сути — это и есть список логически связанных констант. 
Ведь количество сторон света или времён года вряд ли когда-нибудь изменится.

Поэтому иногда значения перечисления так и называют: константы перечисления. 
Каждая из них — `static final` и не может быть изменена после создания.
![img_2.png](img_2.png)

Создадим перечисление `TrafficLight`, состоящее из трёх сигналов стандартного светофора:
красного (red), жёлтого (yellow) и зелёного (green).
```java
// объявите перечисление
enum TrafficLight {
    RED,
    YELLOW,
    GREEN
} 

```

Чтобы создать перечисление в IntelliJ IDEA:
* в структуре текущего проекта выберите New → Java Class;
* в появившемся окне введите имя нового файла (оно должно совпадать с названием перечисления) и выберите тип Enum.

![img_3.png](img_3.png)

### Переменная с типом `enum`
Так же, как создаются переменные с типом `String` или `int`, 
можно создавать переменные с типом объявленного перечисления. 
В такой переменной можно, например, хранить жанр фильма.


```java

public class Film {
    String title;
    FilmGenre genre;
}

enum FilmGenre {
    FAMILY, // семейный
    COMEDY, // комедия
    DOCUMENTARY, // документальный
    DRAMA, // драма
    HORROR, // фильм ужасов
    FANTASY, // фантастический
    THRILLER // триллер
}

```

Значение переменной `genre`, как и других переменных c типом `enum`, 
нужно инициализировать в упрощённом виде — без оператора `new`.
```java
FilmGenre genre = FilmGenre.COMEDY;

```

Это связано с тем, что переменной с типом enum можно присвоить только то значение,
которое определено в перечислении, а значит, 
существует в единственном экземпляре на всю программу. 
В примере с фильмами переменной genre можно присвоить
только одно из значений перечисления `FilmGenre`.

Элементы перечисления можно сравнивать друг с другом с помощью оператора `==`. 
На этом строится фильтр фильмов по определённому жанру:

```java
import java.util.ArrayList;

public class Practicum {

    public static void main(String[] args) {
        ArrayList<Film> films = new ArrayList<>();
        films.add(new Film("Зелёная миля", FilmGenre.DRAMA));
        films.add(new Film("Побег из Шоушенка", FilmGenre.DRAMA));
        films.add(new Film("Властелин колец: Братство Кольца", FilmGenre.FANTASY));
        films.add(new Film("Король Лев", FilmGenre.FAMILY));

        filterByGenre(films, FilmGenre.FAMILY);
    }

    // метод для фильтрации списка фильмов по жанру:
    public static void filterByGenre(ArrayList<Film> films, FilmGenre genre) {
        for (Film film : films) {
            // Сравнение жанра фильма из списка с искомым жанром:
            if (film.getGenre() == genre) {
                System.out.println(film.getTitle());
            }
        }
    }
}

class Film {
    private String title;
    private FilmGenre genre;

    public Film(String title, FilmGenre genre) {
        this.title = title;
        this.genre = genre;
    }

    public String getTitle() {
        return title;
    }

    public FilmGenre getGenre() {
        return genre;
    }
}

enum FilmGenre {
    FAMILY, // семейный
    COMEDY, // комедия
    DOCUMENTARY, // документальный
    DRAMA, // драма
    HORROR, // фильм ужасов
    FANTASY, // фантастический
    THRILLER // триллер
}

```
```
Результат
Король Лев
```

</details>

<details>
<summary>Задача 3
</summary>
Перед вами часть программы для хранения списка задач с приоритетом. Приоритет (англ. _task priority_) может быть:
* высокий (англ. high) — `TaskPriority.HIGH`,
* средний (англ. medium) — `TaskPriority.MEDIUM`,
* низкий (англ. low) — `TaskPriority.LOW`.
Вам нужно реализовать поиск задач с наивысшим приоритетом из предложенного списка.

### class Practicum
```java
// импортируйте нужные пакеты

public class Practicum {

    public static void main(String[] args) {
        ArrayList<Task> tasks = new ArrayList<>();
        tasks.add(new Task(TaskPriority.HIGH, "Оплатить интернет."));
        tasks.add(new Task(TaskPriority.LOW, "Сходить в парикмахерскую."));
        tasks.add(new Task(TaskPriority.MEDIUM, "Выбрать подарок подруге на ДР."));
        tasks.add(new Task(TaskPriority.MEDIUM, "Купить билеты в театр."));
        tasks.add(new Task(TaskPriority.HIGH, "Посетить вебинар по английскому языку."));
        tasks.add(new Task(TaskPriority.LOW, "Купить пылесос."));

        System.out.println("Задачи с наивысшим приоритетом на сегодня:");
        ... // цикл for для поиска задач
    }
}
```
### class Task
```java
public class Task {

    ... // добавьте переменную priority с приоритетом задачи
    private String description;

    ...// добавьте конструктор класса

    ... // добавьте метод get для приоритета

    public String getDescription() {
        return description;
    }
}
```

### перечисление TaskPriority
```java
... // добавьте перечисление TaskPriority
```


### Подсказки

* Для работы со списками вам понадобятся импортировать класс `ArrayList`.
* Для хранения значений приоритета создайте перечисление `TaskPriority`.
* Цикл `for` поможет перебрать все дела в списке.
* Для поиска задач с максимальным приоритетом `TaskPriority.HIGH`воспользуйтесь оператором `==`.

</details>

<details>
<summary>Работа с перечислениями</summary>

</details>